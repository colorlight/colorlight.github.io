<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[堆利用系列之开篇]]></title>
    <url>%2F2021%2F06%2F17%2F%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[堆利用系列之开篇前言堆利用这块内容相对独立但是类型较多，希望本系列文章能够让读者掌握堆利用的一些通用方法，建立堆利用的基本知识体系。堆是一块需要动态管理的内存，glibc是实现堆管理的库，为了效率更高的管理堆，引入了很多机制，这就给利用堆破坏漏洞实现代码执行提供了很多攻击面。但是，相比于栈破坏的利用，堆本身就很复杂，需要理解堆的一些关键部分的工作原理，才能更好的写出利用代码，因此我们这篇文章先学习了解下堆的基本概念和关键实现原理。 关于libc的版本 malloc和calloc相关的代码都在libc中，但是不同libc版本，malloc的差异性可能会很大，导致需要利用不同的利用方式来针对同一种类型的漏洞。因此，在利用之前一定要搞清楚libc的版本，是uclibc还是glibc，以及具体的子版本号。 Malloc Chunk 首先我们要学习一下Chunk的基本概念 当我们在调用malloc的时候，就会返回一个指针指向一个chunk 我们的测试代码 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void main(void)&#123; char *ptr; ptr = malloc(0x10); strcpy(ptr, &quot;panda&quot;);&#125; 我们可以看到在panda的前面是有一块描述区的，这一块也是chunk的一部分，我们可以把它叫做metadata部分，他主要是由一块标识前一个chunk大小的和一个表示当前chunk大小的部分组成。在64位中，一个标识的长度是8个字节，在32位中则是4个字节。 1230x0: 0x00 - Previous Chunk Size0x8: 0x21 - Chunk Size0x10: &quot;pada&quot; - Content of chunk 我们可能会发现，在本例中标识前一个块的大小的是0x0，这是什么意思，这个主要是根据chunk size这个字段的标识0x21，说明前面一个紧邻的chunk是被使用了，因此previouschunksize这个字段实际上是上一个chunk的数据区部分。换句话说，根据chunk size字段的最后一位的不同，chunk的结构的意义是不一样的，但是大小是不变的。 Chunk size字段的最后一位是标志着前面一块是否在使用的，1代表着在使用，0代表着没有使用 对于被释放的Chunk，他还有两个字段是用来指向在bin链表中相邻的chunk的，注意bin链表中相邻与实际上的相邻chunk是不一样的。有的bin链表是双向链表，需要使用fd和bk两个字段，有的链表是单向链表，只需要使用fd字段，bk无意义。 Bins heap中有各种各样的Bin数据结构，当一个chunk被释放了，会被bin数据结构记录，一般是一个链表。根据被释放的chunk的大小，将他们放到不同的bin中，主要有下面几种bin Fast bin： Unsorted bin Small bin Large bin 这个数据结构可以加快下一次分配chunk的时候更加迅速，直接在这些bin中先寻找合适的chunk Fast bin 在x64中，Fastbin chunk的大小是从0x20，到0x80。Fastbin共有7个链表组成，每个链表上维护的chunk的大小都是相同的，通过GEF的 heap bins fast可以方便的查看各个fast bin链表上的情况 12345678────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────Fastbins[idx=0, size=0x10] ← Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE) ← Chunk(addr=0x602030, size=0x20, flags=PREV_INUSE)Fastbins[idx=1, size=0x20] ← Chunk(addr=0x602050, size=0x30, flags=PREV_INUSE)Fastbins[idx=2, size=0x30] ← Chunk(addr=0x602080, size=0x40, flags=PREV_INUSE)Fastbins[idx=3, size=0x40] ← Chunk(addr=0x6020c0, size=0x50, flags=PREV_INUSE)Fastbins[idx=4, size=0x50] ← Chunk(addr=0x602110, size=0x60, flags=PREV_INUSE)Fastbins[idx=5, size=0x60] ← Chunk(addr=0x602170, size=0x70, flags=PREV_INUSE)Fastbins[idx=6, size=0x70] ← Chunk(addr=0x6021e0, size=0x80, flags=PREV_INUSE) 注意要分清楚Fast chunk和fast bin是不同的概念，fast chunk的意思是放在fast bin链表上的chunk。fastbin本身实际上是一个数组，数组的每个元素是一个fast bin链表指针，fast bin链表指针指向heap中的chunk的地址，而chunk中有fd指针，又指向了下一个free chunk，因此这样就形成了一个单向链表。当插入chunk的时候是从头部开始插入的，就是先入后出的。 tcache 这个数据结构是在2.26版本中新引入的，每一个线程都会有一个tcache,目的是不需要再多线程中操作heap的时候给bin加锁，这样就可以更加的迅速。tcache是在分配chunk的时候的第一优先考虑的分配来源，甚至比fast bin还要优先。 tcache的数据结构与Fast bin类似，都是一个单向链表，都是先入后出的。相关的数据结构源码 12345678910111213141516typedef struct tcache_entry&#123;struct tcache_entry *next;/* This field exists to detect double frees. */struct tcache_perthread_struct *key;&#125; tcache_entry;typedef struct tcache_perthread_struct&#123;uint16_t counts[TCACHE_MAX_BINS];tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;static __thread bool tcache_shutting_down = false;static __thread tcache_perthread_struct *tcache = NULL; static __thread tcache_perthread_struct *tcache这个是个全局变量，直接指向了这个tcache数据结构，应该是每个线程都会维护以这个这个全局变量。 tcache_perthread_struct中包含了一个tcache_entry数组，元素有64个，代表着64个链表，也就是说以供会有64个单向链表组成一个tcache，每个链表上也是与fast bin一样都是记录的相同大小的某个size的chunk。但是与fastbin不一样的是，单向链表的长度是有限制的，不能超过7，当超过7个的时候就会往对应的bin上进行分流，同样可以通过GEF的heap bins tcache去查看。64个链表维护的chunk大小范围为0x20-0x410,间隔是0x10. Unsorted， Large 和 Small bins Unosrted, Large 和 Small bins联系的比较紧密，他们都是在一个数组中的，而fastbin 和tcache都是有自己单独的数组的。 12 /* Normal bins packed as described above */mchunkptr bins[NBINS * 2 - 2]; bins这个数组中的第0个元素空置，第一个元素就是指向unsorted bin list的指针，紧接着的62个元素都是指向samll bin 链表的指针，后面63个指向的是Large bin链表的指针。 如下图所示的结构图 Unsorted bin链表，这个主要是用来存放刚被释放的chunk，被free释放掉的chunk并不会直接回到对应small bin或者large bin中，而是先回到unsorted bin，以供后面malloc的时候更加快速的使用。 这是一个双向链表，与fast bin链表不同是它多了一个bk指针 这个链表上的大小并不是固定的，任何大小的chunk都可以到这个链表上来 当出现malloc_consolidate，就是一次对heap的整理，就会把unsorted bin重新放到各自对应chunk size的链表上 Small bin的每个链表存放的元素的大小的都是相同的，对于大小不大于0x400(64bit)的chunk会被放置在这个链表上 Large Bin使用来存放超过0x400大小的chunk的，但是这些链表上的chunk的大小并不一定是相同的，而是有一个范围的，比如对于0x400到0x420(仅举例)的chunk都放在第一个large bin的链表上。 Top chunk 是在当前在用的堆区的最顶部，它不是属于任何一个bin，是一个之前调用mmap或者sbrk从内核中分配的内存还剩下未用的区域。如果用户请求的size在所有的bin和tcache中都没有满足，就会从top chunk开始分配，剩下的未用的chunk则是新的top chunk。 如果当前用户请求的size连top chunk都满足不了，则会继续调用系统调用mmap或者sbrk扩展堆区，就是扩展top chunk。然后再把chunk返回给用户。 top chunk是所有分配的源头，第一个malloc肯定是从top chunk中分配的，因为此时所有的bin和tcache都是空的 各种bin和chunk在内存中的示意图 malloc_chunk就是chunk header，是一个chunk的开头，无论malloced或者空闲的都有这个header. Main Arena Main Arena实际上就是一个对heap的抽象的数据结构，它包含了对各种bin的定义，tcache的定义，top chunk的定义，都是在这个数据结构中的，它在初始化的时候是作为一个全局变量保留在全局区域的。 当我们在GEF中调用heap相关的各种命令实际上都是通过对这个变量的读取来解析的。123456789101112131415161718192021222324252627gef➤ heap bins [+] No Tcache in this version of libc ────────────────────── Fastbins for arena 0x7ffff7dd1b20 ────────────────────── Fastbins[idx=0, size=0x10] ← Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE) Fastbins[idx=1, size=0x20] 0x00 Fastbins[idx=2, size=0x30] 0x00 Fastbins[idx=3, size=0x40] 0x00 Fastbins[idx=4, size=0x50] 0x00 Fastbins[idx=5, size=0x60] 0x00 Fastbins[idx=6, size=0x70] 0x00 ───────────────────── Unsorted Bin for arena &apos;main_arena&apos; ───────────────────── [+] Found 0 chunks in unsorted bin. ────────────────────── Small Bins for arena &apos;main_arena&apos; ────────────────────── [+] Found 0 chunks in 0 small non-empty bins. ────────────────────── Large Bins for arena &apos;main_arena&apos; ────────────────────── [+] Found 0 chunks in 0 large non-empty bins. gef➤ x/20g 0x7ffff7dd1b20 0x7ffff7dd1b20 &lt;main_arena&gt;: 0x0 0x602000 0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0 0x0 0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0 0x0 0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0 0x0 0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0 0x0 0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0 0x602120 0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0 0x7ffff7dd1b78 0x7ffff7dd1b90 &lt;main_arena+112&gt;: 0x7ffff7dd1b78 0x7ffff7dd1b88 0x7ffff7dd1ba0 &lt;main_arena+128&gt;: 0x7ffff7dd1b88 0x7ffff7dd1b98 0x7ffff7dd1bb0 &lt;main_arena+144&gt;: 0x7ffff7dd1b98 0x7ffff7dd1ba8 Consolidation 由于多次的释放和malloc会不可避免的出现很多小的chunk，这就有可能有两个连续的chunk虽然都是空闲的，但是由于是两个独立的chunk，在malloc使用的时候并不能将他们作为一个chunk返回，因此就会降低内存的使用效率，为了减少碎片，就需要在合适的时候将这些相邻的空闲块给合并成一个大的chunk。 合并的函数就是malloc_consolidate, 调用它的时候就会对空闲块进行合并，那么这个函数的调用条件有什么呢 malloc large bin的时候，当需要很大的chunk的时候，就会调用这个函数先进行一次合并，看看会不会多出来一些可以用的chunk。 当top chunk中的空间不够用的时候 free函数之后，会对chunk进行前后合并，如果这个合并后的chunk size大于FASTBIN_CONSOLIDATION_THRESHOLD，也会调用一次 与堆利用相关的 我们前面先简单介绍了一下与堆相关的一些基本概念，虽然没有覆盖完全，但是与堆利用相关的已经基本列出，更加详细的认知需要在漏洞利用的过程中再去学习。 下面列出对漏洞利用的知识体系的基本框架 我们要想进行堆利用，就需要首先发现一个与堆相关的漏洞，UAF，堆溢出，double free这些，然后我们通过这个漏洞去修改一些chunk，这些chunk肯定是属于某个bin 链表或者tcache中，然后我们再借用house的各种方法去实现更复杂的利用方法。虽然还有很多方法没有列出，但是我们可以先掌握这些最基本的，这也是我在这个系列文章中要覆盖到的一些方法。 参考 https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/ https://guyinatuxedo.github.io/25-heap/index.html?search= http://jcs.iie.ac.cn/ch/reader/create_pdf.aspx?file_no=20180101&amp;flag=1&amp;year_id=2018&amp;quarter_id=1 版权声明本文作者为colorlight，首发于安全客 https://www.anquanke.com/post/id/241239]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2021-31802 NETGEAR R7000 httpd PreAuth RCE]]></title>
    <url>%2F2021%2F04%2F27%2FCVE-2021-31802%20Netgear%20R7000%20preAuth%20RCE%2F</url>
    <content type="text"><![CDATA[TL;DRCVE-2021-31802 is my first CVE assignment, Thanks @d4rkn3ss for his brilliant work. I learn a lot from his work. Thanks @SecuriTeam_SSD for their professional work, they help me to get the CVE assignment within a month, which I never got a response from MITRE by myself. Vulnerability SummaryThis vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R7000 routers. Authentication is not required to exploit this vulnerability.The vulnerability exists within the handling of http request, the issue results from the lack of proper validation of user-supplied data, which can result a heap overflow. An attacker can leverage this vulnerability to execute code with the root privilege. Affected SystemsNetgear Nighthawk R7000 running firmware version 1.0.11.116 and before Vulnerability Root Cause AnalysisI bypass the patch for the ZDI-20-709 vulnerability, so I get this vulnerability. The patch for ZDI-20-709 cannot solve the root cause of the vulnerability. The httpd program allows user to upload a file with the url /backup.cgi. While the root cause of the vulnerability is that the program uses two variables to represent the length of the uploaded file.One variable is related to the value of the Content-length in the http post request header, the other one is the length of the file content in the http post request body. The vulnerability exists in the sub_16674. Below picture is the heap overflow point:The decompiled code is like this: The program allocates memory for storing the file content by calling malloc，the return value is stored by dword_1DE2F8, the size is the value of Content-Length plus 600. The Content-Length value can be controlled by the attacker, thus if we provide a proper value, we can make the malloc to return any size of the heap chunk we want. The memcpy function copies the http request payload from s1 to dword_1DE2F8, the copied buffer length is v80 - v91 which is the length of the file content in the http post request body. So this is the problem, the size of the heap-based buffer dword_1DE2F8 can by controlled by the attacker with a small value, and the v80-v91 can also by controlled with another larger value. Thus, it can cause a heap overflow. Exploit ConsiderationsThe patch for ZDI-20-709 is that it adds a check for one byte before Content-Length, it checks if it is a &#39;\n&#39;, I simply add a &#39;\n&#39; before the Content-Length in order to bypass the patch. Though the vulnerabilities are basically the same, but the exploit still needs a lot of efforts because the heap states are different between R6700 and R7000. We may conduct a fastbin dup attack to the heap overflow vulnerability. But it is not easy to do this. Fastbin dup attack needs two continuous malloc function to get two return address from a same fastbin list, the first malloc returns the chunk whose fd pointer is overwritten by the heap overflow, the second malloc returns the address where we want to write data. The bigest problem is that there should be no free procedure between these two malloc functions. But dword_1DE2F8 is checked every time before malloc:If dword_1DE2F8 is not a null pointer, it will be freed and set 0. Thus we should find another point of calling malloc. Luckily, there is another malloc whose size can by controlled by us, it is in the function of sub_A5B68The function handles another file upload http request, we may use the /genierestore.cgi to trigger this function. But there is another problem, both /genierestore.cgi and /backup.cgi requests can cause the fopen function gets called. The fopen function will call malloc(0x60) and mallloc(0x1000). malloc(0x1000) will cause __malloc_consolidate function gets called which will destroy the fastbin, since the size is larger than the value of max_fast. We need to find a way to change the max_fast value to a large value so that the __malloc_consolidate will not be triggered. According to the implemenation of uClibc free function:1234567891011121314 if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast)#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don&apos;t place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) &#123; set_fastchunks(av); fb = &amp;(av-&gt;fastbins[fastbin_index(size)]); // &lt;-------when size is set 8 bytes, the fastbin_index(size) is -1 p-&gt;fd = *fb; *fb = p; &#125; When we free a chunk whose size is 0x8, fastbin_index(size) return -1, and av-&gt;fastbins[fastbin_index(size)] will cause an out-of-bounds access.12345678910struct malloc_state &#123; /* The maximum chunk size to be eligible for fastbin */ size_t max_fast; /* low 2 bits used as flags */ // 0 /* Fastbins */ // 4 mfastbinptr fastbins[NFASTBINS]; ...&#125; According to the struct of malloc_state, fb = &amp;(av-&gt;fastbins[-1]) exactly points to max_fast, thus *fb = p will make the max_fast to a large value.But in the normal situation, the chunk size cannot be 0x8 bytes, because it means that the user data is 0 byte. So we can first make use of the heap overflow vulnerability to overwrite the PREV_INUSE flag of a chunk so that it incorrectly indicates that the previous chunk is free. Due to the incorrect PREV_INUSE flag, we can get malloc() to return a chunk that overlaps an actual existing chunk. This lets us edit the size field in the existing chunk’s metadata, setting it to the invalid value of 8. When this chunk is freed and placed on the fastbin, malloc_stats-&gt;max_fast is overwritten by a large value.Then the fopen will not lead to a __malloc_consolidate, so we can conduct a fastbin dup attack.Once we make the malloc return a chosen address, we could overwrite the GOT entry of the free to the address of system PLT code. Finally we execute utelnetd -l /bin/sh to start the telnet service, then we get the root shell of R7000. I use some techniques to make the exploit more steady. To make the malloc chunks are adjacent so that the heap overflow will not corrupt other heap-based buffers, I send a very long payload to trigger closing the tcp connection in advance so that the /backup.cgi request will not calling fopen subsequently, and there will be no other malloc calling between two http requests. The httpd program’s heap state may be different when user login or logout the web management, to make the heap state consistent，I find that when I try to login the web management with wrong password for 3 times, the httpd program will redirect the user to a Router Password Reset page. I can make use of this feature to achieve a steady heap state. Reference SSD Advisory – NETGEAR Nighthawk R7000 httpd PreAuth RCE CVE-2021-31802 ZDI-20-709: HEAP OVERFLOW IN THE NETGEAR NIGHTHAWK R6700 ROUTER]]></content>
      <categories>
        <category>IoT Security</category>
      </categories>
      <tags>
        <tag>IoT Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捉虫日记漏洞总结]]></title>
    <url>%2F2020%2F10%2F10%2F%E6%8D%89%E8%99%AB%E6%97%A5%E8%AE%B0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言最近阅读了捉虫日记这本少有的讲述漏洞挖掘方法的书籍，本书虽然只有7个漏洞，但是对每个漏洞到底是如何发现的做了很详细的说明，还原了漏洞挖掘的思维过程，笔者认为这是本书最有价值的一块内容，现在大部分的文章都是讲述了漏洞原理但是对于漏洞是如何发现的内容涉及很少。漏洞的发现过程是比较琐碎的，甚至难以回忆，很容易忘记当时的发现的思路历程，所以比较难成文，笔者也将努力将原书中我比较喜欢的几个漏洞的ROOT CAUSE和如何找到做一些简单的总结。 0x00 ESCAPE FROM WWW ZONE漏洞 ROOT CAUSE由于有错误条件是两个方式共同表示的，返回值和一个参数值，当出现错误条件的时候，只设置了其中一个条件（返回值）忘记设置了参数，由于对同一个错误状态的两种表达方式不同步，最终导致这个oob 如何发现这个漏洞 观察错误条件是否是两个因素或者多个因素决定的，对于这种编程范式就可以好好审计 构造好fuzz条件，fuzz 输入payload 0x01 NULL POINTER FTW漏洞 ROOT CAUSE由于对长度信息的处理不恰当，将一个unsigned 类型直接赋值给 有符号的变量，对这个长度信息所做的任何判断大小比较都会存在风险。 如何发现这漏洞对于TLV格式的数据，定位抽取长度的变量，观察这个变量是否赋给了有符号的变量，不需要对所有的类型转换进行审计，只需要对这种标识长度的变量的类型转换进行审计就行。这种有符号的比较大小本身就是容易出问题，有符号的比较就要考虑到小于0的情况 漏洞利用造成的是NULL pointer derefernce，但是这个并不是制造成了dos，还造成了控制ip，由于这个空指针应用的偏移是可控的，所以可以落到got表中，对got表的修改，即可以在紧接着的call 目标got表函数时造成劫持 0x02 ONE KERNEL TO RULE THEM ALL 漏洞 ROOT CAUSEmemcpy函数的第一个参数是任意可变的，即使n是固定值，直接实现了write what where 如何发现这个漏洞 作者还是通过跟踪数据流向的方法在静态的审计函数的处理流程，重点关注了与长度相关的处理逻辑，但是这个漏洞不需要dst与n的不同步即可触发，或者可以理解为是不同步的一种特殊情况，由于dst是任意的，所以永远与n不同步。 除了仔细审计与长度相关的代码，还需要注意的是当涉及到与memcpy这种dst，src，和copy数目相关的函数的时候，一定要重点关注dst和num这两个值，要关注dst的来源是什么，是否和num同步，是否可能造成溢出，像这个漏洞是否dst是直接由用户指定的，这都是根据dst的来源而定的 0x03 A BUG OLDER THAN 4.4BSD 漏洞 ROOT CAUSE从payload中转化的长度信息，赋值给了有符号数，对有符号的比较，比较绕过，导致越界的访问 如何发现这个漏洞 在追踪数据流的时候，不仅对数据的长度信息关注，还需要对任何数目相关的字段关注，这些字段的比较大小是容易出错的 特别这些数目是有符号数的比较，是非常危险的，一定要注意小于0的情况是否是预期内的 0x04 THE RINGTONE MASSACRE漏洞 Fuzz方法变异策略 通过对一个合法的文件格式进行逐个字节的0xff替换 这种变异策略是相对高效的，可以找到一些简单的有关长度的漏洞，而且不需要对格式协议有详细的了解，smb也可以尝试利用同样的方法进行一些测试。 小结本文主要是对书中几个漏洞的根因进行了提炼，对根因的理解抽象才能够举一反三，所以漏洞原因也尽量精简，笔者也在整理漏洞挖掘方法，但是由于分析的漏洞数量不够多，还不好拿出分享，等到分析足够多的漏洞，到时会以makdown map的形式展示出。以后也会经常以本篇文章的形式分析一系列漏洞。 版权声明本文作者为colorlight，转载请注明出处 https://colorlight.github.io]]></content>
      <categories>
        <category>漏洞挖掘方法</category>
      </categories>
      <tags>
        <tag>如何发现漏洞</tag>
        <tag>ROOT CAUSE</tag>
        <tag>Fuzz 变异策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪造LTE地震海啸警报]]></title>
    <url>%2F2020%2F07%2F29%2F%E4%BC%AA%E9%80%A0LTE%E5%9C%B0%E9%9C%87%E6%B5%B7%E5%95%B8%E8%AD%A6%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[前言这是我在2019年的HITB和DEFCON China的议题的解读，现在同步到我的blog上 议题摘要本议题将讨论LTE协议中与PWS(Public Warning System公共预警系统)相关的安全漏洞。 PWS是向公众播报地震海啸以及其他紧急事件的预警系统，在灾难发生前，PWS系统可以为人民的生命安全争取极其宝贵的时间。我们仔细研究了LTE协议中与PWS相关部分，发现LTE空口中承载的预警信息是不经过加密以及完整性保护的，我们通过常用的软件无线电设备即可以仿造虚假的灾难预警信息，并且成功的迫使支持PWS的Android和iPhone手机发出灾难警报。通过对LTE协议中参数的精心配置，我们还实现了将灾难警报信息伪装成诈骗钓鱼以及广告短信的形式。最后我们提出了一些相应的解决办法，来防止PWS系统沦为摆设甚至成为电信诈骗的工具。 议题解析3GPP协议中规定了4种公共警报系统，分别是日本的ETWS，美国的CMAS，韩国的KPAS以及欧洲的EU-Alert。由于各个国家的安全要求不同，因此标准化工作较为困难。为了避免系统复杂性，防止漫游到其他国家手机不能正常接收警报信息，目前的标准中并未加入对警报信息的签名等验证信息。我们利用软件无线电设备USRP B210和开源的LTE测试平台srsLTE搭建LTE伪基站。为了不干扰正常用户的通信，我们的实验选择在了电磁屏蔽屋内进行。为了能够使手机发起小区重选流程，我们搭建的伪基站的参数要尽量模仿合法基站的设置，可以利用一些常用的路测软件获取当前基站的参数，如TAC PCI以及下行频点号。由于LTE的小区重选机制相对于GSM等系统较为严格，即使信号强度高于合法基站，仍然难以触发手机的小区重选，我们可以选在优先频点或者将物理小区号设置成与合法基站相同的以增加接入成功率。为了避免手机发起鉴权流程，要将TAC设置成与合法基站一样的，手机无法发起位置区更新，则不会对伪基站的合法性进行甄别。LTE协议中直接携带警报信息内容的是系统广播信息System information，其中SIB 10携带的是日本的ETWS的第一级警报信息，此信息仅包含固定的警报消息类型，如地震海啸或者其他紧急警报。SIB 11中携带的是ETWS的第二级警报信息，包含具体的警报内容，如地震中心，地震强度等，此信息是自定义的。SIB 12是携带的CMAS KPAS和EU-ALERT警报消息。由于ETWS相较于其他系统分为两个等级的警报信息，较为复杂，我们以ETWS为例进行伪造警报消息。除了SIB10 SIB11直接携带警报消息外，SIB 1负责对SIB10以及SIB11的调度，paging消息负责向用户手机提示有警报消息需要接收。由于srsLTE中没有针对SIB10的定义与实现，我们需要比照协议对SIB10进行构造，其中messageIdentifer字段标识了消息类型，地震警报需要将此值设置为0x1102。其他参数的具体配置可以参看截图。我们需要在srsLTE源码中添加对paging消息的修改，使paging消息中增加对ETWS警报信息的指示。其实我们不仅可以利用ETWS消息发送地震警报，我们甚至可以它改造成一个广告诈骗等垃圾短信。将message identifier字段设置为0x1104就可以使手机不发出警报声，但是仍弹出信息内容。以上是我们在Google Pixel手机上分别伪造的地震警报信息和添加了钓鱼电话的诈骗信息。由于中国没有在手机移动网络中支持公共报警服务，因此国内版的Android手机并不会对伪造的警报信息作出响应，同时国行版的苹果手机也仅在MCC为001,MNC为01的测试网络中对警报信息作出响应。公共警报信息的不加密造成的潜在安全威胁还是较大的，如果在人口密集处如满座的球场内发送警报信息有可能导致踩踏事件。2018年的夏威夷导弹误警报就是基于美国的PWS系统CMAS传播的，这导致了全城的恐慌和社会混乱。目前可以利用非对称加密的机制对警报信息添加签名信息来防止恶意伪造的虚假警报。由于各国对警报消息的要求不同，3GPP的警报的标准化进行较为困难，导致数字签名验证机制并没有作为一种强制执行要求，所以现在的手机均是不验证警报消息的合法性的。 攻击演示 参考链接 HAXPO: This is a Public Service Announcement: Hacking LTE Public Warning Systems WARNING: Magnitude 10 Earthquake Is Coming in One Minute 安全客|HITB议题解读 | 伪造LTE地震海啸警信息 HAXPO D1 - Hacking LTE Public Warning Systems - Weiguang Li.pdf 版权声明本文作者为colorlight，首发于安全客转载请注明出处 https://colorlight.github.io/2020/07/29/伪造LTE地震海啸警报/]]></content>
      <categories>
        <category>LTE security</category>
      </categories>
      <tags>
        <tag>PWS</tag>
        <tag>LTE安全</tag>
        <tag>伪造地震消息</tag>
      </tags>
  </entry>
</search>
