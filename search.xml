<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CVE-2021-31802 NETGEAR Nighthawk R7000 httpd PreAuth RCE]]></title>
    <url>%2F2021%2F04%2F27%2FCVE-2021-31802%20Netgear%20R7000%20preAuth%20RCE%2F</url>
    <content type="text"><![CDATA[CVE-2021-31802 NETGEAR Nighthawk R7000 httpd PreAuth RCETL;DRThis is my first CVE assignment, Thanks @d4rkn3ss for his brilliant work. I learn a lot from his work. Thanks @SecuriTeam_SSD for their professional work, they help me to get the CVE assignment within a month, which I never got a response from MITRE by myself. Vulnerability SummaryThis vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R7000 routers. Authentication is not required to exploit this vulnerability.The vulnerability exists within the handling of http request, the issue results from the lack of proper validation of user-supplied data, which can result a heap overflow. An attacker can leverage this vulnerability to execute code with the root privilege. Credit@Colorlight2019 Affected SystemsNetgear Nighthawk R7000 running firmware version 1.0.11.116 and before Vulnerability Root Cause AnalysisI bypass the patch for the ZDI-20-709 vulnerability, so I get this vulnerability. The patch for ZDI-20-709 cannot solve the root cause of the vulnerability. The httpd program allows user to upload a file with the url /backup.cgi. While the root cause of the vulnerability is that the program uses two variables to represent the length of the uploaded file.One variable is related to the value of the Content-length in the http post request header, the other one is the length of the file content in the http post request body. The vulnerability exists in the sub_16674. Below picture is the heap overflow point:The decompiled code is like this: The program allocates memory for storing the file content by calling malloc，the return value is stored by dword_1DE2F8, the size is the value of Content-Length plus 600. The Content-Length value can be controlled by the attacker, thus if we provide a proper value, we can make the malloc to return any size of the heap chunk we want. The memcpy function copies the http request payload from s1 to dword_1DE2F8, the copied buffer length is v80 - v91 which is the length of the file content in the http post request body. So this is the problem, the size of the heap-based buffer dword_1DE2F8 can by controlled by the attacker with a small value, and the v80-v91 can also by controlled with another larger value. Thus, it can cause a heap overflow. Exploit ConsiderationsThe patch for ZDI-20-709 is that it adds a check for one byte before Content-Length, it checks if it is a &#39;\n&#39;, I simply add a &#39;\n&#39; before the Content-Length in order to bypass the patch. Though the vulnerabilities are basically the same, but the exploit still needs a lot of efforts because the heap states are different between R6700 and R7000. We may conduct a fastbin dup attack to the heap overflow vulnerability. But it is not easy to do this. Fastbin dup attack needs two continuous malloc function to get two return address from a same fastbin list, the first malloc returns the chunk whose fd pointer is overwritten by the heap overflow, the second malloc returns the address where we want to write data. The bigest problem is that there should be no free procedure between these two malloc functions. But dword_1DE2F8 is checked every time before malloc:If dword_1DE2F8 is not a null pointer, it will be freed and set 0. Thus we should find another point of calling malloc. Luckily, there is another malloc whose size can by controlled by us, it is in the function of sub_A5B68The function handles another file upload http request, we may use the /genierestore.cgi to trigger this function. But there is another problem, both /genierestore.cgi and /backup.cgi requests can cause the fopen function gets called. The fopen function will call malloc(0x60) and mallloc(0x1000). malloc(0x1000) will cause __malloc_consolidate function gets called which will destroy the fastbin, since the size is larger than the value of max_fast. We need to find a way to change the max_fast value to a large value so that the __malloc_consolidate will not be triggered. According to the implemenation of uClibc free function:1234567891011121314 if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast)#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don&apos;t place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) &#123; set_fastchunks(av); fb = &amp;(av-&gt;fastbins[fastbin_index(size)]); // &lt;-------when size is set 8 bytes, the fastbin_index(size) is -1 p-&gt;fd = *fb; *fb = p; &#125; When we free a chunk whose size is 0x8, fastbin_index(size) return -1, and av-&gt;fastbins[fastbin_index(size)] will cause an out-of-bounds access.12345678910struct malloc_state &#123; /* The maximum chunk size to be eligible for fastbin */ size_t max_fast; /* low 2 bits used as flags */ // 0 /* Fastbins */ // 4 mfastbinptr fastbins[NFASTBINS]; ...&#125; According to the struct of malloc_state, fb = &amp;(av-&gt;fastbins[-1]) exactly points to max_fast, thus *fb = p will make the max_fast to a large value.But in the normal situation, the chunk size cannot be 0x8 bytes, because it means that the user data is 0 byte. So we can first make use of the heap overflow vulnerability to overwrite the PREV_INUSE flag of a chunk so that it incorrectly indicates that the previous chunk is free. Due to the incorrect PREV_INUSE flag, we can get malloc() to return a chunk that overlaps an actual existing chunk. This lets us edit the size field in the existing chunk’s metadata, setting it to the invalid value of 8. When this chunk is freed and placed on the fastbin, malloc_stats-&gt;max_fast is overwritten by a large value.Then the fopen will not lead to a __malloc_consolidate, so we can conduct a fastbin dup attack.Once we make the malloc return a chosen address, we could overwrite the GOT entry of the free to the address of system PLT code. Finally we execute utelnetd -l /bin/sh to start the telnet service, then we get the root shell of R7000. I use some techniques to make the exploit more steady. To make the malloc chunks are adjacent so that the heap overflow will not corrupt other heap-based buffers, I send a very long payload to trigger closing the tcp connection in advance so that the /backup.cgi request will not calling fopen subsequently, and there will be no other malloc calling between two http requests. The httpd program’s heap state may be different when user login or logout the web management, to make the heap state consistent，I find that when I try to login the web management with wrong password for 3 times, the httpd program will redirect the user to a Router Password Reset page. I can make use of this feature to achieve a steady heap state. Reference SSD Advisory – NETGEAR Nighthawk R7000 httpd PreAuth RCE CVE-2021-31802 ZDI-20-709: HEAP OVERFLOW IN THE NETGEAR NIGHTHAWK R6700 ROUTER]]></content>
      <categories>
        <category>IoT Security</category>
      </categories>
      <tags>
        <tag>IoT Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捉虫日记漏洞总结]]></title>
    <url>%2F2020%2F10%2F10%2F%E6%8D%89%E8%99%AB%E6%97%A5%E8%AE%B0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言最近阅读了捉虫日记这本少有的讲述漏洞挖掘方法的书籍，本书虽然只有7个漏洞，但是对每个漏洞到底是如何发现的做了很详细的说明，还原了漏洞挖掘的思维过程，笔者认为这是本书最有价值的一块内容，现在大部分的文章都是讲述了漏洞原理但是对于漏洞是如何发现的内容涉及很少。漏洞的发现过程是比较琐碎的，甚至难以回忆，很容易忘记当时的发现的思路历程，所以比较难成文，笔者也将努力将原书中我比较喜欢的几个漏洞的ROOT CAUSE和如何找到做一些简单的总结。 0x00 ESCAPE FROM WWW ZONE漏洞 ROOT CAUSE由于有错误条件是两个方式共同表示的，返回值和一个参数值，当出现错误条件的时候，只设置了其中一个条件（返回值）忘记设置了参数，由于对同一个错误状态的两种表达方式不同步，最终导致这个oob 如何发现这个漏洞 观察错误条件是否是两个因素或者多个因素决定的，对于这种编程范式就可以好好审计 构造好fuzz条件，fuzz 输入payload 0x01 NULL POINTER FTW漏洞 ROOT CAUSE由于对长度信息的处理不恰当，将一个unsigned 类型直接赋值给 有符号的变量，对这个长度信息所做的任何判断大小比较都会存在风险。 如何发现这漏洞对于TLV格式的数据，定位抽取长度的变量，观察这个变量是否赋给了有符号的变量，不需要对所有的类型转换进行审计，只需要对这种标识长度的变量的类型转换进行审计就行。这种有符号的比较大小本身就是容易出问题，有符号的比较就要考虑到小于0的情况 漏洞利用造成的是NULL pointer derefernce，但是这个并不是制造成了dos，还造成了控制ip，由于这个空指针应用的偏移是可控的，所以可以落到got表中，对got表的修改，即可以在紧接着的call 目标got表函数时造成劫持 0x02 ONE KERNEL TO RULE THEM ALL 漏洞 ROOT CAUSEmemcpy函数的第一个参数是任意可变的，即使n是固定值，直接实现了write what where 如何发现这个漏洞 作者还是通过跟踪数据流向的方法在静态的审计函数的处理流程，重点关注了与长度相关的处理逻辑，但是这个漏洞不需要dst与n的不同步即可触发，或者可以理解为是不同步的一种特殊情况，由于dst是任意的，所以永远与n不同步。 除了仔细审计与长度相关的代码，还需要注意的是当涉及到与memcpy这种dst，src，和copy数目相关的函数的时候，一定要重点关注dst和num这两个值，要关注dst的来源是什么，是否和num同步，是否可能造成溢出，像这个漏洞是否dst是直接由用户指定的，这都是根据dst的来源而定的 0x03 A BUG OLDER THAN 4.4BSD 漏洞 ROOT CAUSE从payload中转化的长度信息，赋值给了有符号数，对有符号的比较，比较绕过，导致越界的访问 如何发现这个漏洞 在追踪数据流的时候，不仅对数据的长度信息关注，还需要对任何数目相关的字段关注，这些字段的比较大小是容易出错的 特别这些数目是有符号数的比较，是非常危险的，一定要注意小于0的情况是否是预期内的 0x04 THE RINGTONE MASSACRE漏洞 Fuzz方法变异策略 通过对一个合法的文件格式进行逐个字节的0xff替换 这种变异策略是相对高效的，可以找到一些简单的有关长度的漏洞，而且不需要对格式协议有详细的了解，smb也可以尝试利用同样的方法进行一些测试。 小结本文主要是对书中几个漏洞的根因进行了提炼，对根因的理解抽象才能够举一反三，所以漏洞原因也尽量精简，笔者也在整理漏洞挖掘方法，但是由于分析的漏洞数量不够多，还不好拿出分享，等到分析足够多的漏洞，到时会以makdown map的形式展示出。以后也会经常以本篇文章的形式分析一系列漏洞。 版权声明本文作者为colorlight，转载请注明出处 https://colorlight.github.io]]></content>
      <categories>
        <category>漏洞挖掘方法</category>
      </categories>
      <tags>
        <tag>如何发现漏洞</tag>
        <tag>ROOT CAUSE</tag>
        <tag>Fuzz 变异策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪造LTE地震海啸警报]]></title>
    <url>%2F2020%2F07%2F29%2F%E4%BC%AA%E9%80%A0LTE%E5%9C%B0%E9%9C%87%E6%B5%B7%E5%95%B8%E8%AD%A6%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[前言这是我在2019年的HITB和DEFCON China的议题的解读，现在同步到我的blog上 议题摘要本议题将讨论LTE协议中与PWS(Public Warning System公共预警系统)相关的安全漏洞。 PWS是向公众播报地震海啸以及其他紧急事件的预警系统，在灾难发生前，PWS系统可以为人民的生命安全争取极其宝贵的时间。我们仔细研究了LTE协议中与PWS相关部分，发现LTE空口中承载的预警信息是不经过加密以及完整性保护的，我们通过常用的软件无线电设备即可以仿造虚假的灾难预警信息，并且成功的迫使支持PWS的Android和iPhone手机发出灾难警报。通过对LTE协议中参数的精心配置，我们还实现了将灾难警报信息伪装成诈骗钓鱼以及广告短信的形式。最后我们提出了一些相应的解决办法，来防止PWS系统沦为摆设甚至成为电信诈骗的工具。 议题解析3GPP协议中规定了4种公共警报系统，分别是日本的ETWS，美国的CMAS，韩国的KPAS以及欧洲的EU-Alert。由于各个国家的安全要求不同，因此标准化工作较为困难。为了避免系统复杂性，防止漫游到其他国家手机不能正常接收警报信息，目前的标准中并未加入对警报信息的签名等验证信息。我们利用软件无线电设备USRP B210和开源的LTE测试平台srsLTE搭建LTE伪基站。为了不干扰正常用户的通信，我们的实验选择在了电磁屏蔽屋内进行。为了能够使手机发起小区重选流程，我们搭建的伪基站的参数要尽量模仿合法基站的设置，可以利用一些常用的路测软件获取当前基站的参数，如TAC PCI以及下行频点号。由于LTE的小区重选机制相对于GSM等系统较为严格，即使信号强度高于合法基站，仍然难以触发手机的小区重选，我们可以选在优先频点或者将物理小区号设置成与合法基站相同的以增加接入成功率。为了避免手机发起鉴权流程，要将TAC设置成与合法基站一样的，手机无法发起位置区更新，则不会对伪基站的合法性进行甄别。LTE协议中直接携带警报信息内容的是系统广播信息System information，其中SIB 10携带的是日本的ETWS的第一级警报信息，此信息仅包含固定的警报消息类型，如地震海啸或者其他紧急警报。SIB 11中携带的是ETWS的第二级警报信息，包含具体的警报内容，如地震中心，地震强度等，此信息是自定义的。SIB 12是携带的CMAS KPAS和EU-ALERT警报消息。由于ETWS相较于其他系统分为两个等级的警报信息，较为复杂，我们以ETWS为例进行伪造警报消息。除了SIB10 SIB11直接携带警报消息外，SIB 1负责对SIB10以及SIB11的调度，paging消息负责向用户手机提示有警报消息需要接收。由于srsLTE中没有针对SIB10的定义与实现，我们需要比照协议对SIB10进行构造，其中messageIdentifer字段标识了消息类型，地震警报需要将此值设置为0x1102。其他参数的具体配置可以参看截图。我们需要在srsLTE源码中添加对paging消息的修改，使paging消息中增加对ETWS警报信息的指示。其实我们不仅可以利用ETWS消息发送地震警报，我们甚至可以它改造成一个广告诈骗等垃圾短信。将message identifier字段设置为0x1104就可以使手机不发出警报声，但是仍弹出信息内容。以上是我们在Google Pixel手机上分别伪造的地震警报信息和添加了钓鱼电话的诈骗信息。由于中国没有在手机移动网络中支持公共报警服务，因此国内版的Android手机并不会对伪造的警报信息作出响应，同时国行版的苹果手机也仅在MCC为001,MNC为01的测试网络中对警报信息作出响应。公共警报信息的不加密造成的潜在安全威胁还是较大的，如果在人口密集处如满座的球场内发送警报信息有可能导致踩踏事件。2018年的夏威夷导弹误警报就是基于美国的PWS系统CMAS传播的，这导致了全城的恐慌和社会混乱。目前可以利用非对称加密的机制对警报信息添加签名信息来防止恶意伪造的虚假警报。由于各国对警报消息的要求不同，3GPP的警报的标准化进行较为困难，导致数字签名验证机制并没有作为一种强制执行要求，所以现在的手机均是不验证警报消息的合法性的。 攻击演示 参考链接 HAXPO: This is a Public Service Announcement: Hacking LTE Public Warning Systems WARNING: Magnitude 10 Earthquake Is Coming in One Minute 安全客|HITB议题解读 | 伪造LTE地震海啸警信息 HAXPO D1 - Hacking LTE Public Warning Systems - Weiguang Li.pdf 版权声明本文作者为colorlight，首发于安全客转载请注明出处 https://colorlight.github.io/2020/07/29/伪造LTE地震海啸警报/]]></content>
      <categories>
        <category>LTE security</category>
      </categories>
      <tags>
        <tag>PWS</tag>
        <tag>LTE安全</tag>
        <tag>伪造地震消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈i/o底层过程]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B5%85%E8%B0%88i-o%E5%BA%95%E5%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[操作系统将所有的io都抽象为了一个文件的读写，我浅谈底层一点的模型。以这两个语句为例12read(file, tmp_buf, len);write(socket, tmp_buf, len); 分别是从文件读数据到tmp_buf用户的内存，再从tmp_buf发送到socket 这个过程中发生了什么，CPU 内存 硬盘 和 网卡之间是如何进行交互的呢。 简单的两句话，却包含着4次复制过程！读写分别两次。 read过程 硬盘通过DMA机制将数据复制到操作系统内核内存缓冲区中 操作系统通过CPU将内核内存复制到用户内存 write过程 操作系统通过CPU将用户内存复制到socket内核内存 网卡DMA机制将内核内存复制到网卡 减少复制的方法这两句话造成的复制太多了，为了较少复制的次数可以使用 mmap： tmp_buf = mmap(file, len)， 这样可以省去内核到用户空间的复制 sendfile()： sendfile(socket, file, len) 这种新的系统调用可以省去用户缓冲区的存在由于读文件的内核缓冲区与socket的内核缓冲区不同，仍需要这二者之间的复制。但是如果支持零拷贝的情况下，也不需要二者之间的复制了。一共只需要两次复制。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>I/O</tag>
        <tag>mmap</tag>
      </tags>
  </entry>
</search>
